diff --git a/components/prism-core.js b/components/prism-core.js
index 1259f23e07c9c4e62f32a7705e9fbb7d52c8c060..30947c7c9ef12d1794ffcbcb1fce4dc90901db61 100644
--- a/components/prism-core.js
+++ b/components/prism-core.js
@@ -1,13 +1,3 @@
-/// <reference lib="WebWorker"/>
-
-var _self = (typeof window !== 'undefined')
-	? window   // if in browser
-	: (
-		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
-			? self // if in worker
-			: {}   // if in node js
-	);
-
 /**
  * Prism: Lightweight, robust, elegant syntax highlighting
  *
@@ -16,61 +6,13 @@ var _self = (typeof window !== 'undefined')
  * @namespace
  * @public
  */
-var Prism = (function (_self) {
-
-	// Private helper vars
-	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
-	var uniqueId = 0;
+var Prism = ((_self) => {
 
 	// The grammar object for plaintext
 	var plainTextGrammar = {};
 
-
 	var _ = {
-		/**
-		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
-		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
-		 * additional languages or plugins yourself.
-		 *
-		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
-		 *
-		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
-		 * empty Prism object into the global scope before loading the Prism script like this:
-		 *
-		 * ```js
-		 * window.Prism = window.Prism || {};
-		 * Prism.manual = true;
-		 * // add a new <script> to load Prism's script
-		 * ```
-		 *
-		 * @default false
-		 * @type {boolean}
-		 * @memberof Prism
-		 * @public
-		 */
-		manual: _self.Prism && _self.Prism.manual,
-		/**
-		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
-		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
-		 * own worker, you don't want it to do this.
-		 *
-		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
-		 *
-		 * You obviously have to change this value before Prism executes. To do this, you can add an
-		 * empty Prism object into the global scope before loading the Prism script like this:
-		 *
-		 * ```js
-		 * window.Prism = window.Prism || {};
-		 * Prism.disableWorkerMessageHandler = true;
-		 * // Load Prism's script
-		 * ```
-		 *
-		 * @default false
-		 * @type {boolean}
-		 * @memberof Prism
-		 * @public
-		 */
-		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
+		manual: true,
 
 		/**
 		 * A namespace for utility methods.
@@ -82,16 +24,6 @@ var Prism = (function (_self) {
 		 * @memberof Prism
 		 */
 		util: {
-			encode: function encode(tokens) {
-				if (tokens instanceof Token) {
-					return new Token(tokens.type, encode(tokens.content), tokens.alias);
-				} else if (Array.isArray(tokens)) {
-					return tokens.map(encode);
-				} else {
-					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
-				}
-			},
-
 			/**
 			 * Returns the name of the type of the given value.
 			 *
@@ -108,21 +40,8 @@ var Prism = (function (_self) {
 			 * type(String)    === 'Function'
 			 * type(/abc+/)    === 'RegExp'
 			 */
-			type: function (o) {
-				return Object.prototype.toString.call(o).slice(8, -1);
-			},
-
-			/**
-			 * Returns a unique number for the given object. Later calls will still return the same number.
-			 *
-			 * @param {Object} obj
-			 * @returns {number}
-			 */
-			objId: function (obj) {
-				if (!obj['__id']) {
-					Object.defineProperty(obj, '__id', { value: ++uniqueId });
-				}
-				return obj['__id'];
+			type(o) {
+				return {}.toString.call(o).slice(8, -1);
 			},
 
 			/**
@@ -135,157 +54,27 @@ var Prism = (function (_self) {
 			 * @returns {T}
 			 * @template T
 			 */
-			clone: function deepClone(o, visited) {
-				visited = visited || {};
-
-				var clone; var id;
-				switch (_.util.type(o)) {
-					case 'Object':
-						id = _.util.objId(o);
-						if (visited[id]) {
-							return visited[id];
-						}
-						clone = /** @type {Record<string, any>} */ ({});
-						visited[id] = clone;
-
-						for (var key in o) {
-							if (o.hasOwnProperty(key)) {
-								clone[key] = deepClone(o[key], visited);
-							}
-						}
-
-						return /** @type {any} */ (clone);
-
-					case 'Array':
-						id = _.util.objId(o);
-						if (visited[id]) {
-							return visited[id];
-						}
-						clone = [];
-						visited[id] = clone;
-
-						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
-							clone[i] = deepClone(v, visited);
-						});
-
-						return /** @type {any} */ (clone);
-
-					default:
-						return o;
-				}
-			},
-
-			/**
-			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
-			 *
-			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
-			 *
-			 * @param {Element} element
-			 * @returns {string}
-			 */
-			getLanguage: function (element) {
-				while (element) {
-					var m = lang.exec(element.className);
-					if (m) {
-						return m[1].toLowerCase();
+			clone(o, visited = new Map) {
+				if (visited.has(o)) return visited.get(o);
+				var clone, type = _.util.type(o);
+				if (type == "Array") {
+					visited.set(o, clone = []);
+					for (var i = 0, l = o.length; i < l; i++) {
+						clone[i] = this.clone(o[i], visited);
 					}
-					element = element.parentElement;
-				}
-				return 'none';
-			},
-
-			/**
-			 * Sets the Prism `language-xxxx` class of the given element.
-			 *
-			 * @param {Element} element
-			 * @param {string} language
-			 * @returns {void}
-			 */
-			setLanguage: function (element, language) {
-				// remove all `language-xxxx` classes
-				// (this might leave behind a leading space)
-				element.className = element.className.replace(RegExp(lang, 'gi'), '');
-
-				// add the new `language-xxxx` class
-				// (using `classList` will automatically clean up spaces for us)
-				element.classList.add('language-' + language);
-			},
-
-			/**
-			 * Returns the script element that is currently executing.
-			 *
-			 * This does __not__ work for line script element.
-			 *
-			 * @returns {HTMLScriptElement | null}
-			 */
-			currentScript: function () {
-				if (typeof document === 'undefined') {
-					return null;
-				}
-				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
-					return /** @type {any} */ (document.currentScript);
+					return clone;
 				}
-
-				// IE11 workaround
-				// we'll get the src of the current script by parsing IE11's error stack trace
-				// this will not work for inline scripts
-
-				try {
-					throw new Error();
-				} catch (err) {
-					// Get file src url from stack. Specifically works with the format of stack traces in IE.
-					// A stack will look like this:
-					//
-					// Error
-					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
-					//    at Global code (http://localhost/components/prism-core.js:606:1)
-
-					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
-					if (src) {
-						var scripts = document.getElementsByTagName('script');
-						for (var i in scripts) {
-							if (scripts[i].src == src) {
-								return scripts[i];
-							}
+				
+				if (type == "Object") {
+					visited.set(o, clone = {});
+					for (var key in o) {
+						if (o.hasOwnProperty(key)) {
+							clone[key] = this.clone(o[key], visited);
 						}
 					}
-					return null;
+					return clone;
 				}
-			},
-
-			/**
-			 * Returns whether a given class is active for `element`.
-			 *
-			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
-			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
-			 * given class is just the given class with a `no-` prefix.
-			 *
-			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
-			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
-			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
-			 *
-			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
-			 * version of it, the class is considered active.
-			 *
-			 * @param {Element} element
-			 * @param {string} className
-			 * @param {boolean} [defaultActivation=false]
-			 * @returns {boolean}
-			 */
-			isActive: function (element, className, defaultActivation) {
-				var no = 'no-' + className;
-
-				while (element) {
-					var classList = element.classList;
-					if (classList.contains(className)) {
-						return true;
-					}
-					if (classList.contains(no)) {
-						return false;
-					}
-					element = element.parentElement;
-				}
-				return !!defaultActivation;
+				return o;
 			}
 		},
 
@@ -333,7 +122,7 @@ var Prism = (function (_self) {
 			 *     'color': /\b(?:red|green|blue)\b/
 			 * });
 			 */
-			extend: function (id, redef) {
+			extend(id, redef) {
 				var lang = _.util.clone(_.languages[id]);
 
 				for (var key in redef) {
@@ -418,255 +207,35 @@ var Prism = (function (_self) {
 			 * @returns {Grammar} The new grammar object.
 			 * @public
 			 */
-			insertBefore: function (inside, before, insert, root) {
-				root = root || /** @type {any} */ (_.languages);
-				var grammar = root[inside];
-				/** @type {Grammar} */
-				var ret = {};
+			insertBefore(inside, before, insert, root = _.languages) {
+				var grammar = root[inside]
 
 				for (var token in grammar) {
 					if (grammar.hasOwnProperty(token)) {
+						var val = grammar[token];
+						delete grammar[token];
 
 						if (token == before) {
 							for (var newToken in insert) {
 								if (insert.hasOwnProperty(newToken)) {
-									ret[newToken] = insert[newToken];
+									grammar[newToken] = insert[newToken];
 								}
 							}
 						}
 
 						// Do not insert token which also occur in insert. See #1525
 						if (!insert.hasOwnProperty(token)) {
-							ret[token] = grammar[token];
+							grammar[token] = val;
 						}
 					}
 				}
 
-				var old = root[inside];
-				root[inside] = ret;
-
-				// Update references in other language definitions
-				_.languages.DFS(_.languages, function (key, value) {
-					if (value === old && key != inside) {
-						this[key] = ret;
-					}
-				});
-
-				return ret;
-			},
-
-			// Traverse a language definition with Depth First Search
-			DFS: function DFS(o, callback, type, visited) {
-				visited = visited || {};
-
-				var objId = _.util.objId;
-
-				for (var i in o) {
-					if (o.hasOwnProperty(i)) {
-						callback.call(o, i, o[i], type || i);
-
-						var property = o[i];
-						var propertyType = _.util.type(property);
-
-						if (propertyType === 'Object' && !visited[objId(property)]) {
-							visited[objId(property)] = true;
-							DFS(property, callback, null, visited);
-						} else if (propertyType === 'Array' && !visited[objId(property)]) {
-							visited[objId(property)] = true;
-							DFS(property, callback, i, visited);
-						}
-					}
-				}
+				return grammar;
 			}
 		},
 
 		plugins: {},
 
-		/**
-		 * This is the most high-level function in Prism’s API.
-		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
-		 * each one of them.
-		 *
-		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
-		 *
-		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
-		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightAll: function (async, callback) {
-			_.highlightAllUnder(document, async, callback);
-		},
-
-		/**
-		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
-		 * {@link Prism.highlightElement} on each one of them.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-highlightall`
-		 * 2. `before-all-elements-highlight`
-		 * 3. All hooks of {@link Prism.highlightElement} for each element.
-		 *
-		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
-		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
-		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightAllUnder: function (container, async, callback) {
-			var env = {
-				callback: callback,
-				container: container,
-				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
-			};
-
-			_.hooks.run('before-highlightall', env);
-
-			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
-
-			_.hooks.run('before-all-elements-highlight', env);
-
-			for (var i = 0, element; (element = env.elements[i++]);) {
-				_.highlightElement(element, async === true, env.callback);
-			}
-		},
-
-		/**
-		 * Highlights the code inside a single element.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-sanity-check`
-		 * 2. `before-highlight`
-		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
-		 * 4. `before-insert`
-		 * 5. `after-highlight`
-		 * 6. `complete`
-		 *
-		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
-		 * the element's language.
-		 *
-		 * @param {Element} element The element containing the code.
-		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
-		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
-		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
-		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
-		 *
-		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
-		 * asynchronous highlighting to work. You can build your own bundle on the
-		 * [Download page](https://prismjs.com/download.html).
-		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
-		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightElement: function (element, async, callback) {
-			// Find language
-			var language = _.util.getLanguage(element);
-			var grammar = _.languages[language];
-
-			// Set language on the element, if not present
-			_.util.setLanguage(element, language);
-
-			// Set language on the parent, for styling
-			var parent = element.parentElement;
-			if (parent && parent.nodeName.toLowerCase() === 'pre') {
-				_.util.setLanguage(parent, language);
-			}
-
-			var code = element.textContent;
-
-			var env = {
-				element: element,
-				language: language,
-				grammar: grammar,
-				code: code
-			};
-
-			function insertHighlightedCode(highlightedCode) {
-				env.highlightedCode = highlightedCode;
-
-				_.hooks.run('before-insert', env);
-
-				env.element.innerHTML = env.highlightedCode;
-
-				_.hooks.run('after-highlight', env);
-				_.hooks.run('complete', env);
-				callback && callback.call(env.element);
-			}
-
-			_.hooks.run('before-sanity-check', env);
-
-			// plugins may change/add the parent/element
-			parent = env.element.parentElement;
-			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
-				parent.setAttribute('tabindex', '0');
-			}
-
-			if (!env.code) {
-				_.hooks.run('complete', env);
-				callback && callback.call(env.element);
-				return;
-			}
-
-			_.hooks.run('before-highlight', env);
-
-			if (!env.grammar) {
-				insertHighlightedCode(_.util.encode(env.code));
-				return;
-			}
-
-			if (async && _self.Worker) {
-				var worker = new Worker(_.filename);
-
-				worker.onmessage = function (evt) {
-					insertHighlightedCode(evt.data);
-				};
-
-				worker.postMessage(JSON.stringify({
-					language: env.language,
-					code: env.code,
-					immediateClose: true
-				}));
-			} else {
-				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
-			}
-		},
-
-		/**
-		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
-		 * and the language definitions to use, and returns a string with the HTML produced.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-tokenize`
-		 * 2. `after-tokenize`
-		 * 3. `wrap`: On each {@link Token}.
-		 *
-		 * @param {string} text A string with the code to be highlighted.
-		 * @param {Grammar} grammar An object containing the tokens to use.
-		 *
-		 * Usually a language definition like `Prism.languages.markup`.
-		 * @param {string} language The name of the language definition passed to `grammar`.
-		 * @returns {string} The highlighted HTML.
-		 * @memberof Prism
-		 * @public
-		 * @example
-		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
-		 */
-		highlight: function (text, grammar, language) {
-			var env = {
-				code: text,
-				grammar: grammar,
-				language: language
-			};
-			_.hooks.run('before-tokenize', env);
-			if (!env.grammar) {
-				throw new Error('The language "' + env.language + '" has no grammar.');
-			}
-			env.tokens = _.tokenize(env.code, env.grammar);
-			_.hooks.run('after-tokenize', env);
-			return Token.stringify(_.util.encode(env.tokens), env.language);
-		},
-
 		/**
 		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
 		 * and the language definitions to use, and returns an array with the tokenized code.
@@ -691,7 +260,7 @@ var Prism = (function (_self) {
 		 *     }
 		 * });
 		 */
-		tokenize: function (text, grammar) {
+		tokenize(text, grammar) {
 			var rest = grammar.rest;
 			if (rest) {
 				for (var token in rest) {
@@ -705,8 +274,14 @@ var Prism = (function (_self) {
 			addAfter(tokenList, tokenList.head, text);
 
 			matchGrammar(text, tokenList, grammar, tokenList.head, 0);
-
-			return toArray(tokenList);
+			
+			var array = [], i = 0;
+			var node = tokenList.head.next;
+			while (node != tokenList.tail) {
+				array[i++] = node.value;
+				node = node.next;
+			}
+			return array;
 		},
 
 		/**
@@ -729,12 +304,9 @@ var Prism = (function (_self) {
 			 * @param {HookCallback} callback The callback function which is given environment variables.
 			 * @public
 			 */
-			add: function (name, callback) {
+			add(name, callback) {
 				var hooks = _.hooks.all;
-
-				hooks[name] = hooks[name] || [];
-
-				hooks[name].push(callback);
+				(hooks[name] || (hooks[name] = [])).push(callback);
 			},
 
 			/**
@@ -746,20 +318,16 @@ var Prism = (function (_self) {
 			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
 			 * @public
 			 */
-			run: function (name, env) {
+			run(name, env) {
 				var callbacks = _.hooks.all[name];
 
-				if (!callbacks || !callbacks.length) {
-					return;
-				}
-
-				for (var i = 0, callback; (callback = callbacks[i++]);) {
+				if (callbacks) for (var i = 0, callback; callback = callbacks[i++]; ) {
 					callback(env);
 				}
 			}
 		},
 
-		Token: Token
+		Token
 	};
 	_self.Prism = _;
 
@@ -812,74 +380,6 @@ var Prism = (function (_self) {
 		this.length = (matchedStr || '').length | 0;
 	}
 
-	/**
-	 * A token stream is an array of strings and {@link Token Token} objects.
-	 *
-	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
-	 * them.
-	 *
-	 * 1. No adjacent strings.
-	 * 2. No empty strings.
-	 *
-	 *    The only exception here is the token stream that only contains the empty string and nothing else.
-	 *
-	 * @typedef {Array<string | Token>} TokenStream
-	 * @global
-	 * @public
-	 */
-
-	/**
-	 * Converts the given token or token stream to an HTML representation.
-	 *
-	 * The following hooks will be run:
-	 * 1. `wrap`: On each {@link Token}.
-	 *
-	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
-	 * @param {string} language The name of current language.
-	 * @returns {string} The HTML representation of the token or token stream.
-	 * @memberof Token
-	 * @static
-	 */
-	Token.stringify = function stringify(o, language) {
-		if (typeof o == 'string') {
-			return o;
-		}
-		if (Array.isArray(o)) {
-			var s = '';
-			o.forEach(function (e) {
-				s += stringify(e, language);
-			});
-			return s;
-		}
-
-		var env = {
-			type: o.type,
-			content: stringify(o.content, language),
-			tag: 'span',
-			classes: ['token', o.type],
-			attributes: {},
-			language: language
-		};
-
-		var aliases = o.alias;
-		if (aliases) {
-			if (Array.isArray(aliases)) {
-				Array.prototype.push.apply(env.classes, aliases);
-			} else {
-				env.classes.push(aliases);
-			}
-		}
-
-		_.hooks.run('wrap', env);
-
-		var attributes = '';
-		for (var name in env.attributes) {
-			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
-		}
-
-		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
-	};
-
 	/**
 	 * @param {RegExp} pattern
 	 * @param {number} pos
@@ -887,7 +387,7 @@ var Prism = (function (_self) {
 	 * @param {boolean} lookbehind
 	 * @returns {RegExpExecArray | null}
 	 */
-	function matchPattern(pattern, pos, text, lookbehind) {
+	var matchPattern = (pattern, pos, text, lookbehind) => {
 		pattern.lastIndex = pos;
 		var match = pattern.exec(text);
 		if (match && lookbehind && match[1]) {
@@ -913,7 +413,7 @@ var Prism = (function (_self) {
 	 * @property {string} cause
 	 * @property {number} reach
 	 */
-	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
+	var matchGrammar = (text, tokenList, grammar, startNode, startPos, rematch) => {
 		for (var token in grammar) {
 			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
 				continue;
@@ -1096,7 +596,7 @@ var Prism = (function (_self) {
 	 * @returns {LinkedListNode<T>} The added node.
 	 * @template T
 	 */
-	function addAfter(list, node, value) {
+	var addAfter = (list, node, value) => {
 		// assumes that node != list.tail && values.length >= 0
 		var next = node.next;
 
@@ -1115,7 +615,7 @@ var Prism = (function (_self) {
 	 * @param {number} count
 	 * @template T
 	 */
-	function removeRange(list, node, count) {
+	var removeRange = (list, node, count) => {
 		var next = node.next;
 		for (var i = 0; i < count && next !== list.tail; i++) {
 			next = next.next;
@@ -1124,95 +624,10 @@ var Prism = (function (_self) {
 		next.prev = node;
 		list.length -= i;
 	}
-	/**
-	 * @param {LinkedList<T>} list
-	 * @returns {T[]}
-	 * @template T
-	 */
-	function toArray(list) {
-		var array = [];
-		var node = list.head.next;
-		while (node !== list.tail) {
-			array.push(node.value);
-			node = node.next;
-		}
-		return array;
-	}
-
-
-	if (!_self.document) {
-		if (!_self.addEventListener) {
-			// in Node.js
-			return _;
-		}
-
-		if (!_.disableWorkerMessageHandler) {
-			// In worker
-			_self.addEventListener('message', function (evt) {
-				var message = JSON.parse(evt.data);
-				var lang = message.language;
-				var code = message.code;
-				var immediateClose = message.immediateClose;
-
-				_self.postMessage(_.highlight(code, _.languages[lang], lang));
-				if (immediateClose) {
-					_self.close();
-				}
-			}, false);
-		}
-
-		return _;
-	}
-
-	// Get current script and highlight
-	var script = _.util.currentScript();
-
-	if (script) {
-		_.filename = script.src;
-
-		if (script.hasAttribute('data-manual')) {
-			_.manual = true;
-		}
-	}
-
-	function highlightAutomaticallyCallback() {
-		if (!_.manual) {
-			_.highlightAll();
-		}
-	}
-
-	if (!_.manual) {
-		// If the document state is "loading", then we'll use DOMContentLoaded.
-		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
-		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
-		// might take longer one animation frame to execute which can create a race condition where only some plugins have
-		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
-		// See https://github.com/PrismJS/prism/issues/2102
-		var readyState = document.readyState;
-		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
-			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
-		} else {
-			if (window.requestAnimationFrame) {
-				window.requestAnimationFrame(highlightAutomaticallyCallback);
-			} else {
-				window.setTimeout(highlightAutomaticallyCallback, 16);
-			}
-		}
-	}
 
 	return _;
 
-}(_self));
-
-if (typeof module !== 'undefined' && module.exports) {
-	module.exports = Prism;
-}
-
-// hack for components to work correctly in node.js
-if (typeof global !== 'undefined') {
-	global.Prism = Prism;
-}
-
+})(window);
 // some additional documentation/types
 
 /**
diff --git a/components/prism-markdown.js b/components/prism-markdown.js
index 438f8ed8fcb682061959a2bf1be8d467861b7ecd..10c61e9c4e2dd61dffe46308f5ba5bb1875fd64e 100644
--- a/components/prism-markdown.js
+++ b/components/prism-markdown.js
@@ -1,4 +1,4 @@
-(function (Prism) {
+(Prism => {
 
 	// Allow only one line break
 	var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
@@ -10,21 +10,16 @@
 	 *
 	 * _Note:_ Keep in mind that this adds a capturing group.
 	 *
-	 * @param {string} pattern
+	 * @param {RegExp} pattern
 	 * @returns {RegExp}
 	 */
-	function createInline(pattern) {
-		pattern = pattern.replace(/<inner>/g, function () { return inner; });
-		return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
-	}
-
+	var createInline = pattern => RegExp(`((?:^|[^\\\\])(?:\\\\{2})*)(?:${pattern.source.replace(/<inner>/g, inner)})`);
 
 	var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
-	var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () { return tableCell; });
+	var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, tableCell);
 	var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
 
-
-	Prism.languages.markdown = Prism.languages.extend('markup', {});
+	Prism.languages.markdown = Prism.languages.md = Prism.languages.extend('markup', {});
 	Prism.languages.insertBefore('markdown', 'prolog', {
 		'front-matter-block': {
 			pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
@@ -167,7 +162,7 @@
 			// __strong__
 
 			// allow one nested instance of italic text using the same delimiter
-			pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
+			pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/),
 			lookbehind: true,
 			greedy: true,
 			inside: {
@@ -184,7 +179,7 @@
 			// _em_
 
 			// allow one nested instance of bold text using the same delimiter
-			pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
+			pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/),
 			lookbehind: true,
 			greedy: true,
 			inside: {
@@ -200,7 +195,7 @@
 			// ~~strike through~~
 			// ~strike~
 			// eslint-disable-next-line regexp/strict
-			pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
+			pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/),
 			lookbehind: true,
 			greedy: true,
 			inside: {
@@ -224,7 +219,7 @@
 			// [example](http://example.com "Optional title")
 			// [example][id]
 			// [example] [id]
-			pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
+			pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/),
 			lookbehind: true,
 			greedy: true,
 			inside: {
@@ -250,166 +245,52 @@
 		}
 	});
 
-	['url', 'bold', 'italic', 'strike'].forEach(function (token) {
-		['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
-			if (token !== inside) {
+	['url', 'bold', 'italic', 'strike'].forEach(token => {
+		['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(inside => {
+			if (token != inside) {
 				Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
 			}
 		});
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
-		if (env.language !== 'markdown' && env.language !== 'md') {
-			return;
-		}
-
-		function walkTokens(tokens) {
-			if (!tokens || typeof tokens === 'string') {
-				return;
-			}
-
-			for (var i = 0, l = tokens.length; i < l; i++) {
-				var token = tokens[i];
-
-				if (token.type !== 'code') {
-					walkTokens(token.content);
-					continue;
-				}
-
-				/*
-				 * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
-				 * is optional. But the grammar is defined so that there is only one case we have to handle:
-				 *
-				 * token.content = [
-				 *     <span class="punctuation">```</span>,
-				 *     <span class="code-language">xxxx</span>,
-				 *     '\n', // exactly one new lines (\r or \n or \r\n)
-				 *     <span class="code-block">...</span>,
-				 *     '\n', // exactly one new lines again
-				 *     <span class="punctuation">```</span>
-				 * ];
-				 */
-
-				var codeLang = token.content[1];
-				var codeBlock = token.content[3];
-
-				if (codeLang && codeBlock &&
-					codeLang.type === 'code-language' && codeBlock.type === 'code-block' &&
-					typeof codeLang.content === 'string') {
-
-					// this might be a language that Prism does not support
-
-					// do some replacements to support C++, C#, and F#
-					var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp');
-					// only use the first word
-					lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
-					var alias = 'language-' + lang;
-
-					// add alias
-					if (!codeBlock.alias) {
-						codeBlock.alias = [alias];
-					} else if (typeof codeBlock.alias === 'string') {
-						codeBlock.alias = [codeBlock.alias, alias];
-					} else {
-						codeBlock.alias.push(alias);
+	var walkTokens = tokens => {
+		if (Array.isArray(tokens)) for (var i = 0, l = tokens.length; i < l; i++) {
+			var token = tokens[i];
+
+			if (typeof token != 'string') {
+				if (token.type != 'code') walkTokens(token.content);
+				else {
+					var [, codeLang, , codeBlock] = token.content;
+
+					if (codeBlock?.type == 'code-block' && codeLang?.type == 'code-language') {
+						var language = (/[a-z][\w-]*/i.exec(
+							codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp')
+						) || [''])[0].toLowerCase();
+						
+						var alias = 'langauge-' + language;
+						var blockAlias = codeBlock.alias;
+						var code = codeBlock.content;
+						var grammar = Prism.languages[language];
+						
+						codeBlock.alias = !blockAlias ? 
+						[alias] : Array.isArray(blockAlias) ? 
+						blockAlias.concat(alias) : [blockAlias, alias];
+						
+						if (grammar && typeof code == 'string') {
+							var env = { code, language, grammar };
+							Prism.hooks.run('before-tokenize', env);
+							codeBlock.content = env.tokens = Prism.tokenize(env.code, env.grammar);
+							Prism.hooks.run('after-tokenize', env);
+						}
 					}
 				}
 			}
 		}
 
-		walkTokens(env.tokens);
-	});
-
-	Prism.hooks.add('wrap', function (env) {
-		if (env.type !== 'code-block') {
-			return;
-		}
-
-		var codeLang = '';
-		for (var i = 0, l = env.classes.length; i < l; i++) {
-			var cls = env.classes[i];
-			var match = /language-(.+)/.exec(cls);
-			if (match) {
-				codeLang = match[1];
-				break;
-			}
-		}
-
-		var grammar = Prism.languages[codeLang];
-
-		if (!grammar) {
-			if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
-				var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
-				env.attributes['id'] = id;
-
-				Prism.plugins.autoloader.loadLanguages(codeLang, function () {
-					var ele = document.getElementById(id);
-					if (ele) {
-						ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
-					}
-				});
-			}
-		} else {
-			env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
-		}
-	});
-
-	var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');
-
-	/**
-	 * A list of known entity names.
-	 *
-	 * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
-	 *
-	 * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
-	 */
-	var KNOWN_ENTITY_NAMES = {
-		'amp': '&',
-		'lt': '<',
-		'gt': '>',
-		'quot': '"',
-	};
-
-	// IE 11 doesn't support `String.fromCodePoint`
-	var fromCodePoint = String.fromCodePoint || String.fromCharCode;
-
-	/**
-	 * Returns the text content of a given HTML source code string.
-	 *
-	 * @param {string} html
-	 * @returns {string}
-	 */
-	function textContent(html) {
-		// remove all tags
-		var text = html.replace(tagPattern, '');
-
-		// decode known entities
-		text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
-			code = code.toLowerCase();
-
-			if (code[0] === '#') {
-				var value;
-				if (code[1] === 'x') {
-					value = parseInt(code.slice(2), 16);
-				} else {
-					value = Number(code.slice(1));
-				}
-
-				return fromCodePoint(value);
-			} else {
-				var known = KNOWN_ENTITY_NAMES[code];
-				if (known) {
-					return known;
-				}
-
-				// unable to decode
-				return m;
-			}
-		});
-
-		return text;
 	}
 
-	Prism.languages.md = Prism.languages.markdown;
+	Prism.hooks.add('after-tokenize', env => {
+		if (env.language == 'markdown' || env.language == 'md') walkTokens(env.tokens);
+	});
 
-}(Prism));
+})(Prism);