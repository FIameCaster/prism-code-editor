---
title: Server side rendering
description: Learn how you can render an editor on the server and make it interactive on the client.
---

import "../../../components/languages/ts.astro"
import "prism-code-editor/layout.css"
import "prism-code-editor/scrollbar.css"
import "../../../css/editor-theme.css"

This library supports rendering an editor as an HTML string on a server and mounting the editor on the client. This has multiple advantages. Layout shifts can be completely avoided, and the editors will be visible before the JavaScript has been executed. This is the method used to render editors on this documentation website.

## Rendering on the server

[`renderEditor(){:js}`](/api-reference/ssr/f-rendereditor) renders an editor with the specified [`EditorOptions{:js}`](/api-reference/index/t-editoroptions) as an HTML string. The event handler options such as `onUpdate` are ignored.

```js editor
import "prism-code-editor/prism/languages/javascript"
import { renderEditor } from "prism-code-editor/ssr"

const html = renderEditor({
	language: "javascript",
	value: 'const foo = "bar"'
})
```

### Rendering options

```js editor
import "prism-code-editor/prism/languages/javascript"
import { renderEditor, rainbowBrackets } from "prism-code-editor/ssr"

const html = renderEditor({
	language: "javascript",
	value: 'const foo = "bar"'
}, {
	tokenizeCallback: rainbowBrackets()
})
```

The second argument can be used to customize the output. Currently, only a single property is accepted: `tokenizeCallback`. This function is called before the tokens are stringified to HTML and can be used to modify them. If you're using [`matchBrackets(){:js}`](/api-reference/match-brackets/f-matchbrackets) for example, these same modifications should be done one the server. If you don't, the editor will flash with incorrect tokens.

## Mounting on the client

The editors created from plain HTML are obviously not interactive. They must be mounted on the client using [`mountEditorsUnder(){:js}`](/api-reference/client/f-mounteditorsunder). This function mounts all editors under the specified root in document order. Editors that have already been mounted are skipped.

### Adding extensions

```js editor
import "prism-code-editor/prism/languages/javascript"
import { mountEditorsUnder } from "prism-code-editor/client"
import { matchBrackets } from "prism-code-editor/match-brackets"
import { indentGuides } from "prism-code-editor/guides"

const editors = mountEditorsUnder(
	document,
	options => [
		matchBrackets(),
		indentGuides()
	]
)
```

The second argument receives the options for an editor and returns the extensions that editor should be initialized with. This means you can add different extensions to editors with different options.

## Adding extra options

You can define extra properties for `renderEditor(){:js}` that will get stringified as JSON and later parsed by `mountEditorsUnder(){:js}`. This can be very useful for configuring which extensions to add. Take this example:

```ts editor file="server.ts"
import "prism-code-editor/prism/languages/javascript"
import { renderEditor } from "prism-code-editor/ssr"

export type MyOptions = {
	hasHistory?: boolean
}

const html = renderEditor<MyOptions>({
	language: "javascript",
	value: 'const foo = "bar"',
	hasHistory: true
})
```

```ts editor file="client.ts"
import "prism-code-editor/prism/languages/javascript"
import { mountEditorsUnder } from "prism-code-editor/client"
import { editHistory } from "prism-code-editor/commands"
import type { MyOptions } from "./server"

const editors = mountEditorsUnder<MyOptions>(
	document,
	options => {
		if (options.hasHistory) {
			return [editHistory()]
		}
	}
)
```

## Usage in Practice

Many of the examples shown on this page might seem abstract. This is beacuse the SSR utilities are meant to be usable with many technologies. It's your job to integrate this API with the server side framework, static site generator, etc. you're using. Here's a [working example](https://stackblitz.com/edit/withastro-astro-yfajet?file=src%2Fcomponents%2Fmount.ts,src%2Fcomponents%2Fextensions.ts,src%2Fcomponents%2FEditor.astro) for [astro](https://astro.build).

### With markdown

There are markdown plugins for both [rehype](https://github.com/rehypejs/rehype) and [marked](https://github.com/markedjs/marked) that can create editors from fenced code blocks. These use `renderEditor(){:js}` under the hood. Read [their documentation](/markdown-plugins/getting-started) to learn more.
