diff --git a/components/prism-core.js b/components/prism-core.js
index 1259f23e07c9c4e62f32a7705e9fbb7d52c8c060..fca2d538c687a773e16a88ea6fccfa54de23b41b 100644
--- a/components/prism-core.js
+++ b/components/prism-core.js
@@ -1,13 +1,3 @@
-/// <reference lib="WebWorker"/>
-
-var _self = (typeof window !== 'undefined')
-	? window   // if in browser
-	: (
-		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
-			? self // if in worker
-			: {}   // if in node js
-	);
-
 /**
  * Prism: Lightweight, robust, elegant syntax highlighting
  *
@@ -16,61 +6,39 @@ var _self = (typeof window !== 'undefined')
  * @namespace
  * @public
  */
-var Prism = (function (_self) {
-
-	// Private helper vars
-	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
-	var uniqueId = 0;
+(() => {
 
 	// The grammar object for plaintext
 	var plainTextGrammar = {};
 
+	var hooks = {};
 
-	var _ = {
-		/**
-		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
-		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
-		 * additional languages or plugins yourself.
-		 *
-		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
-		 *
-		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
-		 * empty Prism object into the global scope before loading the Prism script like this:
-		 *
-		 * ```js
-		 * window.Prism = window.Prism || {};
-		 * Prism.manual = true;
-		 * // add a new <script> to load Prism's script
-		 * ```
-		 *
-		 * @default false
-		 * @type {boolean}
-		 * @memberof Prism
-		 * @public
-		 */
-		manual: _self.Prism && _self.Prism.manual,
-		/**
-		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
-		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
-		 * own worker, you don't want it to do this.
-		 *
-		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
-		 *
-		 * You obviously have to change this value before Prism executes. To do this, you can add an
-		 * empty Prism object into the global scope before loading the Prism script like this:
-		 *
-		 * ```js
-		 * window.Prism = window.Prism || {};
-		 * Prism.disableWorkerMessageHandler = true;
-		 * // Load Prism's script
-		 * ```
-		 *
-		 * @default false
-		 * @type {boolean}
-		 * @memberof Prism
-		 * @public
-		 */
-		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
+	var clone = (o, visited = new Map) => {
+		if (visited.has(o)) return visited.get(o);
+		var c = o, t = type(o);
+
+		if (t == "Object") {
+			visited.set(o, c = {});
+			for (var key in o) {
+				if (o.hasOwnProperty(key)) {
+					c[key] = clone(o[key], visited);
+				}
+			}
+		}
+		else if (t == "Array") {
+			visited.set(o, c = []);
+			for (var i = 0, l = o.length; i < l; i++) {
+				c[i] = clone(o[i], visited);
+			}
+		}
+
+		return c;
+	}
+
+	var type = o => ({}).toString.call(o).slice(8, -1);
+
+	var _ = window.Prism = {
+		manual: true,
 
 		/**
 		 * A namespace for utility methods.
@@ -82,16 +50,6 @@ var Prism = (function (_self) {
 		 * @memberof Prism
 		 */
 		util: {
-			encode: function encode(tokens) {
-				if (tokens instanceof Token) {
-					return new Token(tokens.type, encode(tokens.content), tokens.alias);
-				} else if (Array.isArray(tokens)) {
-					return tokens.map(encode);
-				} else {
-					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
-				}
-			},
-
 			/**
 			 * Returns the name of the type of the given value.
 			 *
@@ -108,22 +66,7 @@ var Prism = (function (_self) {
 			 * type(String)    === 'Function'
 			 * type(/abc+/)    === 'RegExp'
 			 */
-			type: function (o) {
-				return Object.prototype.toString.call(o).slice(8, -1);
-			},
-
-			/**
-			 * Returns a unique number for the given object. Later calls will still return the same number.
-			 *
-			 * @param {Object} obj
-			 * @returns {number}
-			 */
-			objId: function (obj) {
-				if (!obj['__id']) {
-					Object.defineProperty(obj, '__id', { value: ++uniqueId });
-				}
-				return obj['__id'];
-			},
+			type,
 
 			/**
 			 * Creates a deep clone of the given object.
@@ -131,162 +74,11 @@ var Prism = (function (_self) {
 			 * The main intended use of this function is to clone language definitions.
 			 *
 			 * @param {T} o
-			 * @param {Record<number, any>} [visited]
+			 * @param {Map<any, any>} [visited]
 			 * @returns {T}
 			 * @template T
 			 */
-			clone: function deepClone(o, visited) {
-				visited = visited || {};
-
-				var clone; var id;
-				switch (_.util.type(o)) {
-					case 'Object':
-						id = _.util.objId(o);
-						if (visited[id]) {
-							return visited[id];
-						}
-						clone = /** @type {Record<string, any>} */ ({});
-						visited[id] = clone;
-
-						for (var key in o) {
-							if (o.hasOwnProperty(key)) {
-								clone[key] = deepClone(o[key], visited);
-							}
-						}
-
-						return /** @type {any} */ (clone);
-
-					case 'Array':
-						id = _.util.objId(o);
-						if (visited[id]) {
-							return visited[id];
-						}
-						clone = [];
-						visited[id] = clone;
-
-						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
-							clone[i] = deepClone(v, visited);
-						});
-
-						return /** @type {any} */ (clone);
-
-					default:
-						return o;
-				}
-			},
-
-			/**
-			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
-			 *
-			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
-			 *
-			 * @param {Element} element
-			 * @returns {string}
-			 */
-			getLanguage: function (element) {
-				while (element) {
-					var m = lang.exec(element.className);
-					if (m) {
-						return m[1].toLowerCase();
-					}
-					element = element.parentElement;
-				}
-				return 'none';
-			},
-
-			/**
-			 * Sets the Prism `language-xxxx` class of the given element.
-			 *
-			 * @param {Element} element
-			 * @param {string} language
-			 * @returns {void}
-			 */
-			setLanguage: function (element, language) {
-				// remove all `language-xxxx` classes
-				// (this might leave behind a leading space)
-				element.className = element.className.replace(RegExp(lang, 'gi'), '');
-
-				// add the new `language-xxxx` class
-				// (using `classList` will automatically clean up spaces for us)
-				element.classList.add('language-' + language);
-			},
-
-			/**
-			 * Returns the script element that is currently executing.
-			 *
-			 * This does __not__ work for line script element.
-			 *
-			 * @returns {HTMLScriptElement | null}
-			 */
-			currentScript: function () {
-				if (typeof document === 'undefined') {
-					return null;
-				}
-				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
-					return /** @type {any} */ (document.currentScript);
-				}
-
-				// IE11 workaround
-				// we'll get the src of the current script by parsing IE11's error stack trace
-				// this will not work for inline scripts
-
-				try {
-					throw new Error();
-				} catch (err) {
-					// Get file src url from stack. Specifically works with the format of stack traces in IE.
-					// A stack will look like this:
-					//
-					// Error
-					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
-					//    at Global code (http://localhost/components/prism-core.js:606:1)
-
-					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
-					if (src) {
-						var scripts = document.getElementsByTagName('script');
-						for (var i in scripts) {
-							if (scripts[i].src == src) {
-								return scripts[i];
-							}
-						}
-					}
-					return null;
-				}
-			},
-
-			/**
-			 * Returns whether a given class is active for `element`.
-			 *
-			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
-			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
-			 * given class is just the given class with a `no-` prefix.
-			 *
-			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
-			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
-			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
-			 *
-			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
-			 * version of it, the class is considered active.
-			 *
-			 * @param {Element} element
-			 * @param {string} className
-			 * @param {boolean} [defaultActivation=false]
-			 * @returns {boolean}
-			 */
-			isActive: function (element, className, defaultActivation) {
-				var no = 'no-' + className;
-
-				while (element) {
-					var classList = element.classList;
-					if (classList.contains(className)) {
-						return true;
-					}
-					if (classList.contains(no)) {
-						return false;
-					}
-					element = element.parentElement;
-				}
-				return !!defaultActivation;
-			}
+			clone,
 		},
 
 		/**
@@ -333,15 +125,7 @@ var Prism = (function (_self) {
 			 *     'color': /\b(?:red|green|blue)\b/
 			 * });
 			 */
-			extend: function (id, redef) {
-				var lang = _.util.clone(_.languages[id]);
-
-				for (var key in redef) {
-					lang[key] = redef[key];
-				}
-
-				return lang;
-			},
+			extend: (id, redef) => Object.assign(clone(_.languages[id]), redef),
 
 			/**
 			 * Inserts tokens _before_ another token in a language definition or any other grammar.
@@ -418,255 +202,31 @@ var Prism = (function (_self) {
 			 * @returns {Grammar} The new grammar object.
 			 * @public
 			 */
-			insertBefore: function (inside, before, insert, root) {
-				root = root || /** @type {any} */ (_.languages);
+			insertBefore(inside, before, insert, root = _.languages) {
 				var grammar = root[inside];
-				/** @type {Grammar} */
-				var ret = {};
+				var temp = {};
 
 				for (var token in grammar) {
 					if (grammar.hasOwnProperty(token)) {
-
-						if (token == before) {
-							for (var newToken in insert) {
-								if (insert.hasOwnProperty(newToken)) {
-									ret[newToken] = insert[newToken];
-								}
-							}
-						}
-
-						// Do not insert token which also occur in insert. See #1525
-						if (!insert.hasOwnProperty(token)) {
-							ret[token] = grammar[token];
-						}
+						temp[token] = grammar[token];
+						delete grammar[token];
 					}
 				}
+				
+				for (var token in temp) {
+					if (token == before) Object.assign(grammar, insert);
 
-				var old = root[inside];
-				root[inside] = ret;
-
-				// Update references in other language definitions
-				_.languages.DFS(_.languages, function (key, value) {
-					if (value === old && key != inside) {
-						this[key] = ret;
+					// Do not insert token which also occur in insert. See #1525
+					if (!insert.hasOwnProperty(token)) {
+						grammar[token] = temp[token];
 					}
-				});
+				}
 
-				return ret;
+				return grammar;
 			},
-
-			// Traverse a language definition with Depth First Search
-			DFS: function DFS(o, callback, type, visited) {
-				visited = visited || {};
-
-				var objId = _.util.objId;
-
-				for (var i in o) {
-					if (o.hasOwnProperty(i)) {
-						callback.call(o, i, o[i], type || i);
-
-						var property = o[i];
-						var propertyType = _.util.type(property);
-
-						if (propertyType === 'Object' && !visited[objId(property)]) {
-							visited[objId(property)] = true;
-							DFS(property, callback, null, visited);
-						} else if (propertyType === 'Array' && !visited[objId(property)]) {
-							visited[objId(property)] = true;
-							DFS(property, callback, i, visited);
-						}
-					}
-				}
-			}
 		},
 
 		plugins: {},
-
-		/**
-		 * This is the most high-level function in Prism’s API.
-		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
-		 * each one of them.
-		 *
-		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
-		 *
-		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
-		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightAll: function (async, callback) {
-			_.highlightAllUnder(document, async, callback);
-		},
-
-		/**
-		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
-		 * {@link Prism.highlightElement} on each one of them.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-highlightall`
-		 * 2. `before-all-elements-highlight`
-		 * 3. All hooks of {@link Prism.highlightElement} for each element.
-		 *
-		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
-		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
-		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightAllUnder: function (container, async, callback) {
-			var env = {
-				callback: callback,
-				container: container,
-				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
-			};
-
-			_.hooks.run('before-highlightall', env);
-
-			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
-
-			_.hooks.run('before-all-elements-highlight', env);
-
-			for (var i = 0, element; (element = env.elements[i++]);) {
-				_.highlightElement(element, async === true, env.callback);
-			}
-		},
-
-		/**
-		 * Highlights the code inside a single element.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-sanity-check`
-		 * 2. `before-highlight`
-		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
-		 * 4. `before-insert`
-		 * 5. `after-highlight`
-		 * 6. `complete`
-		 *
-		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
-		 * the element's language.
-		 *
-		 * @param {Element} element The element containing the code.
-		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
-		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
-		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
-		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
-		 *
-		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
-		 * asynchronous highlighting to work. You can build your own bundle on the
-		 * [Download page](https://prismjs.com/download.html).
-		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
-		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightElement: function (element, async, callback) {
-			// Find language
-			var language = _.util.getLanguage(element);
-			var grammar = _.languages[language];
-
-			// Set language on the element, if not present
-			_.util.setLanguage(element, language);
-
-			// Set language on the parent, for styling
-			var parent = element.parentElement;
-			if (parent && parent.nodeName.toLowerCase() === 'pre') {
-				_.util.setLanguage(parent, language);
-			}
-
-			var code = element.textContent;
-
-			var env = {
-				element: element,
-				language: language,
-				grammar: grammar,
-				code: code
-			};
-
-			function insertHighlightedCode(highlightedCode) {
-				env.highlightedCode = highlightedCode;
-
-				_.hooks.run('before-insert', env);
-
-				env.element.innerHTML = env.highlightedCode;
-
-				_.hooks.run('after-highlight', env);
-				_.hooks.run('complete', env);
-				callback && callback.call(env.element);
-			}
-
-			_.hooks.run('before-sanity-check', env);
-
-			// plugins may change/add the parent/element
-			parent = env.element.parentElement;
-			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
-				parent.setAttribute('tabindex', '0');
-			}
-
-			if (!env.code) {
-				_.hooks.run('complete', env);
-				callback && callback.call(env.element);
-				return;
-			}
-
-			_.hooks.run('before-highlight', env);
-
-			if (!env.grammar) {
-				insertHighlightedCode(_.util.encode(env.code));
-				return;
-			}
-
-			if (async && _self.Worker) {
-				var worker = new Worker(_.filename);
-
-				worker.onmessage = function (evt) {
-					insertHighlightedCode(evt.data);
-				};
-
-				worker.postMessage(JSON.stringify({
-					language: env.language,
-					code: env.code,
-					immediateClose: true
-				}));
-			} else {
-				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
-			}
-		},
-
-		/**
-		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
-		 * and the language definitions to use, and returns a string with the HTML produced.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-tokenize`
-		 * 2. `after-tokenize`
-		 * 3. `wrap`: On each {@link Token}.
-		 *
-		 * @param {string} text A string with the code to be highlighted.
-		 * @param {Grammar} grammar An object containing the tokens to use.
-		 *
-		 * Usually a language definition like `Prism.languages.markup`.
-		 * @param {string} language The name of the language definition passed to `grammar`.
-		 * @returns {string} The highlighted HTML.
-		 * @memberof Prism
-		 * @public
-		 * @example
-		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
-		 */
-		highlight: function (text, grammar, language) {
-			var env = {
-				code: text,
-				grammar: grammar,
-				language: language
-			};
-			_.hooks.run('before-tokenize', env);
-			if (!env.grammar) {
-				throw new Error('The language "' + env.language + '" has no grammar.');
-			}
-			env.tokens = _.tokenize(env.code, env.grammar);
-			_.hooks.run('after-tokenize', env);
-			return Token.stringify(_.util.encode(env.tokens), env.language);
-		},
-
 		/**
 		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
 		 * and the language definitions to use, and returns an array with the tokenized code.
@@ -691,22 +251,28 @@ var Prism = (function (_self) {
 		 *     }
 		 * });
 		 */
-		tokenize: function (text, grammar) {
+		tokenize(text, grammar) {
+			var head = {};
+			var tail = { prev: head };
+			var tokenList = {
+				head, tail, length: 0
+			};
 			var rest = grammar.rest;
+			var array = [], i = 0;
+			head.next = tail;
 			if (rest) {
-				for (var token in rest) {
-					grammar[token] = rest[token];
-				}
+				Object.assign(grammar, rest);
 
 				delete grammar.rest;
 			}
 
-			var tokenList = new LinkedList();
 			addAfter(tokenList, tokenList.head, text);
-
 			matchGrammar(text, tokenList, grammar, tokenList.head, 0);
-
-			return toArray(tokenList);
+			
+			while ((head = head.next) != tail) {
+				array[i++] = head.value;
+			}
+			return array;
 		},
 
 		/**
@@ -715,7 +281,7 @@ var Prism = (function (_self) {
 		 * @public
 		 */
 		hooks: {
-			all: {},
+			all: hooks,
 
 			/**
 			 * Adds the given callback to the list of callbacks for the given hook.
@@ -729,12 +295,8 @@ var Prism = (function (_self) {
 			 * @param {HookCallback} callback The callback function which is given environment variables.
 			 * @public
 			 */
-			add: function (name, callback) {
-				var hooks = _.hooks.all;
-
-				hooks[name] = hooks[name] || [];
-
-				hooks[name].push(callback);
+			add(name, callback) {
+				(hooks[name] || (hooks[name] = [])).push(callback);
 			},
 
 			/**
@@ -746,138 +308,15 @@ var Prism = (function (_self) {
 			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
 			 * @public
 			 */
-			run: function (name, env) {
-				var callbacks = _.hooks.all[name];
-
-				if (!callbacks || !callbacks.length) {
-					return;
-				}
+			run(name, env) {
+				var callbacks = hooks[name];
 
-				for (var i = 0, callback; (callback = callbacks[i++]);) {
+				if (callbacks) for (var i = 0, callback; callback = callbacks[i++]; ) {
 					callback(env);
 				}
 			}
 		},
-
-		Token: Token
-	};
-	_self.Prism = _;
-
-
-	// Typescript note:
-	// The following can be used to import the Token type in JSDoc:
-	//
-	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
-
-	/**
-	 * Creates a new token.
-	 *
-	 * @param {string} type See {@link Token#type type}
-	 * @param {string | TokenStream} content See {@link Token#content content}
-	 * @param {string|string[]} [alias] The alias(es) of the token.
-	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
-	 * @class
-	 * @global
-	 * @public
-	 */
-	function Token(type, content, alias, matchedStr) {
-		/**
-		 * The type of the token.
-		 *
-		 * This is usually the key of a pattern in a {@link Grammar}.
-		 *
-		 * @type {string}
-		 * @see GrammarToken
-		 * @public
-		 */
-		this.type = type;
-		/**
-		 * The strings or tokens contained by this token.
-		 *
-		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
-		 *
-		 * @type {string | TokenStream}
-		 * @public
-		 */
-		this.content = content;
-		/**
-		 * The alias(es) of the token.
-		 *
-		 * @type {string|string[]}
-		 * @see GrammarToken
-		 * @public
-		 */
-		this.alias = alias;
-		// Copy of the full string this token was created from
-		this.length = (matchedStr || '').length | 0;
-	}
-
-	/**
-	 * A token stream is an array of strings and {@link Token Token} objects.
-	 *
-	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
-	 * them.
-	 *
-	 * 1. No adjacent strings.
-	 * 2. No empty strings.
-	 *
-	 *    The only exception here is the token stream that only contains the empty string and nothing else.
-	 *
-	 * @typedef {Array<string | Token>} TokenStream
-	 * @global
-	 * @public
-	 */
-
-	/**
-	 * Converts the given token or token stream to an HTML representation.
-	 *
-	 * The following hooks will be run:
-	 * 1. `wrap`: On each {@link Token}.
-	 *
-	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
-	 * @param {string} language The name of current language.
-	 * @returns {string} The HTML representation of the token or token stream.
-	 * @memberof Token
-	 * @static
-	 */
-	Token.stringify = function stringify(o, language) {
-		if (typeof o == 'string') {
-			return o;
-		}
-		if (Array.isArray(o)) {
-			var s = '';
-			o.forEach(function (e) {
-				s += stringify(e, language);
-			});
-			return s;
-		}
-
-		var env = {
-			type: o.type,
-			content: stringify(o.content, language),
-			tag: 'span',
-			classes: ['token', o.type],
-			attributes: {},
-			language: language
-		};
-
-		var aliases = o.alias;
-		if (aliases) {
-			if (Array.isArray(aliases)) {
-				Array.prototype.push.apply(env.classes, aliases);
-			} else {
-				env.classes.push(aliases);
-			}
-		}
-
-		_.hooks.run('wrap', env);
-
-		var attributes = '';
-		for (var name in env.attributes) {
-			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
-		}
-
-		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
+		Token
 	};
 
 	/**
@@ -887,7 +326,7 @@ var Prism = (function (_self) {
 	 * @param {boolean} lookbehind
 	 * @returns {RegExpExecArray | null}
 	 */
-	function matchPattern(pattern, pos, text, lookbehind) {
+	var matchPattern = (pattern, pos, text, lookbehind) => {
 		pattern.lastIndex = pos;
 		var match = pattern.exec(text);
 		if (match && lookbehind && match[1]) {
@@ -913,38 +352,29 @@ var Prism = (function (_self) {
 	 * @property {string} cause
 	 * @property {number} reach
 	 */
-	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
+	var matchGrammar = (text, tokenList, grammar, startNode, startPos, rematch) => {
 		for (var token in grammar) {
-			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
-				continue;
-			}
-
-			var patterns = grammar[token];
-			patterns = Array.isArray(patterns) ? patterns : [patterns];
-
-			for (var j = 0; j < patterns.length; ++j) {
+			if (grammar.hasOwnProperty(token) && grammar[token]) for (var j = 0, p = grammar[token], patterns = Array.isArray(p) ? p : [p]; j < patterns.length; ++j) {
 				if (rematch && rematch.cause == token + ',' + j) {
 					return;
 				}
 
 				var patternObj = patterns[j];
 				var inside = patternObj.inside;
-				var lookbehind = !!patternObj.lookbehind;
-				var greedy = !!patternObj.greedy;
+				var lookbehind = patternObj.lookbehind;
+				var greedy = patternObj.greedy;
 				var alias = patternObj.alias;
 
-				if (greedy && !patternObj.pattern.global) {
-					// Without the global flag, lastIndex won't work
-					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
-					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
-				}
-
 				/** @type {RegExp} */
 				var pattern = patternObj.pattern || patternObj;
-
+				if (greedy && !pattern.global) {
+					// Without the global flag, lastIndex won't work
+					pattern = patternObj.pattern = RegExp(pattern.source, `${pattern}g`.match(/[imsuyg]*$/)[0]);
+				}
+				
 				for ( // iterate the token list and keep track of the current token/string position
 					var currentNode = startNode.next, pos = startPos;
-					currentNode !== tokenList.tail;
+					currentNode != tokenList.tail;
 					pos += currentNode.value.length, currentNode = currentNode.next
 				) {
 
@@ -994,7 +424,7 @@ var Prism = (function (_self) {
 						// find the last node which is affected by this match
 						for (
 							var k = currentNode;
-							k !== tokenList.tail && (p < to || typeof k.value === 'string');
+							k != tokenList.tail && (p < to || typeof k.value == 'string');
 							k = k.next
 						) {
 							removeCount++;
@@ -1017,21 +447,26 @@ var Prism = (function (_self) {
 					var matchStr = match[0];
 					var before = str.slice(0, from);
 					var after = str.slice(from + matchStr.length);
-
 					var reach = pos + str.length;
+					var removeFrom = currentNode.prev;
+
 					if (rematch && reach > rematch.reach) {
 						rematch.reach = reach;
 					}
 
-					var removeFrom = currentNode.prev;
-
 					if (before) {
 						removeFrom = addAfter(tokenList, removeFrom, before);
 						pos += before.length;
 					}
 
-					removeRange(tokenList, removeFrom, removeCount);
-
+					var next = removeFrom.next;
+					for (var i = 0; i < removeCount && next != tokenList.tail; i++) {
+						next = next.next;
+					}
+					removeFrom.next = next;
+					next.prev = removeFrom;
+					tokenList.length -= i;
+					
 					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
 					currentNode = addAfter(tokenList, removeFrom, wrapped);
 
@@ -1069,24 +504,6 @@ var Prism = (function (_self) {
 	 * @private
 	 */
 
-	/**
-	 * @template T
-	 * @private
-	 */
-	function LinkedList() {
-		/** @type {LinkedListNode<T>} */
-		var head = { value: null, prev: null, next: null };
-		/** @type {LinkedListNode<T>} */
-		var tail = { value: null, prev: head, next: null };
-		head.next = tail;
-
-		/** @type {LinkedListNode<T>} */
-		this.head = head;
-		/** @type {LinkedListNode<T>} */
-		this.tail = tail;
-		this.length = 0;
-	}
-
 	/**
 	 * Adds a new node with the given value to the list.
 	 *
@@ -1096,7 +513,7 @@ var Prism = (function (_self) {
 	 * @returns {LinkedListNode<T>} The added node.
 	 * @template T
 	 */
-	function addAfter(list, node, value) {
+	var addAfter = (list, node, value) => {
 		// assumes that node != list.tail && values.length >= 0
 		var next = node.next;
 
@@ -1107,157 +524,54 @@ var Prism = (function (_self) {
 
 		return newNode;
 	}
+
+	// Typescript note:
+	// The following can be used to import the Token type in JSDoc:
+	//
+	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
+
 	/**
-	 * Removes `count` nodes after the given node. The given node will not be removed.
+	 * Creates a new token.
 	 *
-	 * @param {LinkedList<T>} list
-	 * @param {LinkedListNode<T>} node
-	 * @param {number} count
-	 * @template T
-	 */
-	function removeRange(list, node, count) {
-		var next = node.next;
-		for (var i = 0; i < count && next !== list.tail; i++) {
-			next = next.next;
-		}
-		node.next = next;
-		next.prev = node;
-		list.length -= i;
-	}
-	/**
-	 * @param {LinkedList<T>} list
-	 * @returns {T[]}
-	 * @template T
+	 * @param {string} type See {@link Token#type type}
+	 * @param {string | TokenStream} content See {@link Token#content content}
+	 * @param {string|string[]} [alias] The alias(es) of the token.
+	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
+	 * @class
+	 * @global
+	 * @public
 	 */
-	function toArray(list) {
-		var array = [];
-		var node = list.head.next;
-		while (node !== list.tail) {
-			array.push(node.value);
-			node = node.next;
-		}
-		return array;
-	}
-
-
-	if (!_self.document) {
-		if (!_self.addEventListener) {
-			// in Node.js
-			return _;
-		}
-
-		if (!_.disableWorkerMessageHandler) {
-			// In worker
-			_self.addEventListener('message', function (evt) {
-				var message = JSON.parse(evt.data);
-				var lang = message.language;
-				var code = message.code;
-				var immediateClose = message.immediateClose;
-
-				_self.postMessage(_.highlight(code, _.languages[lang], lang));
-				if (immediateClose) {
-					_self.close();
-				}
-			}, false);
-		}
-
-		return _;
-	}
-
-	// Get current script and highlight
-	var script = _.util.currentScript();
-
-	if (script) {
-		_.filename = script.src;
-
-		if (script.hasAttribute('data-manual')) {
-			_.manual = true;
-		}
-	}
-
-	function highlightAutomaticallyCallback() {
-		if (!_.manual) {
-			_.highlightAll();
-		}
-	}
-
-	if (!_.manual) {
-		// If the document state is "loading", then we'll use DOMContentLoaded.
-		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
-		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
-		// might take longer one animation frame to execute which can create a race condition where only some plugins have
-		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
-		// See https://github.com/PrismJS/prism/issues/2102
-		var readyState = document.readyState;
-		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
-			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
-		} else {
-			if (window.requestAnimationFrame) {
-				window.requestAnimationFrame(highlightAutomaticallyCallback);
-			} else {
-				window.setTimeout(highlightAutomaticallyCallback, 16);
-			}
-		}
+	function Token(type, content, alias, matchedStr) {
+		/**
+		 * The type of the token.
+		 *
+		 * This is usually the key of a pattern in a {@link Grammar}.
+		 *
+		 * @type {string}
+		 * @see GrammarToken
+		 * @public
+		 */
+		this.type = type;
+		/**
+		 * The strings or tokens contained by this token.
+		 *
+		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
+		 *
+		 * @type {string | TokenStream}
+		 * @public
+		 */
+		this.content = content;
+		/**
+		 * The alias(es) of the token.
+		 *
+		 * @type {string|string[]}
+		 * @see GrammarToken
+		 * @public
+		 */
+		this.alias = alias;
+		// Copy of the full string this token was created from
+		this.length = (matchedStr || '').length | 0;
 	}
 
 	return _;
-
-}(_self));
-
-if (typeof module !== 'undefined' && module.exports) {
-	module.exports = Prism;
-}
-
-// hack for components to work correctly in node.js
-if (typeof global !== 'undefined') {
-	global.Prism = Prism;
-}
-
-// some additional documentation/types
-
-/**
- * The expansion of a simple `RegExp` literal to support additional properties.
- *
- * @typedef GrammarToken
- * @property {RegExp} pattern The regular expression of the token.
- * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
- * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
- * @property {boolean} [greedy=false] Whether the token is greedy.
- * @property {string|string[]} [alias] An optional alias or list of aliases.
- * @property {Grammar} [inside] The nested grammar of this token.
- *
- * The `inside` grammar will be used to tokenize the text value of each token of this kind.
- *
- * This can be used to make nested and even recursive language definitions.
- *
- * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
- * each another.
- * @global
- * @public
- */
-
-/**
- * @typedef Grammar
- * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
- * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
- * @global
- * @public
- */
-
-/**
- * A function which will invoked after an element was successfully highlighted.
- *
- * @callback HighlightCallback
- * @param {Element} element The element successfully highlighted.
- * @returns {void}
- * @global
- * @public
- */
-
-/**
- * @callback HookCallback
- * @param {Object<string, any>} env The environment variables of the hook.
- * @returns {void}
- * @global
- * @public
- */
+})();
diff --git a/components/prism-markdown.js b/components/prism-markdown.js
index 438f8ed8fcb682061959a2bf1be8d467861b7ecd..6e1f89f08b9be9dc677c0b50ed912585a82a49d6 100644
--- a/components/prism-markdown.js
+++ b/components/prism-markdown.js
@@ -1,415 +1,291 @@
-(function (Prism) {
-
-	// Allow only one line break
-	var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
-
-	/**
-	 * This function is intended for the creation of the bold or italic pattern.
-	 *
-	 * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
-	 *
-	 * _Note:_ Keep in mind that this adds a capturing group.
-	 *
-	 * @param {string} pattern
-	 * @returns {RegExp}
-	 */
-	function createInline(pattern) {
-		pattern = pattern.replace(/<inner>/g, function () { return inner; });
-		return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
-	}
-
-
-	var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
-	var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () { return tableCell; });
-	var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
-
-
-	Prism.languages.markdown = Prism.languages.extend('markup', {});
-	Prism.languages.insertBefore('markdown', 'prolog', {
-		'front-matter-block': {
-			pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
-			lookbehind: true,
-			greedy: true,
-			inside: {
-				'punctuation': /^---|---$/,
-				'front-matter': {
-					pattern: /\S+(?:\s+\S+)*/,
-					alias: ['yaml', 'language-yaml'],
-					inside: Prism.languages.yaml
-				}
-			}
-		},
-		'blockquote': {
-			// > ...
-			pattern: /^>(?:[\t ]*>)*/m,
-			alias: 'punctuation'
-		},
-		'table': {
-			pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
-			inside: {
-				'table-data-rows': {
-					pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
-					lookbehind: true,
-					inside: {
-						'table-data': {
-							pattern: RegExp(tableCell),
-							inside: Prism.languages.markdown
-						},
-						'punctuation': /\|/
-					}
-				},
-				'table-line': {
-					pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
-					lookbehind: true,
-					inside: {
-						'punctuation': /\||:?-{3,}:?/
-					}
-				},
-				'table-header-row': {
-					pattern: RegExp('^' + tableRow + '$'),
-					inside: {
-						'table-header': {
-							pattern: RegExp(tableCell),
-							alias: 'important',
-							inside: Prism.languages.markdown
-						},
-						'punctuation': /\|/
-					}
-				}
+// Allow only one line break
+var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
+
+/**
+ * This function is intended for the creation of the bold or italic pattern.
+ *
+ * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
+ *
+ * _Note:_ Keep in mind that this adds a capturing group.
+ *
+ * @param {RegExp} pattern
+ * @returns {RegExp}
+ */
+var createInline = pattern => RegExp(`((?:^|[^\\\\])(?:\\\\{2})*)(?:${pattern.source.replace(/<inner>/g, inner)})`);
+var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
+var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, tableCell);
+var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
+var languages = Prism.languages
+var markdown = languages.markdown = languages.md = languages.extend('markup', {});
+
+languages.insertBefore('markdown', 'prolog', {
+	'front-matter-block': {
+		pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'punctuation': /^---|---$/,
+			'front-matter': {
+				pattern: /\S+(?:\s+\S+)*/,
+				alias: ['yaml', 'language-yaml'],
+				inside: languages.yaml
 			}
-		},
-		'code': [
-			{
-				// Prefixed by 4 spaces or 1 tab and preceded by an empty line
-				pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
+		}
+	},
+	'blockquote': {
+		// > ...
+		pattern: /^>(?:[\t ]*>)*/m,
+		alias: 'punctuation'
+	},
+	'table': {
+		pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
+		inside: {
+			'table-data-rows': {
+				pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
 				lookbehind: true,
-				alias: 'keyword'
-			},
-			{
-				// ```optional language
-				// code block
-				// ```
-				pattern: /^```[\s\S]*?^```$/m,
-				greedy: true,
 				inside: {
-					'code-block': {
-						pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
-						lookbehind: true
-					},
-					'code-language': {
-						pattern: /^(```).+/,
-						lookbehind: true
+					'table-data': {
+						pattern: RegExp(tableCell),
+						inside: markdown
 					},
-					'punctuation': /```/
+					'punctuation': /\|/
 				}
-			}
-		],
-		'title': [
-			{
-				// title 1
-				// =======
-
-				// title 2
-				// -------
-				pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
-				alias: 'important',
+			},
+			'table-line': {
+				pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
+				lookbehind: true,
 				inside: {
-					punctuation: /==+$|--+$/
+					'punctuation': /\||:?-{3,}:?/
 				}
 			},
-			{
-				// # title 1
-				// ###### title 6
-				pattern: /(^\s*)#.+/m,
-				lookbehind: true,
-				alias: 'important',
+			'table-header-row': {
+				pattern: RegExp('^' + tableRow + '$'),
 				inside: {
-					punctuation: /^#+|#+$/
+					'table-header': {
+						pattern: RegExp(tableCell),
+						alias: 'important',
+						inside: markdown
+					},
+					'punctuation': /\|/
 				}
 			}
-		],
-		'hr': {
-			// ***
-			// ---
-			// * * *
-			// -----------
-			pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
-			lookbehind: true,
-			alias: 'punctuation'
-		},
-		'list': {
-			// * item
-			// + item
-			// - item
-			// 1. item
-			pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
+		}
+	},
+	'code': [
+		{
+			// Prefixed by 4 spaces or 1 tab and preceded by an empty line
+			pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
 			lookbehind: true,
-			alias: 'punctuation'
+			alias: 'keyword'
 		},
-		'url-reference': {
-			// [id]: http://example.com "Optional title"
-			// [id]: http://example.com 'Optional title'
-			// [id]: http://example.com (Optional title)
-			// [id]: <http://example.com> "Optional title"
-			pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
-			inside: {
-				'variable': {
-					pattern: /^(!?\[)[^\]]+/,
-					lookbehind: true
-				},
-				'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
-				'punctuation': /^[\[\]!:]|[<>]/
-			},
-			alias: 'url'
-		},
-		'bold': {
-			// **strong**
-			// __strong__
-
-			// allow one nested instance of italic text using the same delimiter
-			pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
-			lookbehind: true,
+		{
+			// ```optional language
+			// code block
+			// ```
+			pattern: /^```[\s\S]*?^```$/m,
 			greedy: true,
 			inside: {
-				'content': {
-					pattern: /(^..)[\s\S]+(?=..$)/,
-					lookbehind: true,
-					inside: {} // see below
+				'code-block': {
+					pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
+					lookbehind: true
 				},
-				'punctuation': /\*\*|__/
-			}
-		},
-		'italic': {
-			// *em*
-			// _em_
-
-			// allow one nested instance of bold text using the same delimiter
-			pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
-			lookbehind: true,
-			greedy: true,
-			inside: {
-				'content': {
-					pattern: /(^.)[\s\S]+(?=.$)/,
-					lookbehind: true,
-					inside: {} // see below
+				'code-language': {
+					pattern: /^(```).+/,
+					lookbehind: true
 				},
-				'punctuation': /[*_]/
+				'punctuation': /```/
 			}
-		},
-		'strike': {
-			// ~~strike through~~
-			// ~strike~
-			// eslint-disable-next-line regexp/strict
-			pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
-			lookbehind: true,
-			greedy: true,
+		}
+	],
+	'title': [
+		{
+			// title 1
+			// =======
+
+			// title 2
+			// -------
+			pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
+			alias: 'important',
 			inside: {
-				'content': {
-					pattern: /(^~~?)[\s\S]+(?=\1$)/,
-					lookbehind: true,
-					inside: {} // see below
-				},
-				'punctuation': /~~?/
+				punctuation: /==+$|--+$/
 			}
 		},
-		'code-snippet': {
-			// `code`
-			// ``code``
-			pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
+		{
+			// # title 1
+			// ###### title 6
+			pattern: /(^\s*)#.+/m,
 			lookbehind: true,
-			greedy: true,
-			alias: ['code', 'keyword']
-		},
-		'url': {
-			// [example](http://example.com "Optional title")
-			// [example][id]
-			// [example] [id]
-			pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
-			lookbehind: true,
-			greedy: true,
+			alias: 'important',
 			inside: {
-				'operator': /^!/,
-				'content': {
-					pattern: /(^\[)[^\]]+(?=\])/,
-					lookbehind: true,
-					inside: {} // see below
-				},
-				'variable': {
-					pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
-					lookbehind: true
-				},
-				'url': {
-					pattern: /(^\]\()[^\s)]+/,
-					lookbehind: true
-				},
-				'string': {
-					pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
-					lookbehind: true
-				}
+				punctuation: /^#+|#+$/
 			}
 		}
-	});
-
-	['url', 'bold', 'italic', 'strike'].forEach(function (token) {
-		['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
-			if (token !== inside) {
-				Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
-			}
-		});
-	});
-
-	Prism.hooks.add('after-tokenize', function (env) {
-		if (env.language !== 'markdown' && env.language !== 'md') {
-			return;
+	],
+	'hr': {
+		// ***
+		// ---
+		// * * *
+		// -----------
+		pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
+		lookbehind: true,
+		alias: 'punctuation'
+	},
+	'list': {
+		// * item
+		// + item
+		// - item
+		// 1. item
+		pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
+		lookbehind: true,
+		alias: 'punctuation'
+	},
+	'url-reference': {
+		// [id]: http://example.com "Optional title"
+		// [id]: http://example.com 'Optional title'
+		// [id]: http://example.com (Optional title)
+		// [id]: <http://example.com> "Optional title"
+		pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
+		inside: {
+			'variable': {
+				pattern: /^(!?\[)[^\]]+/,
+				lookbehind: true
+			},
+			'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
+			'punctuation': /^[\[\]!:]|[<>]/
+		},
+		alias: 'url'
+	},
+	'bold': {
+		// **strong**
+		// __strong__
+
+		// allow one nested instance of italic text using the same delimiter
+		pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'content': {
+				pattern: /(^..)[\s\S]+(?=..$)/,
+				lookbehind: true,
+				inside: {} // see below
+			},
+			'punctuation': /\*\*|__/
 		}
-
-		function walkTokens(tokens) {
-			if (!tokens || typeof tokens === 'string') {
-				return;
-			}
-
-			for (var i = 0, l = tokens.length; i < l; i++) {
-				var token = tokens[i];
-
-				if (token.type !== 'code') {
-					walkTokens(token.content);
-					continue;
-				}
-
-				/*
-				 * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
-				 * is optional. But the grammar is defined so that there is only one case we have to handle:
-				 *
-				 * token.content = [
-				 *     <span class="punctuation">```</span>,
-				 *     <span class="code-language">xxxx</span>,
-				 *     '\n', // exactly one new lines (\r or \n or \r\n)
-				 *     <span class="code-block">...</span>,
-				 *     '\n', // exactly one new lines again
-				 *     <span class="punctuation">```</span>
-				 * ];
-				 */
-
-				var codeLang = token.content[1];
-				var codeBlock = token.content[3];
-
-				if (codeLang && codeBlock &&
-					codeLang.type === 'code-language' && codeBlock.type === 'code-block' &&
-					typeof codeLang.content === 'string') {
-
-					// this might be a language that Prism does not support
-
-					// do some replacements to support C++, C#, and F#
-					var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp');
-					// only use the first word
-					lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
-					var alias = 'language-' + lang;
-
-					// add alias
-					if (!codeBlock.alias) {
-						codeBlock.alias = [alias];
-					} else if (typeof codeBlock.alias === 'string') {
-						codeBlock.alias = [codeBlock.alias, alias];
-					} else {
-						codeBlock.alias.push(alias);
-					}
-				}
-			}
+	},
+	'italic': {
+		// *em*
+		// _em_
+
+		// allow one nested instance of bold text using the same delimiter
+		pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'content': {
+				pattern: /(^.)[\s\S]+(?=.$)/,
+				lookbehind: true,
+				inside: {} // see below
+			},
+			'punctuation': /[*_]/
 		}
-
-		walkTokens(env.tokens);
-	});
-
-	Prism.hooks.add('wrap', function (env) {
-		if (env.type !== 'code-block') {
-			return;
+	},
+	'strike': {
+		// ~~strike through~~
+		// ~strike~
+		// eslint-disable-next-line regexp/strict
+		pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'content': {
+				pattern: /(^~~?)[\s\S]+(?=\1$)/,
+				lookbehind: true,
+				inside: {} // see below
+			},
+			'punctuation': /~~?/
 		}
-
-		var codeLang = '';
-		for (var i = 0, l = env.classes.length; i < l; i++) {
-			var cls = env.classes[i];
-			var match = /language-(.+)/.exec(cls);
-			if (match) {
-				codeLang = match[1];
-				break;
+	},
+	'code-snippet': {
+		// `code`
+		// ``code``
+		pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
+		lookbehind: true,
+		greedy: true,
+		alias: ['code', 'keyword']
+	},
+	'url': {
+		// [example](http://example.com "Optional title")
+		// [example][id]
+		// [example] [id]
+		pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'operator': /^!/,
+			'content': {
+				pattern: /(^\[)[^\]]+(?=\])/,
+				lookbehind: true,
+				inside: {} // see below
+			},
+			'variable': {
+				pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
+				lookbehind: true
+			},
+			'url': {
+				pattern: /(^\]\()[^\s)]+/,
+				lookbehind: true
+			},
+			'string': {
+				pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
+				lookbehind: true
 			}
 		}
+	}
+});
 
-		var grammar = Prism.languages[codeLang];
-
-		if (!grammar) {
-			if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
-				var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
-				env.attributes['id'] = id;
-
-				Prism.plugins.autoloader.loadLanguages(codeLang, function () {
-					var ele = document.getElementById(id);
-					if (ele) {
-						ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
-					}
-				});
-			}
-		} else {
-			env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
+['url', 'bold', 'italic', 'strike'].forEach(token => {
+	['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(inside => {
+		if (token != inside) {
+			markdown[token].inside.content.inside[inside] = markdown[inside];
 		}
 	});
-
-	var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');
-
-	/**
-	 * A list of known entity names.
-	 *
-	 * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
-	 *
-	 * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
-	 */
-	var KNOWN_ENTITY_NAMES = {
-		'amp': '&',
-		'lt': '<',
-		'gt': '>',
-		'quot': '"',
-	};
-
-	// IE 11 doesn't support `String.fromCodePoint`
-	var fromCodePoint = String.fromCodePoint || String.fromCharCode;
-
-	/**
-	 * Returns the text content of a given HTML source code string.
-	 *
-	 * @param {string} html
-	 * @returns {string}
-	 */
-	function textContent(html) {
-		// remove all tags
-		var text = html.replace(tagPattern, '');
-
-		// decode known entities
-		text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
-			code = code.toLowerCase();
-
-			if (code[0] === '#') {
-				var value;
-				if (code[1] === 'x') {
-					value = parseInt(code.slice(2), 16);
-				} else {
-					value = Number(code.slice(1));
-				}
-
-				return fromCodePoint(value);
-			} else {
-				var known = KNOWN_ENTITY_NAMES[code];
-				if (known) {
-					return known;
+});
+
+var walkTokens = tokens => {
+	if (Array.isArray(tokens)) for (var i = 0, l = tokens.length; i < l; i++) {
+		var token = tokens[i];
+		var type = token.type;
+
+		if (type) {
+			if (type != 'code') walkTokens(token.content);
+			else {
+				var [, codeLang, , codeBlock] = token.content;
+
+				if (codeBlock && codeLang && codeBlock.type == 'code-block' && codeLang.type == 'code-language') {
+					var language = (/[a-z][\w-]*/i.exec(
+						codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp')
+					) || [''])[0].toLowerCase();
+
+					var alias = 'language-' + language;
+					var blockAlias = codeBlock.alias;
+					var code = codeBlock.content;
+					var grammar = Prism.languages[language];
+
+					if (Array.isArray(blockAlias)) blockAlias.push(alias)
+					else codeBlock.alias = blockAlias ? [blockAlias, alias] : [alias]
+
+					if (grammar && typeof code == 'string') {
+						var env = { code, language, grammar };
+						Prism.hooks.run('before-tokenize', env);
+						codeBlock.content = env.tokens = Prism.tokenize(env.code, env.grammar);
+						Prism.hooks.run('after-tokenize', env);
+					}
 				}
-
-				// unable to decode
-				return m;
 			}
-		});
-
-		return text;
+		}
 	}
+}
 
-	Prism.languages.md = Prism.languages.markdown;
-
-}(Prism));
+Prism.hooks.add('after-tokenize', env => {
+	if (env.language == 'markdown' || env.language == 'md') walkTokens(env.tokens);
+});