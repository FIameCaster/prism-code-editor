diff --git a/components/prism-abnf.js b/components/prism-abnf.js
index 4b8fcab79520e0e5ab66bd22a13f689239770aba..bb4fb61cf7c05ddd867f452bf99951984e5a39a6 100644
--- a/components/prism-abnf.js
+++ b/components/prism-abnf.js
@@ -33,7 +33,7 @@
 			}
 		},
 		'core-rule': {
-			pattern: RegExp('(?:(^|[^<\\w-])' + coreRules + '|<' + coreRules + '>)(?![\\w-])', 'i'),
+			pattern: RegExp(`(?:(^|[^<\\w-])${coreRules}|<${coreRules}>)(?![\\w-])`, 'i'),
 			lookbehind: true,
 			alias: ['rule', 'constant'],
 			inside: {
diff --git a/components/prism-actionscript.js b/components/prism-actionscript.js
index 72a4d232be40ec459b2bb7000aa3cd5d2badd514..fdbf97fd522389aef65cf119118b328846dfdca8 100644
--- a/components/prism-actionscript.js
+++ b/components/prism-actionscript.js
@@ -1,19 +1,18 @@
-Prism.languages.actionscript = Prism.languages.extend('javascript', {
+var actionscript = Prism.languages.actionscript = Prism.languages.extend('javascript', {
 	'keyword': /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
 	'operator': /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
 });
-Prism.languages.actionscript['class-name'].alias = 'function';
+actionscript['class-name'].alias = 'function';
 
 // doesn't work with AS because AS is too complex
-delete Prism.languages.actionscript['parameter'];
-delete Prism.languages.actionscript['literal-property'];
+delete actionscript['parameter'];
+delete actionscript['literal-property'];
+
+Prism.languages.insertBefore('actionscript', 'string', {
+	'xml': {
+		pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
+		lookbehind: true,
+		inside: 'markup'
+	}
+});
 
-if (Prism.languages.markup) {
-	Prism.languages.insertBefore('actionscript', 'string', {
-		'xml': {
-			pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
-			lookbehind: true,
-			inside: Prism.languages.markup
-		}
-	});
-}
diff --git a/components/prism-apex.js b/components/prism-apex.js
index dbb7f0dcd6d369f547376fa976efbec1e4bad363..91f7abce02266949983d91df2476ed5ea6ccf42c 100644
--- a/components/prism-apex.js
+++ b/components/prism-apex.js
@@ -3,11 +3,10 @@
 	var keywords = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i;
 
 	var className = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source
-		.replace(/<keyword>/g, function () { return keywords.source; });
+		.replace(/<keyword>/g, keywords.source);
 	/** @param {string} pattern */
-	function insertClassName(pattern) {
-		return RegExp(pattern.replace(/<CLASS-NAME>/g, function () { return className; }), 'i');
-	}
+	var insertClassName = pattern =>
+		RegExp(pattern.replace(/<CLASS-NAME>/g, className), 'i');
 
 	var classNameInside = {
 		'keyword': keywords,
@@ -22,7 +21,7 @@
 			lookbehind: true,
 			greedy: true,
 			alias: 'language-sql',
-			inside: Prism.languages.sql
+			inside: 'sql'
 		},
 
 		'annotation': {
diff --git a/components/prism-arturo.js b/components/prism-arturo.js
index d09b5e27ef5ce7151fcaa69515289354534b719e..ef940ac3806c19936a09968a394fb28e947fa572 100644
--- a/components/prism-arturo.js
+++ b/components/prism-arturo.js
@@ -3,21 +3,19 @@
 	 * @param {string} lang
 	 * @param {string} pattern
 	 */
-	var createLanguageString = function (lang, pattern) {
-		return {
-			pattern: RegExp(/\{!/.source + '(?:' + (pattern || lang) + ')' + /$[\s\S]*\}/.source, 'm'),
-			greedy: true,
-			inside: {
-				'embedded': {
-					pattern: /(^\{!\w+\b)[\s\S]+(?=\}$)/,
-					lookbehind: true,
-					alias: 'language-' + lang,
-					inside: Prism.languages[lang]
-				},
-				'string': /[\s\S]+/
-			}
-		};
-	};
+	var createLanguageString = (lang, pattern = lang) => ({
+		pattern: RegExp(`\\{!(?:${pattern})$[\\s\\S]*\\}`, 'mg'),
+		greedy: true,
+		inside: {
+			'embedded': {
+				pattern: /(^\{!\w+\b)[\s\S]+(?=\}$)/,
+				lookbehind: true,
+				alias: 'language-' + lang,
+				inside: lang
+			},
+			'string': /[\s\S]+/
+		}
+	});
 
 	Prism.languages.arturo = {
 		'comment': {
@@ -31,9 +29,7 @@
 			greedy: true
 		},
 
-		'number': {
-			pattern: /\b\d+(?:\.\d+(?:\.\d+(?:-[\w+-]+)?)?)?\b/,
-		},
+		'number': /\b\d+(?:\.\d+(?:\.\d+(?:-[\w+-]+)?)?)?\b/,
 
 		'string': {
 			pattern: /"(?:[^"\\\r\n]|\\.)*"/,
@@ -92,13 +88,9 @@
 
 		'punctuation': /[()[\],]/,
 
-		'symbol': {
-			pattern: /<:|-:|ø|@|#|\+|\||\*|\$|---|-|%|\/|\.\.|\^|~|=|<|>|\\/
-		},
+		'symbol': /<:|-:|ø|@|#|\+|\||\*|\$|---|-|%|\/|\.\.|\^|~|=|<|>|\\/,
 
-		'boolean': {
-			pattern: /\b(?:false|maybe|true)\b/
-		}
+		'boolean': /\b(?:false|maybe|true)\b/
 	};
 
 	Prism.languages.art = Prism.languages['arturo'];
diff --git a/components/prism-asciidoc.js b/components/prism-asciidoc.js
index b639a1756e712bf23037a255307b6af52316778e..5fbfbf524fdd453c41194e46e034f00a21030726 100644
--- a/components/prism-asciidoc.js
+++ b/components/prism-asciidoc.js
@@ -200,11 +200,10 @@
 
 	// Allow some nesting. There is no recursion though, so cloning should not be needed.
 
-	function copyFromAsciiDoc(keys) {
+	var copyFromAsciiDoc = keys => {
 		keys = keys.split(' ');
 
-		var o = {};
-		for (var i = 0, l = keys.length; i < l; i++) {
+		for (var i = 0, o = {}, l = keys.length; i < l; i++) {
 			o[keys[i]] = asciidoc[keys[i]];
 		}
 		return o;
@@ -222,13 +221,5 @@
 
 	asciidoc['title'].inside.rest = copyFromAsciiDoc('macro inline replacement entity');
 
-
-	// Plugin to make entity title show the real entity, idea by Roman Komarov
-	Prism.hooks.add('wrap', function (env) {
-		if (env.type === 'entity') {
-			env.attributes['title'] = env.content.replace(/&amp;/, '&');
-		}
-	});
-
-	Prism.languages.adoc = Prism.languages.asciidoc;
+	Prism.languages.adoc = asciidoc;
 }(Prism));
diff --git a/components/prism-aspnet.js b/components/prism-aspnet.js
index 1b1348c5d15b9b872f8fa051ff50bfd7b575d19a..3be4c303642b54ed06c21def2a5b24852bb05434 100644
--- a/components/prism-aspnet.js
+++ b/components/prism-aspnet.js
@@ -1,14 +1,15 @@
-Prism.languages.aspnet = Prism.languages.extend('markup', {
+var pageDirectiveInside = {
+	'page-directive': {
+		pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
+		alias: 'tag'
+	}
+}
+
+var aspnet = Prism.languages.aspnet = Prism.languages.extend('markup', {
 	'page-directive': {
 		pattern: /<%\s*@.*%>/,
 		alias: 'tag',
-		inside: {
-			'page-directive': {
-				pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
-				alias: 'tag'
-			},
-			rest: Prism.languages.markup.tag.inside
-		}
+		inside: pageDirectiveInside
 	},
 	'directive': {
 		pattern: /<%.*%>/,
@@ -18,17 +19,25 @@ Prism.languages.aspnet = Prism.languages.extend('markup', {
 				pattern: /<%\s*?[$=%#:]{0,2}|%>/,
 				alias: 'tag'
 			},
-			rest: Prism.languages.csharp
+			rest: 'csharp'
 		}
 	}
 });
+
+var brackets = aspnet['markup-bracket'];
+var tag = aspnet.tag;
+delete aspnet['markup-bracket'];
+
+aspnet['markup-bracket'] = brackets;
+pageDirectiveInside.rest = tag.inside
+
 // Regexp copied from prism-markup, with a negative look-ahead added
-Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
+tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
 
 // match directives of attribute value foo="<% Bar %>"
 Prism.languages.insertBefore('inside', 'punctuation', {
-	'directive': Prism.languages.aspnet['directive']
-}, Prism.languages.aspnet.tag.inside['attr-value']);
+	'directive': aspnet['directive']
+}, tag.inside['attr-value']);
 
 Prism.languages.insertBefore('aspnet', 'comment', {
 	'asp-comment': {
@@ -38,11 +47,11 @@ Prism.languages.insertBefore('aspnet', 'comment', {
 });
 
 // script runat="server" contains csharp, not javascript
-Prism.languages.insertBefore('aspnet', Prism.languages.javascript ? 'script' : 'tag', {
+Prism.languages.insertBefore('aspnet', aspnet.script ? 'script' : 'tag', {
 	'asp-script': {
 		pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
 		lookbehind: true,
 		alias: ['asp', 'script'],
-		inside: Prism.languages.csharp || {}
+		inside: 'csharp'
 	}
 });
diff --git a/components/prism-avisynth.js b/components/prism-avisynth.js
index 2400eb93bd2ac6ef7b2634dc69667c19eb0cd425..fd4edfc4623f5b44671a8151fbc4c7654768a62e 100644
--- a/components/prism-avisynth.js
+++ b/components/prism-avisynth.js
@@ -1,15 +1,13 @@
 // http://avisynth.nl/index.php/The_full_AviSynth_grammar
 (function (Prism) {
 
-	function replace(pattern, replacements) {
-		return pattern.replace(/<<(\d+)>>/g, function (m, index) {
-			return replacements[+index];
-		});
-	}
-
-	function re(pattern, replacements, flags) {
-		return RegExp(replace(pattern, replacements), flags || '');
-	}
+	var replace = (pattern, replacements) => 
+		pattern.replace(/<<(\d+)>>/g, (m, index) =>
+			replacements[+index]
+		);
+
+	var re = (pattern, replacements, flags = '') =>
+		RegExp(replace(pattern, replacements), flags);
 
 	var types = /bool|clip|float|int|string|val/.source;
 	var internals = [
diff --git a/components/prism-bash.js b/components/prism-bash.js
index 6d2e3815c2b589d8dc0bbb94e14a840e227e5a31..30213f9a8e93169db39b703c5d2c7a4496459ff2 100644
--- a/components/prism-bash.js
+++ b/components/prism-bash.js
@@ -9,7 +9,6 @@
 		pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
 		lookbehind: true,
 		alias: 'punctuation', // this looks reasonably well in all themes
-		inside: null // see below
 	};
 
 	var insideString = {
@@ -67,7 +66,7 @@
 		'entity': /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
 	};
 
-	Prism.languages.bash = {
+	var bash = commandAfterHeredoc.inside = Prism.languages.sh = Prism.languages.shell = Prism.languages.bash = {
 		'shebang': {
 			pattern: /^#!\s*\/.*/,
 			alias: 'important'
@@ -205,10 +204,9 @@
 		}
 	};
 
-	commandAfterHeredoc.inside = Prism.languages.bash;
-
 	/* Patterns in command substitution. */
-	var toBeCopied = [
+	var inside = insideString.variable[1].inside;
+	[
 		'comment',
 		'function-name',
 		'for-or-select',
@@ -224,12 +222,6 @@
 		'operator',
 		'punctuation',
 		'number'
-	];
-	var inside = insideString.variable[1].inside;
-	for (var i = 0; i < toBeCopied.length; i++) {
-		inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
-	}
+	].forEach(copied => inside[copied] = bash[copied])
 
-	Prism.languages.sh = Prism.languages.bash;
-	Prism.languages.shell = Prism.languages.bash;
 }(Prism));
diff --git a/components/prism-bnf.js b/components/prism-bnf.js
index dfbe3973a81f0fe56c4c60f3e615db48bf535294..795b6e16c511e824f98fbb461e2bb7561db33408 100644
--- a/components/prism-bnf.js
+++ b/components/prism-bnf.js
@@ -1,7 +1,5 @@
 Prism.languages.bnf = {
-	'string': {
-		pattern: /"[^\r\n"]*"|'[^\r\n']*'/
-	},
+	'string': /"[^\r\n"]*"|'[^\r\n']*'/,
 	'definition': {
 		pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
 		alias: ['rule', 'keyword'],
diff --git a/components/prism-brightscript.js b/components/prism-brightscript.js
index a75e55bf08c99fbde37894d4b60edbf3cc3ac6d8..1d4b30eb4bb815767eb3ee770d2997f0073f5b63 100644
--- a/components/prism-brightscript.js
+++ b/components/prism-brightscript.js
@@ -1,4 +1,8 @@
-Prism.languages.brightscript = {
+var expression = {
+	pattern: /[\s\S]+/
+}
+
+expression.inside = Prism.languages.brightscript = {
 	'comment': /(?:\brem|').*/i,
 	'directive-statement': {
 		pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
@@ -13,10 +17,7 @@ Prism.languages.brightscript = {
 				pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
 				alias: 'keyword'
 			},
-			'expression': {
-				pattern: /[\s\S]+/,
-				inside: null // see below
-			}
+			'expression': expression
 		}
 	},
 	'property': {
@@ -40,5 +41,3 @@ Prism.languages.brightscript = {
 	'punctuation': /[.,;()[\]{}]/,
 	'constant': /\b(?:LINE_NUM)\b/i
 };
-
-Prism.languages.brightscript['directive-statement'].inside.expression.inside = Prism.languages.brightscript;
diff --git a/components/prism-c.js b/components/prism-c.js
index 58ed906eca54798798bb08331cd6481847b8d2fe..5d593bab664962671d89eea99a88b8a1d16710bf 100644
--- a/components/prism-c.js
+++ b/components/prism-c.js
@@ -1,4 +1,4 @@
-Prism.languages.c = Prism.languages.extend('clike', {
+var c = Prism.languages.c = Prism.languages.extend('clike', {
 	'comment': {
 		pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
 		greedy: true
@@ -41,10 +41,10 @@ Prism.languages.insertBefore('c', 'string', {
 					pattern: /^(#\s*include\s*)<[^>]+>/,
 					lookbehind: true
 				},
-				Prism.languages.c['string']
+				c['string']
 			],
-			'char': Prism.languages.c['char'],
-			'comment': Prism.languages.c['comment'],
+			'char': c['char'],
+			'comment': c['comment'],
 			'macro-name': [
 				{
 					pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
@@ -66,7 +66,7 @@ Prism.languages.insertBefore('c', 'string', {
 			'punctuation': /##|\\(?=[\r\n])/,
 			'expression': {
 				pattern: /\S[\s\S]*/,
-				inside: Prism.languages.c
+				inside: c
 			}
 		}
 	}
@@ -77,4 +77,4 @@ Prism.languages.insertBefore('c', 'function', {
 	'constant': /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
 });
 
-delete Prism.languages.c['boolean'];
+delete c['boolean'];
diff --git a/components/prism-coffeescript.js b/components/prism-coffeescript.js
index 72fe0b8ba6e019b4e9854fbbe7a74c354ee6b09f..913b1d9ee22028aecd981db528f214f70a1e095e 100644
--- a/components/prism-coffeescript.js
+++ b/components/prism-coffeescript.js
@@ -7,7 +7,7 @@
 		alias: 'variable'
 	};
 
-	Prism.languages.coffeescript = Prism.languages.extend('javascript', {
+	var coffee = Prism.languages.coffee = Prism.languages.coffeescript = Prism.languages.extend('js', {
 		'comment': comment,
 		'string': [
 
@@ -61,7 +61,7 @@
 				'script': {
 					pattern: /[\s\S]+/,
 					alias: 'language-javascript',
-					inside: Prism.languages.javascript
+					inside: 'js'
 				}
 			}
 		},
@@ -90,7 +90,6 @@
 		'property': /(?!\d)\w+(?=\s*:(?!:))/
 	});
 
-	delete Prism.languages.coffeescript['template-string'];
+	delete coffee['template-string'];
 
-	Prism.languages.coffee = Prism.languages.coffeescript;
 }(Prism));
diff --git a/components/prism-concurnas.js b/components/prism-concurnas.js
index 476d0b49adf7bb250d3418bd3f86ea8f686653d3..e0370ef5ecd0b746be0f0ab323de90cf4d573b86 100644
--- a/components/prism-concurnas.js
+++ b/components/prism-concurnas.js
@@ -1,9 +1,33 @@
-Prism.languages.concurnas = {
+Prism.languages.conc = Prism.languages.concurnas = {
 	'comment': {
 		pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
 		lookbehind: true,
 		greedy: true
 	},
+	'regex-literal': {
+		pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
+		greedy: true,
+		inside: {
+			'interpolation': {
+				pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
+				lookbehind: true,
+				inside: 'conc'
+			},
+			'regex': /[\s\S]+/
+		}
+	},
+	'string-literal': {
+		pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
+		greedy: true,
+		inside: {
+			'interpolation': {
+				pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
+				lookbehind: true,
+				inside: 'conc'
+			},
+			'string': /[\s\S]+/
+		}
+	},
 	'langext': {
 		pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
 		greedy: true,
@@ -30,32 +54,3 @@ Prism.languages.concurnas = {
 		alias: 'builtin'
 	}
 };
-
-Prism.languages.insertBefore('concurnas', 'langext', {
-	'regex-literal': {
-		pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
-		greedy: true,
-		inside: {
-			'interpolation': {
-				pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
-				lookbehind: true,
-				inside: Prism.languages.concurnas
-			},
-			'regex': /[\s\S]+/
-		}
-	},
-	'string-literal': {
-		pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
-		greedy: true,
-		inside: {
-			'interpolation': {
-				pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
-				lookbehind: true,
-				inside: Prism.languages.concurnas
-			},
-			'string': /[\s\S]+/
-		}
-	}
-});
-
-Prism.languages.conc = Prism.languages.concurnas;
diff --git a/components/prism-cooklang.js b/components/prism-cooklang.js
index cb49ed1260c48f7ecedb5b9148ba40e8901eef3d..8182c35332cad5f5ca8bb13304f457f72d8d1f64 100644
--- a/components/prism-cooklang.js
+++ b/components/prism-cooklang.js
@@ -58,18 +58,10 @@
 			}
 		},
 		'cookware-group': { // #...{...}, #...
-			pattern: new RegExp('#(?:'
-				+ multi_token
-				+ '|'
-				+ single_token_suffix
-				+ ')'
-			),
+			pattern: RegExp(`#(?:${multi_token}|${single_token_suffix})`),
 			inside: {
 				'cookware': {
-					pattern: new RegExp('(^#)(?:'
-						+ multi_token_infix
-						+ ')'
-					),
+					pattern: RegExp(`(^#)(?:${multi_token_infix})`),
 					lookbehind: true,
 					alias: 'variable',
 				},
@@ -78,10 +70,10 @@
 					alias: 'keyword',
 				},
 				'quantity-group': {
-					pattern: new RegExp(/\{[^{}@#]*\}/),
+					pattern: RegExp(/\{[^{}@#]*\}/),
 					inside: {
 						'quantity': {
-							pattern: new RegExp(/(^\{)/.source + multi_token_infix),
+							pattern: RegExp('(^\\{)' + multi_token_infix),
 							lookbehind: true,
 							alias: 'number',
 						},
@@ -91,16 +83,10 @@
 			},
 		},
 		'ingredient-group': { // @...{...}, @...
-			pattern: new RegExp('@(?:'
-				+ multi_token
-				+ '|'
-				+ single_token_suffix
-				+ ')'),
+			pattern: RegExp(`@(?:${multi_token}|${single_token_suffix})`),
 			inside: {
 				'ingredient': {
-					pattern: new RegExp('(^@)(?:'
-						+ multi_token_infix
-						+ ')'),
+					pattern: RegExp(`(^@)(?:${multi_token_infix})`),
 					lookbehind: true,
 					alias: 'variable',
 				},
@@ -125,7 +111,7 @@
 					inside: {
 						'punctuation': /[{}]/,
 						'unit': {
-							pattern: new RegExp(/(%\s*)/.source + timer_units + /\b/.source),
+							pattern: RegExp('(%\\s*)' + timer_units + '\\b'),
 							lookbehind: true,
 							alias: 'symbol',
 						},
diff --git a/components/prism-coq.js b/components/prism-coq.js
index 663ed9a5fa5f11880612c1d588bdc2aa46c2d875..1b58b674cb250bc560b57aec543bc9522c72fd2b 100644
--- a/components/prism-coq.js
+++ b/components/prism-coq.js
@@ -4,7 +4,7 @@
 
 	var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
 	for (var i = 0; i < 2; i++) {
-		commentSource = commentSource.replace(/<self>/g, function () { return commentSource; });
+		commentSource = commentSource.replace(/<self>/g, commentSource);
 	}
 	commentSource = commentSource.replace(/<self>/g, '[]');
 
@@ -18,7 +18,7 @@
 			{
 				pattern: RegExp(
 					/#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source
-						.replace(/<comment>/g, function () { return commentSource; })
+						.replace(/<comment>/g, commentSource)
 				),
 				greedy: true,
 				alias: 'attr-name',
diff --git a/components/prism-core.js b/components/prism-core.js
index 1259f23e07c9c4e62f32a7705e9fbb7d52c8c060..37a6dca69da7a31a88c61d77c2636858f1ff18c4 100644
--- a/components/prism-core.js
+++ b/components/prism-core.js
@@ -1,13 +1,3 @@
-/// <reference lib="WebWorker"/>
-
-var _self = (typeof window !== 'undefined')
-	? window   // if in browser
-	: (
-		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
-			? self // if in worker
-			: {}   // if in node js
-	);
-
 /**
  * Prism: Lightweight, robust, elegant syntax highlighting
  *
@@ -16,62 +6,42 @@ var _self = (typeof window !== 'undefined')
  * @namespace
  * @public
  */
-var Prism = (function (_self) {
-
-	// Private helper vars
-	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
-	var uniqueId = 0;
+export default (() => {
 
 	// The grammar object for plaintext
 	var plainTextGrammar = {};
 
+	var hooks = {};
 
-	var _ = {
-		/**
-		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
-		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
-		 * additional languages or plugins yourself.
-		 *
-		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
-		 *
-		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
-		 * empty Prism object into the global scope before loading the Prism script like this:
-		 *
-		 * ```js
-		 * window.Prism = window.Prism || {};
-		 * Prism.manual = true;
-		 * // add a new <script> to load Prism's script
-		 * ```
-		 *
-		 * @default false
-		 * @type {boolean}
-		 * @memberof Prism
-		 * @public
-		 */
-		manual: _self.Prism && _self.Prism.manual,
-		/**
-		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
-		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
-		 * own worker, you don't want it to do this.
-		 *
-		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
-		 *
-		 * You obviously have to change this value before Prism executes. To do this, you can add an
-		 * empty Prism object into the global scope before loading the Prism script like this:
-		 *
-		 * ```js
-		 * window.Prism = window.Prism || {};
-		 * Prism.disableWorkerMessageHandler = true;
-		 * // Load Prism's script
-		 * ```
-		 *
-		 * @default false
-		 * @type {boolean}
-		 * @memberof Prism
-		 * @public
-		 */
-		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
+	var resolve = prop => typeof prop == 'string' ? _.languages[prop] : prop;
+
+	var clone = (o, visited = new Map) => {
+		if (visited.has(o)) return visited.get(o);
+		var copy = o, t = type(o);
+
+		if (t == "Object") {
+			visited.set(o, copy = {});
+			for (var key in o) {
+				if (o.hasOwnProperty(key)) {
+					copy[key] = clone(o[key], visited);
+				}
+			}
+		}
+		else if (t == "Array") {
+			visited.set(o, copy = []);
+			for (var i = 0, l = o.length; i < l; i++) {
+				copy[i] = clone(o[i], visited);
+			}
+		}
+
+		return copy;
+	}
 
+	var toString = {}.toString;
+
+	var type = o => toString.call(o).slice(8, -1);
+
+	var _ = {
 		/**
 		 * A namespace for utility methods.
 		 *
@@ -82,16 +52,6 @@ var Prism = (function (_self) {
 		 * @memberof Prism
 		 */
 		util: {
-			encode: function encode(tokens) {
-				if (tokens instanceof Token) {
-					return new Token(tokens.type, encode(tokens.content), tokens.alias);
-				} else if (Array.isArray(tokens)) {
-					return tokens.map(encode);
-				} else {
-					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
-				}
-			},
-
 			/**
 			 * Returns the name of the type of the given value.
 			 *
@@ -108,22 +68,7 @@ var Prism = (function (_self) {
 			 * type(String)    === 'Function'
 			 * type(/abc+/)    === 'RegExp'
 			 */
-			type: function (o) {
-				return Object.prototype.toString.call(o).slice(8, -1);
-			},
-
-			/**
-			 * Returns a unique number for the given object. Later calls will still return the same number.
-			 *
-			 * @param {Object} obj
-			 * @returns {number}
-			 */
-			objId: function (obj) {
-				if (!obj['__id']) {
-					Object.defineProperty(obj, '__id', { value: ++uniqueId });
-				}
-				return obj['__id'];
-			},
+			type,
 
 			/**
 			 * Creates a deep clone of the given object.
@@ -131,162 +76,11 @@ var Prism = (function (_self) {
 			 * The main intended use of this function is to clone language definitions.
 			 *
 			 * @param {T} o
-			 * @param {Record<number, any>} [visited]
+			 * @param {Map<any, any>} [visited]
 			 * @returns {T}
 			 * @template T
 			 */
-			clone: function deepClone(o, visited) {
-				visited = visited || {};
-
-				var clone; var id;
-				switch (_.util.type(o)) {
-					case 'Object':
-						id = _.util.objId(o);
-						if (visited[id]) {
-							return visited[id];
-						}
-						clone = /** @type {Record<string, any>} */ ({});
-						visited[id] = clone;
-
-						for (var key in o) {
-							if (o.hasOwnProperty(key)) {
-								clone[key] = deepClone(o[key], visited);
-							}
-						}
-
-						return /** @type {any} */ (clone);
-
-					case 'Array':
-						id = _.util.objId(o);
-						if (visited[id]) {
-							return visited[id];
-						}
-						clone = [];
-						visited[id] = clone;
-
-						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
-							clone[i] = deepClone(v, visited);
-						});
-
-						return /** @type {any} */ (clone);
-
-					default:
-						return o;
-				}
-			},
-
-			/**
-			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
-			 *
-			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
-			 *
-			 * @param {Element} element
-			 * @returns {string}
-			 */
-			getLanguage: function (element) {
-				while (element) {
-					var m = lang.exec(element.className);
-					if (m) {
-						return m[1].toLowerCase();
-					}
-					element = element.parentElement;
-				}
-				return 'none';
-			},
-
-			/**
-			 * Sets the Prism `language-xxxx` class of the given element.
-			 *
-			 * @param {Element} element
-			 * @param {string} language
-			 * @returns {void}
-			 */
-			setLanguage: function (element, language) {
-				// remove all `language-xxxx` classes
-				// (this might leave behind a leading space)
-				element.className = element.className.replace(RegExp(lang, 'gi'), '');
-
-				// add the new `language-xxxx` class
-				// (using `classList` will automatically clean up spaces for us)
-				element.classList.add('language-' + language);
-			},
-
-			/**
-			 * Returns the script element that is currently executing.
-			 *
-			 * This does __not__ work for line script element.
-			 *
-			 * @returns {HTMLScriptElement | null}
-			 */
-			currentScript: function () {
-				if (typeof document === 'undefined') {
-					return null;
-				}
-				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
-					return /** @type {any} */ (document.currentScript);
-				}
-
-				// IE11 workaround
-				// we'll get the src of the current script by parsing IE11's error stack trace
-				// this will not work for inline scripts
-
-				try {
-					throw new Error();
-				} catch (err) {
-					// Get file src url from stack. Specifically works with the format of stack traces in IE.
-					// A stack will look like this:
-					//
-					// Error
-					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
-					//    at Global code (http://localhost/components/prism-core.js:606:1)
-
-					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
-					if (src) {
-						var scripts = document.getElementsByTagName('script');
-						for (var i in scripts) {
-							if (scripts[i].src == src) {
-								return scripts[i];
-							}
-						}
-					}
-					return null;
-				}
-			},
-
-			/**
-			 * Returns whether a given class is active for `element`.
-			 *
-			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
-			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
-			 * given class is just the given class with a `no-` prefix.
-			 *
-			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
-			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
-			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
-			 *
-			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
-			 * version of it, the class is considered active.
-			 *
-			 * @param {Element} element
-			 * @param {string} className
-			 * @param {boolean} [defaultActivation=false]
-			 * @returns {boolean}
-			 */
-			isActive: function (element, className, defaultActivation) {
-				var no = 'no-' + className;
-
-				while (element) {
-					var classList = element.classList;
-					if (classList.contains(className)) {
-						return true;
-					}
-					if (classList.contains(no)) {
-						return false;
-					}
-					element = element.parentElement;
-				}
-				return !!defaultActivation;
-			}
+			clone,
 		},
 
 		/**
@@ -333,15 +127,7 @@ var Prism = (function (_self) {
 			 *     'color': /\b(?:red|green|blue)\b/
 			 * });
 			 */
-			extend: function (id, redef) {
-				var lang = _.util.clone(_.languages[id]);
-
-				for (var key in redef) {
-					lang[key] = redef[key];
-				}
-
-				return lang;
-			},
+			extend: (id, redef) => Object.assign(clone(_.languages[id]), redef),
 
 			/**
 			 * Inserts tokens _before_ another token in a language definition or any other grammar.
@@ -418,255 +204,31 @@ var Prism = (function (_self) {
 			 * @returns {Grammar} The new grammar object.
 			 * @public
 			 */
-			insertBefore: function (inside, before, insert, root) {
-				root = root || /** @type {any} */ (_.languages);
+			insertBefore(inside, before, insert, root = _.languages) {
 				var grammar = root[inside];
-				/** @type {Grammar} */
-				var ret = {};
+				var temp = {};
 
 				for (var token in grammar) {
 					if (grammar.hasOwnProperty(token)) {
-
-						if (token == before) {
-							for (var newToken in insert) {
-								if (insert.hasOwnProperty(newToken)) {
-									ret[newToken] = insert[newToken];
-								}
-							}
-						}
-
-						// Do not insert token which also occur in insert. See #1525
-						if (!insert.hasOwnProperty(token)) {
-							ret[token] = grammar[token];
-						}
+						temp[token] = grammar[token];
+						delete grammar[token];
 					}
 				}
+				
+				for (var token in temp) {
+					if (token == before) Object.assign(grammar, insert);
 
-				var old = root[inside];
-				root[inside] = ret;
-
-				// Update references in other language definitions
-				_.languages.DFS(_.languages, function (key, value) {
-					if (value === old && key != inside) {
-						this[key] = ret;
+					// Do not insert token which also occur in insert. See #1525
+					if (!insert.hasOwnProperty(token)) {
+						grammar[token] = temp[token];
 					}
-				});
+				}
 
-				return ret;
+				return grammar;
 			},
-
-			// Traverse a language definition with Depth First Search
-			DFS: function DFS(o, callback, type, visited) {
-				visited = visited || {};
-
-				var objId = _.util.objId;
-
-				for (var i in o) {
-					if (o.hasOwnProperty(i)) {
-						callback.call(o, i, o[i], type || i);
-
-						var property = o[i];
-						var propertyType = _.util.type(property);
-
-						if (propertyType === 'Object' && !visited[objId(property)]) {
-							visited[objId(property)] = true;
-							DFS(property, callback, null, visited);
-						} else if (propertyType === 'Array' && !visited[objId(property)]) {
-							visited[objId(property)] = true;
-							DFS(property, callback, i, visited);
-						}
-					}
-				}
-			}
 		},
 
 		plugins: {},
-
-		/**
-		 * This is the most high-level function in Prism’s API.
-		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
-		 * each one of them.
-		 *
-		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
-		 *
-		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
-		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightAll: function (async, callback) {
-			_.highlightAllUnder(document, async, callback);
-		},
-
-		/**
-		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
-		 * {@link Prism.highlightElement} on each one of them.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-highlightall`
-		 * 2. `before-all-elements-highlight`
-		 * 3. All hooks of {@link Prism.highlightElement} for each element.
-		 *
-		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
-		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
-		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightAllUnder: function (container, async, callback) {
-			var env = {
-				callback: callback,
-				container: container,
-				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
-			};
-
-			_.hooks.run('before-highlightall', env);
-
-			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
-
-			_.hooks.run('before-all-elements-highlight', env);
-
-			for (var i = 0, element; (element = env.elements[i++]);) {
-				_.highlightElement(element, async === true, env.callback);
-			}
-		},
-
-		/**
-		 * Highlights the code inside a single element.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-sanity-check`
-		 * 2. `before-highlight`
-		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
-		 * 4. `before-insert`
-		 * 5. `after-highlight`
-		 * 6. `complete`
-		 *
-		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
-		 * the element's language.
-		 *
-		 * @param {Element} element The element containing the code.
-		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
-		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
-		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
-		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
-		 *
-		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
-		 * asynchronous highlighting to work. You can build your own bundle on the
-		 * [Download page](https://prismjs.com/download.html).
-		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
-		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
-		 * @memberof Prism
-		 * @public
-		 */
-		highlightElement: function (element, async, callback) {
-			// Find language
-			var language = _.util.getLanguage(element);
-			var grammar = _.languages[language];
-
-			// Set language on the element, if not present
-			_.util.setLanguage(element, language);
-
-			// Set language on the parent, for styling
-			var parent = element.parentElement;
-			if (parent && parent.nodeName.toLowerCase() === 'pre') {
-				_.util.setLanguage(parent, language);
-			}
-
-			var code = element.textContent;
-
-			var env = {
-				element: element,
-				language: language,
-				grammar: grammar,
-				code: code
-			};
-
-			function insertHighlightedCode(highlightedCode) {
-				env.highlightedCode = highlightedCode;
-
-				_.hooks.run('before-insert', env);
-
-				env.element.innerHTML = env.highlightedCode;
-
-				_.hooks.run('after-highlight', env);
-				_.hooks.run('complete', env);
-				callback && callback.call(env.element);
-			}
-
-			_.hooks.run('before-sanity-check', env);
-
-			// plugins may change/add the parent/element
-			parent = env.element.parentElement;
-			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
-				parent.setAttribute('tabindex', '0');
-			}
-
-			if (!env.code) {
-				_.hooks.run('complete', env);
-				callback && callback.call(env.element);
-				return;
-			}
-
-			_.hooks.run('before-highlight', env);
-
-			if (!env.grammar) {
-				insertHighlightedCode(_.util.encode(env.code));
-				return;
-			}
-
-			if (async && _self.Worker) {
-				var worker = new Worker(_.filename);
-
-				worker.onmessage = function (evt) {
-					insertHighlightedCode(evt.data);
-				};
-
-				worker.postMessage(JSON.stringify({
-					language: env.language,
-					code: env.code,
-					immediateClose: true
-				}));
-			} else {
-				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
-			}
-		},
-
-		/**
-		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
-		 * and the language definitions to use, and returns a string with the HTML produced.
-		 *
-		 * The following hooks will be run:
-		 * 1. `before-tokenize`
-		 * 2. `after-tokenize`
-		 * 3. `wrap`: On each {@link Token}.
-		 *
-		 * @param {string} text A string with the code to be highlighted.
-		 * @param {Grammar} grammar An object containing the tokens to use.
-		 *
-		 * Usually a language definition like `Prism.languages.markup`.
-		 * @param {string} language The name of the language definition passed to `grammar`.
-		 * @returns {string} The highlighted HTML.
-		 * @memberof Prism
-		 * @public
-		 * @example
-		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
-		 */
-		highlight: function (text, grammar, language) {
-			var env = {
-				code: text,
-				grammar: grammar,
-				language: language
-			};
-			_.hooks.run('before-tokenize', env);
-			if (!env.grammar) {
-				throw new Error('The language "' + env.language + '" has no grammar.');
-			}
-			env.tokens = _.tokenize(env.code, env.grammar);
-			_.hooks.run('after-tokenize', env);
-			return Token.stringify(_.util.encode(env.tokens), env.language);
-		},
-
 		/**
 		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
 		 * and the language definitions to use, and returns an array with the tokenized code.
@@ -691,22 +253,27 @@ var Prism = (function (_self) {
 		 *     }
 		 * });
 		 */
-		tokenize: function (text, grammar) {
-			var rest = grammar.rest;
+		tokenize(text, grammar) {
+			var head = {};
+			var tail = { prev: head };
+			var tokenList = {
+				head, tail, length: 0
+			};
+			var rest = resolve(grammar.rest);
+			var array = [], i = 0;
+			head.next = tail;
 			if (rest) {
-				for (var token in rest) {
-					grammar[token] = rest[token];
-				}
-
+				Object.assign(grammar, rest);
 				delete grammar.rest;
 			}
 
-			var tokenList = new LinkedList();
-			addAfter(tokenList, tokenList.head, text);
-
-			matchGrammar(text, tokenList, grammar, tokenList.head, 0);
-
-			return toArray(tokenList);
+			addAfter(tokenList, head, text);
+			matchGrammar(text, tokenList, grammar, head, 0);
+			
+			while ((head = head.next) != tail) {
+				array[i++] = head.value;
+			}
+			return array;
 		},
 
 		/**
@@ -715,7 +282,7 @@ var Prism = (function (_self) {
 		 * @public
 		 */
 		hooks: {
-			all: {},
+			all: hooks,
 
 			/**
 			 * Adds the given callback to the list of callbacks for the given hook.
@@ -729,12 +296,8 @@ var Prism = (function (_self) {
 			 * @param {HookCallback} callback The callback function which is given environment variables.
 			 * @public
 			 */
-			add: function (name, callback) {
-				var hooks = _.hooks.all;
-
-				hooks[name] = hooks[name] || [];
-
-				hooks[name].push(callback);
+			add(name, callback) {
+				(hooks[name] || (hooks[name] = [])).push(callback);
 			},
 
 			/**
@@ -746,149 +309,20 @@ var Prism = (function (_self) {
 			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
 			 * @public
 			 */
-			run: function (name, env) {
-				var callbacks = _.hooks.all[name];
-
-				if (!callbacks || !callbacks.length) {
-					return;
-				}
-
-				for (var i = 0, callback; (callback = callbacks[i++]);) {
-					callback(env);
-				}
+			run(name, env) {
+				hooks[name] && hooks[name].forEach(callback => callback(env));
 			}
 		},
-
-		Token: Token
-	};
-	_self.Prism = _;
-
-
-	// Typescript note:
-	// The following can be used to import the Token type in JSDoc:
-	//
-	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
-
-	/**
-	 * Creates a new token.
-	 *
-	 * @param {string} type See {@link Token#type type}
-	 * @param {string | TokenStream} content See {@link Token#content content}
-	 * @param {string|string[]} [alias] The alias(es) of the token.
-	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
-	 * @class
-	 * @global
-	 * @public
-	 */
-	function Token(type, content, alias, matchedStr) {
-		/**
-		 * The type of the token.
-		 *
-		 * This is usually the key of a pattern in a {@link Grammar}.
-		 *
-		 * @type {string}
-		 * @see GrammarToken
-		 * @public
-		 */
-		this.type = type;
-		/**
-		 * The strings or tokens contained by this token.
-		 *
-		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
-		 *
-		 * @type {string | TokenStream}
-		 * @public
-		 */
-		this.content = content;
-		/**
-		 * The alias(es) of the token.
-		 *
-		 * @type {string|string[]}
-		 * @see GrammarToken
-		 * @public
-		 */
-		this.alias = alias;
-		// Copy of the full string this token was created from
-		this.length = (matchedStr || '').length | 0;
-	}
-
-	/**
-	 * A token stream is an array of strings and {@link Token Token} objects.
-	 *
-	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
-	 * them.
-	 *
-	 * 1. No adjacent strings.
-	 * 2. No empty strings.
-	 *
-	 *    The only exception here is the token stream that only contains the empty string and nothing else.
-	 *
-	 * @typedef {Array<string | Token>} TokenStream
-	 * @global
-	 * @public
-	 */
-
-	/**
-	 * Converts the given token or token stream to an HTML representation.
-	 *
-	 * The following hooks will be run:
-	 * 1. `wrap`: On each {@link Token}.
-	 *
-	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
-	 * @param {string} language The name of current language.
-	 * @returns {string} The HTML representation of the token or token stream.
-	 * @memberof Token
-	 * @static
-	 */
-	Token.stringify = function stringify(o, language) {
-		if (typeof o == 'string') {
-			return o;
-		}
-		if (Array.isArray(o)) {
-			var s = '';
-			o.forEach(function (e) {
-				s += stringify(e, language);
-			});
-			return s;
-		}
-
-		var env = {
-			type: o.type,
-			content: stringify(o.content, language),
-			tag: 'span',
-			classes: ['token', o.type],
-			attributes: {},
-			language: language
-		};
-
-		var aliases = o.alias;
-		if (aliases) {
-			if (Array.isArray(aliases)) {
-				Array.prototype.push.apply(env.classes, aliases);
-			} else {
-				env.classes.push(aliases);
-			}
-		}
-
-		_.hooks.run('wrap', env);
-
-		var attributes = '';
-		for (var name in env.attributes) {
-			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
-		}
-
-		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
+		Token
 	};
 
 	/**
 	 * @param {RegExp} pattern
-	 * @param {number} pos
 	 * @param {string} text
 	 * @param {boolean} lookbehind
 	 * @returns {RegExpExecArray | null}
 	 */
-	function matchPattern(pattern, pos, text, lookbehind) {
-		pattern.lastIndex = pos;
+	var matchPattern = (pattern, text, lookbehind) => {
 		var match = pattern.exec(text);
 		if (match && lookbehind && match[1]) {
 			// change the match to remove the text matched by the Prism lookbehind group
@@ -909,49 +343,33 @@ var Prism = (function (_self) {
 	 * @returns {void}
 	 * @private
 	 *
-	 * @typedef RematchOptions
-	 * @property {string} cause
-	 * @property {number} reach
+	 * @typedef {{ a: Token, b: number, c: string }} RematchOptions
 	 */
-	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
+	var matchGrammar = (text, tokenList, grammar, startNode, startPos, rematch) => {
 		for (var token in grammar) {
-			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
-				continue;
-			}
-
-			var patterns = grammar[token];
-			patterns = Array.isArray(patterns) ? patterns : [patterns];
-
-			for (var j = 0; j < patterns.length; ++j) {
-				if (rematch && rematch.cause == token + ',' + j) {
+			if (grammar.hasOwnProperty(token) && grammar[token]) for (var j = 0, p = grammar[token], patterns = Array.isArray(p) ? p : [p]; j < patterns.length; ++j) {
+				if (rematch && rematch.b == j && rematch.a == token) {
 					return;
 				}
 
 				var patternObj = patterns[j];
-				var inside = patternObj.inside;
-				var lookbehind = !!patternObj.lookbehind;
-				var greedy = !!patternObj.greedy;
+				var inside = resolve(patternObj.inside);
+				var lookbehind = patternObj.lookbehind;
+				var greedy = patternObj.greedy;
 				var alias = patternObj.alias;
 
-				if (greedy && !patternObj.pattern.global) {
-					// Without the global flag, lastIndex won't work
-					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
-					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
-				}
-
 				/** @type {RegExp} */
 				var pattern = patternObj.pattern || patternObj;
-
+				if (greedy && !pattern.global) {
+					// Without the global flag, lastIndex won't work
+					pattern = patternObj.pattern = RegExp(pattern.source, `${pattern}g`.match(/[imsuyg]*$/)[0]);
+				}
+				
 				for ( // iterate the token list and keep track of the current token/string position
 					var currentNode = startNode.next, pos = startPos;
-					currentNode !== tokenList.tail;
+					currentNode != tokenList.tail && (!rematch || pos < rematch.c);
 					pos += currentNode.value.length, currentNode = currentNode.next
 				) {
-
-					if (rematch && pos >= rematch.reach) {
-						break;
-					}
-
 					var str = currentNode.value;
 
 					if (tokenList.length > text.length) {
@@ -967,24 +385,21 @@ var Prism = (function (_self) {
 					var match;
 
 					if (greedy) {
-						match = matchPattern(pattern, pos, text, lookbehind);
+						pattern.lastIndex = pos
+						match = matchPattern(pattern, text, lookbehind);
 						if (!match || match.index >= text.length) {
 							break;
 						}
 
 						var from = match.index;
-						var to = match.index + match[0].length;
-						var p = pos;
+						var to = from + match[0].length;
 
 						// find the node that contains the match
-						p += currentNode.value.length;
-						while (from >= p) {
+						while (from >= (pos += currentNode.value.length)) {
 							currentNode = currentNode.next;
-							p += currentNode.value.length;
 						}
-						// adjust pos (and p)
-						p -= currentNode.value.length;
-						pos = p;
+						// adjust pos
+						pos -= currentNode.value.length;
 
 						// the current node is a Token, then the match starts inside another Token, which is invalid
 						if (currentNode.value instanceof Token) {
@@ -993,8 +408,8 @@ var Prism = (function (_self) {
 
 						// find the last node which is affected by this match
 						for (
-							var k = currentNode;
-							k !== tokenList.tail && (p < to || typeof k.value === 'string');
+							var k = currentNode, p = pos;
+							k != tokenList.tail && (p < to || typeof k.value == 'string');
 							k = k.next
 						) {
 							removeCount++;
@@ -1006,7 +421,7 @@ var Prism = (function (_self) {
 						str = text.slice(pos, p);
 						match.index -= pos;
 					} else {
-						match = matchPattern(pattern, 0, str, lookbehind);
+						match = matchPattern(pattern, str, lookbehind);
 						if (!match) {
 							continue;
 						}
@@ -1017,21 +432,26 @@ var Prism = (function (_self) {
 					var matchStr = match[0];
 					var before = str.slice(0, from);
 					var after = str.slice(from + matchStr.length);
-
 					var reach = pos + str.length;
-					if (rematch && reach > rematch.reach) {
-						rematch.reach = reach;
-					}
-
 					var removeFrom = currentNode.prev;
 
+					if (rematch && reach > rematch.c) {
+						rematch.c = reach;
+					}
+
 					if (before) {
 						removeFrom = addAfter(tokenList, removeFrom, before);
 						pos += before.length;
 					}
 
-					removeRange(tokenList, removeFrom, removeCount);
-
+					var next = removeFrom.next;
+					for (var i = 0; i < removeCount && next != tokenList.tail; i++) {
+						next = next.next;
+					}
+					removeFrom.next = next;
+					next.prev = removeFrom;
+					tokenList.length -= i;
+					
 					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
 					currentNode = addAfter(tokenList, removeFrom, wrapped);
 
@@ -1044,15 +464,13 @@ var Prism = (function (_self) {
 						// this can only happen if the current pattern is greedy
 
 						/** @type {RematchOptions} */
-						var nestedRematch = {
-							cause: token + ',' + j,
-							reach: reach
-						};
+						// var nestedRematch = [token, j, reach];
+						var nestedRematch = {a: token, b: j, c: reach};
 						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
 
 						// the reach might have been extended because of the rematching
-						if (rematch && nestedRematch.reach > rematch.reach) {
-							rematch.reach = nestedRematch.reach;
+						if (rematch && nestedRematch.c > rematch.c) {
+							rematch.c = nestedRematch.c;
 						}
 					}
 				}
@@ -1069,24 +487,6 @@ var Prism = (function (_self) {
 	 * @private
 	 */
 
-	/**
-	 * @template T
-	 * @private
-	 */
-	function LinkedList() {
-		/** @type {LinkedListNode<T>} */
-		var head = { value: null, prev: null, next: null };
-		/** @type {LinkedListNode<T>} */
-		var tail = { value: null, prev: head, next: null };
-		head.next = tail;
-
-		/** @type {LinkedListNode<T>} */
-		this.head = head;
-		/** @type {LinkedListNode<T>} */
-		this.tail = tail;
-		this.length = 0;
-	}
-
 	/**
 	 * Adds a new node with the given value to the list.
 	 *
@@ -1096,168 +496,60 @@ var Prism = (function (_self) {
 	 * @returns {LinkedListNode<T>} The added node.
 	 * @template T
 	 */
-	function addAfter(list, node, value) {
+	var addAfter = (list, node, value) => {
 		// assumes that node != list.tail && values.length >= 0
 		var next = node.next;
-
-		var newNode = { value: value, prev: node, next: next };
-		node.next = newNode;
-		next.prev = newNode;
 		list.length++;
-
-		return newNode;
+		return node.next = next.prev = { value, prev: node, next };
 	}
+
+	// Typescript note:
+	// The following can be used to import the Token type in JSDoc:
+	//
+	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
+
 	/**
-	 * Removes `count` nodes after the given node. The given node will not be removed.
+	 * Creates a new token.
 	 *
-	 * @param {LinkedList<T>} list
-	 * @param {LinkedListNode<T>} node
-	 * @param {number} count
-	 * @template T
-	 */
-	function removeRange(list, node, count) {
-		var next = node.next;
-		for (var i = 0; i < count && next !== list.tail; i++) {
-			next = next.next;
-		}
-		node.next = next;
-		next.prev = node;
-		list.length -= i;
-	}
-	/**
-	 * @param {LinkedList<T>} list
-	 * @returns {T[]}
-	 * @template T
+	 * @param {string} type See {@link Token#type type}
+	 * @param {string | TokenStream} content See {@link Token#content content}
+	 * @param {string|string[]} [alias] The alias(es) of the token.
+	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
+	 * @class
+	 * @global
+	 * @public
 	 */
-	function toArray(list) {
-		var array = [];
-		var node = list.head.next;
-		while (node !== list.tail) {
-			array.push(node.value);
-			node = node.next;
-		}
-		return array;
-	}
-
-
-	if (!_self.document) {
-		if (!_self.addEventListener) {
-			// in Node.js
-			return _;
-		}
-
-		if (!_.disableWorkerMessageHandler) {
-			// In worker
-			_self.addEventListener('message', function (evt) {
-				var message = JSON.parse(evt.data);
-				var lang = message.language;
-				var code = message.code;
-				var immediateClose = message.immediateClose;
-
-				_self.postMessage(_.highlight(code, _.languages[lang], lang));
-				if (immediateClose) {
-					_self.close();
-				}
-			}, false);
-		}
-
-		return _;
-	}
-
-	// Get current script and highlight
-	var script = _.util.currentScript();
-
-	if (script) {
-		_.filename = script.src;
-
-		if (script.hasAttribute('data-manual')) {
-			_.manual = true;
-		}
-	}
-
-	function highlightAutomaticallyCallback() {
-		if (!_.manual) {
-			_.highlightAll();
-		}
-	}
-
-	if (!_.manual) {
-		// If the document state is "loading", then we'll use DOMContentLoaded.
-		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
-		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
-		// might take longer one animation frame to execute which can create a race condition where only some plugins have
-		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
-		// See https://github.com/PrismJS/prism/issues/2102
-		var readyState = document.readyState;
-		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
-			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
-		} else {
-			if (window.requestAnimationFrame) {
-				window.requestAnimationFrame(highlightAutomaticallyCallback);
-			} else {
-				window.setTimeout(highlightAutomaticallyCallback, 16);
-			}
-		}
+	function Token(type, content, alias, matchedStr = '') {
+		/**
+		 * The type of the token.
+		 *
+		 * This is usually the key of a pattern in a {@link Grammar}.
+		 *
+		 * @type {string}
+		 * @see GrammarToken
+		 * @public
+		 */
+		this.type = type;
+		/**
+		 * The strings or tokens contained by this token.
+		 *
+		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
+		 *
+		 * @type {string | TokenStream}
+		 * @public
+		 */
+		this.content = content;
+		/**
+		 * The alias(es) of the token.
+		 *
+		 * @type {string|string[]}
+		 * @see GrammarToken
+		 * @public
+		 */
+		this.alias = alias;
+		// Copy of the full string this token was created from
+		this.length = matchedStr.length;
 	}
 
 	return _;
-
-}(_self));
-
-if (typeof module !== 'undefined' && module.exports) {
-	module.exports = Prism;
-}
-
-// hack for components to work correctly in node.js
-if (typeof global !== 'undefined') {
-	global.Prism = Prism;
-}
-
-// some additional documentation/types
-
-/**
- * The expansion of a simple `RegExp` literal to support additional properties.
- *
- * @typedef GrammarToken
- * @property {RegExp} pattern The regular expression of the token.
- * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
- * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
- * @property {boolean} [greedy=false] Whether the token is greedy.
- * @property {string|string[]} [alias] An optional alias or list of aliases.
- * @property {Grammar} [inside] The nested grammar of this token.
- *
- * The `inside` grammar will be used to tokenize the text value of each token of this kind.
- *
- * This can be used to make nested and even recursive language definitions.
- *
- * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
- * each another.
- * @global
- * @public
- */
-
-/**
- * @typedef Grammar
- * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
- * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
- * @global
- * @public
- */
-
-/**
- * A function which will invoked after an element was successfully highlighted.
- *
- * @callback HighlightCallback
- * @param {Element} element The element successfully highlighted.
- * @returns {void}
- * @global
- * @public
- */
-
-/**
- * @callback HookCallback
- * @param {Object<string, any>} env The environment variables of the hook.
- * @returns {void}
- * @global
- * @public
- */
+})();
diff --git a/components/prism-cpp.js b/components/prism-cpp.js
index 070cdd9cf8d71cfcbd5520fb4347f36cdd7fce07..aa38de0c5cf4c871dec519a98b161c0ee26ec3a5 100644
--- a/components/prism-cpp.js
+++ b/components/prism-cpp.js
@@ -1,13 +1,11 @@
 (function (Prism) {
 
 	var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
-	var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function () { return keyword.source; });
 
-	Prism.languages.cpp = Prism.languages.extend('c', {
+	var cpp = Prism.languages.cpp = Prism.languages.extend('c', {
 		'class-name': [
 			{
-				pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source
-					.replace(/<keyword>/g, function () { return keyword.source; })),
+				pattern: RegExp(`(\\b(?:class|concept|enum|struct|typename)\\s+)(?!${keyword.source})\\w+`),
 				lookbehind: true
 			},
 			// This is intended to capture the class name of method implementations like:
@@ -35,14 +33,8 @@
 		'module': {
 			// https://en.cppreference.com/w/cpp/language/modules
 			pattern: RegExp(
-				/(\b(?:import|module)\s+)/.source +
-				'(?:' +
-				// header-name
-				/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source +
-				'|' +
-				// module name or partition or both
-				/<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +
-				')'
+				`(\\b(?:import|module)\\s+)(?:"(?:\\\\(?:\\r\\n|[\\s\\S])|[^"\\\\\\r\\n])*"|<[^<>\\r\\n]*>|<mod>(?:\\s*:\\s*<mod>)?|:\\s*<mod>)`
+					.replace(/<mod>/g, `\\b(?!${keyword.source})\\w+(?:\\s*\\.\\s*\\w+)*\\b`)
 			),
 			lookbehind: true,
 			greedy: true,
@@ -67,7 +59,7 @@
 				'generic': {
 					pattern: /<[\s\S]+/,
 					alias: 'class-name',
-					inside: Prism.languages.cpp
+					inside: cpp
 				}
 			}
 		}
@@ -87,13 +79,13 @@
 			pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
 			lookbehind: true,
 			greedy: true,
-			inside: Prism.languages.extend('cpp', {})
+			inside: { ...cpp }
 		}
 	});
 
 	Prism.languages.insertBefore('inside', 'double-colon', {
 		// All untokenized words that are not namespaces should be class names
 		'class-name': /\b[a-z_]\w*\b(?!\s*::)/i
-	}, Prism.languages.cpp['base-clause']);
+	}, cpp['base-clause']);
 
 }(Prism));
diff --git a/components/prism-crystal.js b/components/prism-crystal.js
index c2c0c53a9a3b33aa9c238c39e5cb5018d6685708..7ae175b51c124229c3bc2b643a10c650c2849cba 100644
--- a/components/prism-crystal.js
+++ b/components/prism-crystal.js
@@ -1,5 +1,5 @@
 (function (Prism) {
-	Prism.languages.crystal = Prism.languages.extend('ruby', {
+	var crystal = Prism.languages.crystal = Prism.languages.extend('ruby', {
 		'keyword': [
 			/\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
 			{
@@ -30,7 +30,7 @@
 				},
 				'args': {
 					pattern: /\S(?:[\s\S]*\S)?/,
-					inside: Prism.languages.crystal
+					inside: crystal
 				},
 			}
 		},
@@ -40,7 +40,7 @@
 				'content': {
 					pattern: /^(\{.)[\s\S]+(?=.\}$)/,
 					lookbehind: true,
-					inside: Prism.languages.crystal
+					inside: crystal
 				},
 				'delimiter': {
 					pattern: /^\{[\{%]|[\}%]\}$/,
diff --git a/components/prism-csharp.js b/components/prism-csharp.js
index 9db624d63171ee7eed4e2a0ac0b17f4317098aca..a7d94f3199ea9812a066c2519e33c1df36c24525 100644
--- a/components/prism-csharp.js
+++ b/components/prism-csharp.js
@@ -10,20 +10,16 @@
 	 * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.
 	 * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source
 	 */
-	function replace(pattern, replacements) {
-		return pattern.replace(/<<(\d+)>>/g, function (m, index) {
-			return '(?:' + replacements[+index] + ')';
-		});
-	}
+	var replace = (pattern, replacements) => 
+		pattern.replace(/<<(\d+)>>/g, (m, index) => `(?:${replacements[+index]})`);
 	/**
 	 * @param {string} pattern
 	 * @param {string[]} replacements
 	 * @param {string} [flags]
 	 * @returns {RegExp}
 	 */
-	function re(pattern, replacements, flags) {
-		return RegExp(replace(pattern, replacements), flags || '');
-	}
+	var re = (pattern, replacements, flags) =>
+		RegExp(replace(pattern, replacements), flags || '');
 
 	/**
 	 * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
@@ -32,34 +28,26 @@
 	 * @param {number} depthLog2
 	 * @returns {string}
 	 */
-	function nested(pattern, depthLog2) {
+	var nested = (pattern, depthLog2) => {
 		for (var i = 0; i < depthLog2; i++) {
-			pattern = pattern.replace(/<<self>>/g, function () { return '(?:' + pattern + ')'; });
+			pattern = pattern.replace(/<<self>>/g, `(?:${pattern})`);
 		}
 		return pattern.replace(/<<self>>/g, '[^\\s\\S]');
 	}
 
+	var keywordsToPattern = words => `\\b(?:${words})\\b`;
+
 	// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
-	var keywordKinds = {
-		// keywords which represent a return or variable type
-		type: 'bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void',
-		// keywords which are used to declare a type
-		typeDeclaration: 'class enum interface record struct',
-		// contextual keywords
-		// ("var" and "dynamic" are missing because they are used like types)
-		contextual: 'add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)',
-		// all other keywords
-		other: 'abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield'
-	};
+	var typeKeyword = 'bool|byte|char|decimal|double|dynamic|float|int|long|object|sbyte|short|string|uint|ulong|ushort|var|void'
+	var typeDeclarationKeyword = 'class|enum|interface|record|struct'
+	var contextualKeyword = 'add|alias|and|ascending|async|await|by|descending|from(?=\\s*(?:\\w|$))|get|global|group|into|init(?=\\s*;)|join|let|nameof|not|notnull|on|or|orderby|partial|remove|select|set|unmanaged|value|when|where|with(?=\\s*{)'
+	var otherKeyword = 'abstract|as|base|break|case|catch|checked|const|continue|default|delegate|do|else|event|explicit|extern|finally|fixed|for|foreach|goto|if|implicit|in|internal|is|lock|namespace|new|null|operator|out|override|params|private|protected|public|readonly|ref|return|sealed|sizeof|stackalloc|static|switch|this|throw|try|typeof|unchecked|unsafe|using|virtual|volatile|while|yield'
 
 	// keywords
-	function keywordsToPattern(words) {
-		return '\\b(?:' + words.trim().replace(/ /g, '|') + ')\\b';
-	}
-	var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
-	var keywords = RegExp(keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other));
-	var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other);
-	var nonContextualKeywords = keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.other);
+	var typeDeclarationKeywords = keywordsToPattern(typeDeclarationKeyword);
+	var keywords = RegExp(keywordsToPattern(typeKeyword + '|' + typeDeclarationKeyword + '|' + contextualKeyword + '|' + otherKeyword));
+	var nonTypeKeywords = keywordsToPattern(typeDeclarationKeyword + '|' + contextualKeyword + '|' + otherKeyword);
+	var nonContextualKeywords = keywordsToPattern(typeKeyword + '|' + typeDeclarationKeyword + '|' + otherKeyword);
 
 	// types
 	var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.
@@ -85,8 +73,7 @@
 	var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
 	var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
 
-
-	Prism.languages.csharp = Prism.languages.extend('clike', {
+	var cs = Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp = Prism.languages.extend('clike', {
 		'string': [
 			{
 				pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
@@ -243,7 +230,7 @@
 					pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
 					lookbehind: true,
 					greedy: true,
-					inside: Prism.languages.csharp
+					inside: cs
 				},
 				'keyword': keywords,
 				'class-name': {
@@ -278,6 +265,38 @@
 	var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
 	var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
 
+	// string interpolation
+	var formatString = /:[^}\r\n]+/.source;
+	// multi line
+	var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
+	var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
+	// single line
+	var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
+	var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
+
+	var createInterpolationInside = (interpolation, interpolationRound) => ({
+		'interpolation': {
+			pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
+			lookbehind: true,
+			inside: {
+				'format-string': {
+					pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
+					lookbehind: true,
+					inside: {
+						'punctuation': /^:/
+					}
+				},
+				'punctuation': /^\{|\}$/,
+				'expression': {
+					pattern: /[\s\S]+/,
+					alias: 'language-csharp',
+					inside: cs
+				}
+			}
+		},
+		'string': /[\s\S]+/
+	});
+
 	Prism.languages.insertBefore('csharp', 'class-name', {
 		'attribute': {
 			// Attributes
@@ -292,7 +311,7 @@
 				},
 				'attribute-arguments': {
 					pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
-					inside: Prism.languages.csharp
+					inside: cs
 				},
 				'class-name': {
 					pattern: RegExp(identifier),
@@ -305,41 +324,6 @@
 		}
 	});
 
-
-	// string interpolation
-	var formatString = /:[^}\r\n]+/.source;
-	// multi line
-	var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
-	var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
-	// single line
-	var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
-	var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
-
-	function createInterpolationInside(interpolation, interpolationRound) {
-		return {
-			'interpolation': {
-				pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
-				lookbehind: true,
-				inside: {
-					'format-string': {
-						pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
-						lookbehind: true,
-						inside: {
-							'punctuation': /^:/
-						}
-					},
-					'punctuation': /^\{|\}$/,
-					'expression': {
-						pattern: /[\s\S]+/,
-						alias: 'language-csharp',
-						inside: Prism.languages.csharp
-					}
-				}
-			},
-			'string': /[\s\S]+/
-		};
-	}
-
 	Prism.languages.insertBefore('csharp', 'string', {
 		'interpolation-string': [
 			{
@@ -361,6 +345,4 @@
 		}
 	});
 
-	Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;
-
 }(Prism));
diff --git a/components/prism-cshtml.js b/components/prism-cshtml.js
index 4643710d3d9818afced10e875b08368e60ddeae1..49480e4e77d0e82aca1f79a48774869f0de1b1e2 100644
--- a/components/prism-cshtml.js
+++ b/components/prism-cshtml.js
@@ -6,9 +6,7 @@
 
 	var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source;
 	var stringLike =
-		/@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source +
-		'|' +
-		/'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
+		`@(?!")|"(?:[^\\r\\n\\\\"]|\\\\.)*"|@"(?:[^\\\\"]|""|\\\\[\\s\\S])*"(?!")|'(?:(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'|(?=[^\\\\](?!')))`;
 
 	/**
 	 * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
@@ -19,12 +17,12 @@
 	 */
 	function nested(pattern, depthLog2) {
 		for (var i = 0; i < depthLog2; i++) {
-			pattern = pattern.replace(/<self>/g, function () { return '(?:' + pattern + ')'; });
+			pattern = pattern.replace(/<self>/g, '(?:' + pattern + ')');
 		}
 		return pattern
 			.replace(/<self>/g, '[^\\s\\S]')
-			.replace(/<str>/g, '(?:' + stringLike + ')')
-			.replace(/<comment>/g, '(?:' + commentLike + ')');
+			.replace(/<str>/g, `(?:${stringLike})`)
+			.replace(/<comment>/g, `(?:${commentLike})`);
 	}
 
 	var round = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
@@ -32,11 +30,7 @@
 	var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
 	var angle = nested(/<(?:[^<>'"@/]|<comment>|<self>)*>/.source, 1);
 
-	var inlineCs = /@/.source +
-		/(?:await\b\s*)?/.source +
-		'(?:' + /(?!await\b)\w+\b/.source + '|' + round + ')' +
-		'(?:' + /[?!]?\.\w+\b/.source + '|' + '(?:' + angle + ')?' + round + '|' + square + ')*' +
-		/(?![?!\.(\[]|<(?!\/))/.source;
+	var inlineCs = `@(?:await\\b\\s*)?(?:(?!await\\b)\\w+\\b|${round})(?:[?!]?\\.\\w+\\b|(?:${angle})?${round}|${square})*(?![?!\\.(\\[]|<(?!\\/))`;
 
 	// Note about the above bracket patterns:
 	// They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and
@@ -50,53 +44,14 @@
 	// To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also
 	// allows invalid characters to support HTML expressions like this: <p>That's it!</p>.
 
-	var tagAttrInlineCs = /@(?![\w()])/.source + '|' + inlineCs;
-	var tagAttrValue = '(?:' +
-		/"[^"@]*"|'[^'@]*'|[^\s'"@>=]+(?=[\s>])/.source +
-		'|' +
-		'["\'][^"\'@]*(?:(?:' + tagAttrInlineCs + ')[^"\'@]*)+["\']' +
-		')';
-
-	var tagAttrs = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*<tagAttrValue>|(?=[\s/>])))+)?/.source.replace(/<tagAttrValue>/, tagAttrValue);
-	var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
-	var tagRegion =
-		/\B@?/.source +
-		'(?:' +
-		/<([a-zA-Z][\w:]*)/.source + tagAttrs + /\s*>/.source +
-		'(?:' +
-		(
-			/[^<]/.source +
-			'|' +
-			// all tags that are not the start tag
-			// eslint-disable-next-line regexp/strict
-			/<\/?(?!\1\b)/.source + tagContent +
-			'|' +
-			// nested start tag
-			nested(
-				// eslint-disable-next-line regexp/strict
-				/<\1/.source + tagAttrs + /\s*>/.source +
-				'(?:' +
-				(
-					/[^<]/.source +
-					'|' +
-					// all tags that are not the start tag
-					// eslint-disable-next-line regexp/strict
-					/<\/?(?!\1\b)/.source + tagContent +
-					'|' +
-					'<self>'
-				) +
-				')*' +
-				// eslint-disable-next-line regexp/strict
-				/<\/\1\s*>/.source,
-				2
-			)
-		) +
-		')*' +
-		// eslint-disable-next-line regexp/strict
-		/<\/\1\s*>/.source +
-		'|' +
-		/</.source + tagContent +
-		')';
+	var tagAttrInlineCs = "@(?![\\w()])|" + inlineCs;
+	var tagAttrValue = `(?:"[^"@]*"|'[^'@]*'|[^\\s'"@>=]+(?=[\\s>])|["'][^"'@]*(?:(?:${tagAttrInlineCs})[^"\'@]*)+["\'])`;
+
+	var tagAttrs = `(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*${tagAttrValue}|(?=[\\s/>])))+)?`;
+	var tagContent = `(?!\\d)[^\\s>\\/=$<%]+${tagAttrs}\\s*\\/?>`;
+	var tagRegion = `\\B@?(?:<([a-zA-Z][\\w:]*)${tagAttrs}\\s*>(?:[^<]|<\\/?(?!\\1\\b)${tagContent}|${nested(
+		`<\\1${tagAttrs}\\s*>(?:[^<]|<\\/?(?!\\1\\b)${tagContent}|<self>)*<\\/\\1\\s*>`, 2
+	)})*<\\/\\1\\s*>|<${tagContent})`
 
 	// Now for the actual language definition(s):
 	//
@@ -107,13 +62,13 @@
 	// In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each
 	// other. However, only CSHTML will be exported via `Prism.languages`.
 
-	Prism.languages.cshtml = Prism.languages.extend('markup', {});
+	var cshtml = Prism.languages.razor = Prism.languages.cshtml = Prism.languages.extend('markup', {});
 
 	var csharpWithHtml = Prism.languages.insertBefore('csharp', 'string', {
 		'html': {
 			pattern: RegExp(tagRegion),
 			greedy: true,
-			inside: Prism.languages.cshtml
+			inside: cshtml
 		},
 	}, { csharp: Prism.languages.extend('csharp', {}) });
 
@@ -133,10 +88,13 @@
 			'csharp': cs
 		}
 	};
+	var brackets = cshtml['markup-bracket'];
 
-	Prism.languages.cshtml.tag.pattern = RegExp(/<\/?/.source + tagContent);
-	Prism.languages.cshtml.tag.inside['attr-value'].pattern = RegExp(/=\s*/.source + tagAttrValue);
-	Prism.languages.insertBefore('inside', 'punctuation', { 'value': inlineValue }, Prism.languages.cshtml.tag.inside['attr-value']);
+	delete cshtml['markup-bracket'];
+	cshtml['markup-bracket'] = brackets;
+	cshtml.tag.pattern = RegExp(/<\/?/.source + tagContent);
+	cshtml.tag.inside['attr-value'].pattern = RegExp(/=\s*/.source + tagAttrValue);
+	Prism.languages.insertBefore('inside', 'punctuation', { 'value': inlineValue }, cshtml.tag.inside['attr-value']);
 
 	Prism.languages.insertBefore('cshtml', 'prolog', {
 		'razor-comment': {
@@ -147,25 +105,11 @@
 
 		'block': {
 			pattern: RegExp(
-				/(^|[^@])@/.source +
-				'(?:' +
-				[
-					// @{ ... }
-					curly,
-					// @code{ ... }
-					/(?:code|functions)\s*/.source + curly,
-					// @for (...) { ... }
-					/(?:for|foreach|lock|switch|using|while)\s*/.source + round + /\s*/.source + curly,
-					// @do { ... } while (...);
-					/do\s*/.source + curly + /\s*while\s*/.source + round + /(?:\s*;)?/.source,
-					// @try { ... } catch (...) { ... } finally { ... }
-					/try\s*/.source + curly + /\s*catch\s*/.source + round + /\s*/.source + curly + /\s*finally\s*/.source + curly,
-					// @if (...) {...} else if (...) {...} else {...}
-					/if\s*/.source + round + /\s*/.source + curly + '(?:' + /\s*else/.source + '(?:' + /\s+if\s*/.source + round + ')?' + /\s*/.source + curly + ')*',
-					// @helper Ident(params) { ... }
-					/helper\s+\w+\s*/.source + round + /\s*/.source + curly,
-				].join('|') +
-				')'
+				`(^|[^@])@(?:${curly}|(?:code|functions)\\s*${curly}|(?:for|foreach|lock|switch|using|while)\\s*${
+					round
+				}\\s*${curly}|do\\s*${curly}\\s*while\\s*${round}(?:\\s*;)?|try\\s*${curly}\\s*catch\\s*${round}\\s*${curly}\\s*finally\\s*${
+					curly
+				}|if\\s*${round}\\s*${curly}(?:\\s*else(?:\\s+if\\s*${round})?\\s*${curly})*|helper\\s+\\w+\\s*${round}\\s*${curly})`
 			),
 			lookbehind: true,
 			greedy: true,
@@ -194,6 +138,4 @@
 		}
 	});
 
-	Prism.languages.razor = Prism.languages.cshtml;
-
 }(Prism));
diff --git a/components/prism-csp.js b/components/prism-csp.js
index 8030886a147bb48534db54d0e315378502a4400c..05c4830f613b5b7006a37448ffdf39676e9e5abd 100644
--- a/components/prism-csp.js
+++ b/components/prism-csp.js
@@ -12,12 +12,11 @@
 (function (Prism) {
 
 	/**
-	 * @param {string} source
+	 * @param {RegExp} reg
 	 * @returns {RegExp}
 	 */
-	function value(source) {
-		return RegExp(/([ \t])/.source + '(?:' + source + ')' + /(?=[\s;]|$)/.source, 'i');
-	}
+	var value = reg =>
+		RegExp('([ \\t])(?:' + reg.source + ')(?=[\\s;]|$)', 'i');
 
 	Prism.languages.csp = {
 		'directive': {
@@ -26,31 +25,27 @@
 			alias: 'property'
 		},
 		'scheme': {
-			pattern: value(/[a-z][a-z0-9.+-]*:/.source),
+			pattern: value(/[a-z][a-z0-9.+-]*:/),
 			lookbehind: true
 		},
 		'none': {
-			pattern: value(/'none'/.source),
+			pattern: value(/'none'/),
 			lookbehind: true,
 			alias: 'keyword'
 		},
 		'nonce': {
-			pattern: value(/'nonce-[-+/\w=]+'/.source),
+			pattern: value(/'nonce-[-+/\w=]+'/),
 			lookbehind: true,
 			alias: 'number'
 		},
 		'hash': {
-			pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
+			pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/),
 			lookbehind: true,
 			alias: 'number'
 		},
 		'host': {
 			pattern: value(
-				/[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source +
-				'|' +
-				/\*[^\s;,']*/.source +
-				'|' +
-				/[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
+				/[a-z][a-z0-9.+-]*:\/\/[^\s;,']*|\*[^\s;,']*|[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/
 			),
 			lookbehind: true,
 			alias: 'url',
@@ -60,12 +55,12 @@
 		},
 		'keyword': [
 			{
-				pattern: value(/'unsafe-[a-z-]+'/.source),
+				pattern: value(/'unsafe-[a-z-]+'/),
 				lookbehind: true,
 				alias: 'unsafe'
 			},
 			{
-				pattern: value(/'[a-z-]+'/.source),
+				pattern: value(/'[a-z-]+'/),
 				lookbehind: true,
 				alias: 'safe'
 			},
diff --git a/components/prism-css-extras.js b/components/prism-css-extras.js
index d9a3541b2bacacf2de46bacc308385d96ca979f1..2ebf814044b3c34eaa0168587774b4c9d5f7a9b9 100644
--- a/components/prism-css-extras.js
+++ b/components/prism-css-extras.js
@@ -1,73 +1,75 @@
 (function (Prism) {
 
-	var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
-	var selectorInside;
+	var css = Prism.languages.css;
+	var unit = {
+		pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
+		lookbehind: true
+	};
+	// 123 -123 .123 -.123 12.3 -12.3
+	var number = {
+		pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
+		lookbehind: true
+	};
 
-	Prism.languages.css.selector = {
-		pattern: Prism.languages.css.selector.pattern,
-		lookbehind: true,
-		inside: selectorInside = {
-			'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
-			'pseudo-class': /:[-\w]+/,
-			'class': /\.[-\w]+/,
-			'id': /#[-\w]+/,
-			'attribute': {
-				pattern: RegExp('\\[(?:[^[\\]"\']|' + string.source + ')*\\]'),
-				greedy: true,
-				inside: {
-					'punctuation': /^\[|\]$/,
-					'case-sensitivity': {
-						pattern: /(\s)[si]$/i,
-						lookbehind: true,
-						alias: 'keyword'
-					},
-					'namespace': {
-						pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
-						lookbehind: true,
-						inside: {
-							'punctuation': /\|$/
-						}
-					},
-					'attr-name': {
-						pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
-						lookbehind: true
-					},
-					'attr-value': [
-						string,
-						{
-							pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
-							lookbehind: true
-						}
-					],
-					'operator': /[|~*^$]?=/
-				}
-			},
-			'n-th': [
-				{
-					pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
+	css.selector.inside = css['atrule'].inside['selector-function-argument'].inside = {
+		'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
+		'pseudo-class': /:[-\w]+/,
+		'class': /\.[-\w]+/,
+		'id': /#[-\w]+/,
+		'attribute': {
+			pattern: /\[(?:[^[\]"']|("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1)*\]/,
+			greedy: true,
+			inside: {
+				'punctuation': /^\[|\]$/,
+				'case-sensitivity': {
+					pattern: /(\s)[si]$/i,
+					lookbehind: true,
+					alias: 'keyword'
+				},
+				'namespace': {
+					pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
 					lookbehind: true,
 					inside: {
-						'number': /[\dn]+/,
-						'operator': /[+-]/
+						'punctuation': /\|$/
 					}
 				},
-				{
-					pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
+				'attr-name': {
+					pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
 					lookbehind: true
+				},
+				'attr-value': [
+					/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
+					{
+						pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
+						lookbehind: true
+					}
+				],
+				'operator': /[|~*^$]?=/
+			}
+		},
+		'n-th': [
+			{
+				pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
+				lookbehind: true,
+				inside: {
+					'number': /[\dn]+/,
+					'operator': /[+-]/
 				}
-			],
-			'combinator': />|\+|~|\|\|/,
-
-			// the `tag` token has been existed and removed.
-			// because we can't find a perfect tokenize to match it.
-			// if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
-
-			'punctuation': /[(),]/,
-		}
+			},
+			{
+				pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
+				lookbehind: true
+			}
+		],
+		'combinator': />|\+|~|\|\|/,
+	
+		// the `tag` token has been existed and removed.
+		// because we can't find a perfect tokenize to match it.
+		// if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
+	
+		'punctuation': /[(),]/,
 	};
 
-	Prism.languages.css['atrule'].inside['selector-function-argument'].inside = selectorInside;
-
 	Prism.languages.insertBefore('css', 'property', {
 		'variable': {
 			pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
@@ -75,16 +77,6 @@
 		}
 	});
 
-	var unit = {
-		pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
-		lookbehind: true
-	};
-	// 123 -123 .123 -.123 12.3 -12.3
-	var number = {
-		pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
-		lookbehind: true
-	};
-
 	Prism.languages.insertBefore('css', 'function', {
 		'operator': {
 			pattern: /(\s)[+\-*\/](?=\s)/,
diff --git a/components/prism-css.js b/components/prism-css.js
index 80d3463c90c434cfb0d169f1747239304cef6504..3b9f09ae80c48613eaf4fe85f8539677205af685 100644
--- a/components/prism-css.js
+++ b/components/prism-css.js
@@ -1,11 +1,12 @@
 (function (Prism) {
 
 	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
+	var stringSrc = string.source;
 
-	Prism.languages.css = {
+	var css = Prism.languages.css = {
 		'comment': /\/\*[\s\S]*?\*\//,
 		'atrule': {
-			pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
+			pattern: RegExp(`@[\\w-](?:[^;{\\s"']|\\s+(?!\\s)|${stringSrc})*?(?:;|(?=\\s*\\{))`),
 			inside: {
 				'rule': /^@[\w-]+/,
 				'selector-function-argument': {
@@ -22,19 +23,19 @@
 		},
 		'url': {
 			// https://drafts.csswg.org/css-values-3/#urls
-			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
+			pattern: RegExp(`\\burl\\((?:${stringSrc}|(?:[^\\\\\\r\\n()"']|\\\\[\\s\\S])*)\\)`, 'i'),
 			greedy: true,
 			inside: {
 				'function': /^url/i,
 				'punctuation': /^\(|\)$/,
 				'string': {
-					pattern: RegExp('^' + string.source + '$'),
+					pattern: RegExp('^' + stringSrc + '$'),
 					alias: 'url'
 				}
 			}
 		},
 		'selector': {
-			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
+			pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|${stringSrc})*(?=\\s*\\{)`),
 			lookbehind: true
 		},
 		'string': {
@@ -53,12 +54,6 @@
 		'punctuation': /[(){};:,]/
 	};
 
-	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
-
-	var markup = Prism.languages.markup;
-	if (markup) {
-		markup.tag.addInlined('style', 'css');
-		markup.tag.addAttribute('style', 'css');
-	}
+	css['atrule'].inside.rest = css;
 
 }(Prism));
diff --git a/components/prism-cue.js b/components/prism-cue.js
index 9caf0662eb4685037d6f3416bfb4afa34e2a0ba0..8b00aae3c1328ad073c79e47e4c0c8742be103d2 100644
--- a/components/prism-cue.js
+++ b/components/prism-cue.js
@@ -5,16 +5,14 @@
 	// eslint-disable-next-line regexp/strict
 	var stringEscape = /\\(?:(?!\2)|\2(?:[^()\r\n]|\([^()]*\)))/.source;
 	// eslint-disable-next-line regexp/strict
-	var stringTypes = /"""(?:[^\\"]|"(?!""\2)|<esc>)*"""/.source +
-		// eslint-disable-next-line regexp/strict
-		'|' + /'''(?:[^\\']|'(?!''\2)|<esc>)*'''/.source +
-		// eslint-disable-next-line regexp/strict
-		'|' + /"(?:[^\\\r\n"]|"(?!\2)|<esc>)*"/.source +
-		// eslint-disable-next-line regexp/strict
-		'|' + /'(?:[^\\\r\n']|'(?!\2)|<esc>)*'/.source;
+	var stringTypes = `"""(?:[^\\\\"]|"(?!""\\2)|<esc>)*"""|'''(?:[^\\\\']|'(?!''\\2)|<esc>)*'''|"(?:[^\\\\\\r\\n"]|"(?!\\2)|<esc>)*"|'(?:[^\\\\\\r\\n']|'(?!\\2)|<esc>)*'`;
 	var stringLiteral = '(?:' + stringTypes.replace(/<esc>/g, stringEscape) + ')';
 
-	Prism.languages.cue = {
+	var expression = {
+		pattern: /[\s\S]+/
+	}
+
+	expression.inside = Prism.languages.cue = {
 		'comment': {
 			pattern: /\/\/.*/,
 			greedy: true
@@ -38,10 +36,7 @@
 					greedy: true,
 					inside: {
 						'punctuation': /^\\#*\(|\)$/,
-						'expression': {
-							pattern: /[\s\S]+/,
-							inside: null
-						}
+						'expression': expression
 					}
 				},
 				'string': /[\s\S]+/
@@ -79,6 +74,4 @@
 		'punctuation': /[()[\]{},.:]/
 	};
 
-	Prism.languages.cue['string-literal'].inside.interpolation.inside.expression.inside = Prism.languages.cue;
-
 }(Prism));
diff --git a/components/prism-d.js b/components/prism-d.js
index 981b2f3d2cec5e48aec47513005c87c26d4b811a..d0441809c68a0e884b6f8c134936e5bf9544d658 100644
--- a/components/prism-d.js
+++ b/components/prism-d.js
@@ -6,40 +6,14 @@ Prism.languages.d = Prism.languages.extend('clike', {
 			greedy: true
 		},
 		{
-			pattern: RegExp(/(^|[^\\])/.source + '(?:' + [
-				// /+ comment +/
-				// Allow one level of nesting
-				/\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
-				// // comment
-				/\/\/.*/.source,
-				// /* comment */
-				/\/\*[\s\S]*?\*\//.source
-			].join('|') + ')'),
+			pattern: /(^|[^\\])(?:\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\/|\/\/.*|\/\*[\s\S]*?\*\/)/g,
 			lookbehind: true,
 			greedy: true
 		}
 	],
 	'string': [
 		{
-			pattern: RegExp([
-				// r"", x""
-				/\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
-
-				// q"[]", q"()", q"<>", q"{}"
-				/\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
-
-				// q"IDENT
-				// ...
-				// IDENT"
-				/\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
-
-				// q"//", q"||", etc.
-				// eslint-disable-next-line regexp/strict
-				/\bq"(.)[\s\S]*?\2"/.source,
-
-				// eslint-disable-next-line regexp/strict
-				/(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
-			].join('|'), 'm'),
+			pattern: /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?|\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"|\bq"((?!\d)\w+)$[\s\S]*?^\1"|\bq"(.)[\s\S]*?\2"|(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/gm,
 			greedy: true
 		},
 		{
diff --git a/components/prism-dhall.js b/components/prism-dhall.js
index ee69839b87bb66a1f6943c5915f7457243b8b2e3..60966d3f8e5abe51660301cd295dab32a532ba1f 100644
--- a/components/prism-dhall.js
+++ b/components/prism-dhall.js
@@ -1,7 +1,14 @@
 // ABNF grammar:
 // https://github.com/dhall-lang/dhall-lang/blob/master/standard/dhall.abnf
 
-Prism.languages.dhall = {
+var expression = {
+	pattern: /(^\$\{)[\s\S]+(?=\}$)/,
+	lookbehind: true,
+	alias: 'language-dhall',
+	inside: null // see blow
+}
+
+expression.inside = Prism.languages.dhall = {
 	// Multi-line comments can be nested. E.g. {- foo {- bar -} -}
 	// The multi-line pattern is essentially this:
 	//   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
@@ -13,12 +20,7 @@ Prism.languages.dhall = {
 			'interpolation': {
 				pattern: /\$\{[^{}]*\}/,
 				inside: {
-					'expression': {
-						pattern: /(^\$\{)[\s\S]+(?=\}$)/,
-						lookbehind: true,
-						alias: 'language-dhall',
-						inside: null // see blow
-					},
+					'expression': expression,
 					'punctuation': /\$\{|\}/
 				}
 			}
@@ -65,5 +67,3 @@ Prism.languages.dhall = {
 	// we'll just assume that every capital word left is a type name
 	'class-name': /\b[A-Z]\w*\b/
 };
-
-Prism.languages.dhall.string.inside.interpolation.inside.expression.inside = Prism.languages.dhall;
diff --git a/components/prism-diff.js b/components/prism-diff.js
index eadf69758cc83b44ac53766c72d24cdab70d6d88..5957e781492f0507ffad3d413c4f84d55baec328 100644
--- a/components/prism-diff.js
+++ b/components/prism-diff.js
@@ -28,14 +28,14 @@
 	};
 
 	// add a token for each prefix
-	Object.keys(PREFIXES).forEach(function (name) {
+	Object.keys(PREFIXES).forEach(name => {
 		var prefix = PREFIXES[name];
 
 		var alias = [];
 		if (!/^\w+$/.test(name)) { // "deleted-sign" -> "deleted"
 			alias.push(/\w+/.exec(name)[0]);
 		}
-		if (name === 'diff') {
+		if (name == 'diff') {
 			alias.push('bold');
 		}
 
diff --git a/components/prism-django.js b/components/prism-django.js
index 98501b48b809b82631c027f73d79b0545d6ff6f4..b131db2505e4498b39f2080a8b55877435127824 100644
--- a/components/prism-django.js
+++ b/components/prism-django.js
@@ -41,19 +41,19 @@
 	var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
 	var markupTemplating = Prism.languages['markup-templating'];
 
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		markupTemplating.buildPlaceholders(env, 'django', pattern);
 	});
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		markupTemplating.tokenizePlaceholders(env, 'django');
 	});
 
 	// Add an Jinja2 alias
 	Prism.languages.jinja2 = Prism.languages.django;
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		markupTemplating.buildPlaceholders(env, 'jinja2', pattern);
 	});
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		markupTemplating.tokenizePlaceholders(env, 'jinja2');
 	});
 
diff --git a/components/prism-docker.js b/components/prism-docker.js
index 953f3ae03e2e6022100a50175f4208d2261643c9..784245e10cff188aabe04f0562150430bcc25b16 100644
--- a/components/prism-docker.js
+++ b/components/prism-docker.js
@@ -6,10 +6,10 @@
 	var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source;
 	// At least one space, comment, or line break
 	var space = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source
-		.replace(/<SP_BS>/g, function () { return spaceAfterBackSlash; });
+		.replace(/<SP_BS>/g, spaceAfterBackSlash);
 
 	var string = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source;
-	var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(/<STR>/g, function () { return string; });
+	var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(/<STR>/g, string);
 
 	var stringRule = {
 		pattern: RegExp(string),
@@ -26,15 +26,12 @@
 	 * @param {string} flags
 	 * @returns {RegExp}
 	 */
-	function re(source, flags) {
-		source = source
-			.replace(/<OPT>/g, function () { return option; })
-			.replace(/<SP>/g, function () { return space; });
+	var re = (source, flags) => 
+		RegExp(source
+			.replace(/<OPT>/g, option)
+			.replace(/<SP>/g, space), flags);
 
-		return RegExp(source, flags);
-	}
-
-	Prism.languages.docker = {
+	Prism.languages.dockerfile = Prism.languages.docker = {
 		'instruction': {
 			pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
 			lookbehind: true,
@@ -93,6 +90,4 @@
 		'comment': commentRule
 	};
 
-	Prism.languages.dockerfile = Prism.languages.docker;
-
 }(Prism));
diff --git a/components/prism-dot.js b/components/prism-dot.js
index e93b5bff1b51f491efb5504938ae2ec5ab8df4fa..ceb967923de323051f8b78afc4eadf53a767dea4 100644
--- a/components/prism-dot.js
+++ b/components/prism-dot.js
@@ -2,23 +2,14 @@
 
 (function (Prism) {
 
-	var ID = '(?:' + [
-		// an identifier
-		/[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
-		// a number
-		/-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
-		// a double-quoted string
-		/"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
-		// HTML-like string
-		/<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
-	].join('|') + ')';
+	var ID = `(?:[a-zA-Z_\\x80-\\uFFFF][\\w\\x80-\\uFFFF]*|-?(?:\\.\\d+|\\d+(?:\\.\\d*)?)|"[^"\\\\]*(?:\\\\[\\s\\S][^"\\\\]*)*"|<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>)`;
 
 	var IDInside = {
 		'markup': {
 			pattern: /(^<)[\s\S]+(?=>$)/,
 			lookbehind: true,
 			alias: ['language-markup', 'language-html', 'language-xml'],
-			inside: Prism.languages.markup
+			inside: 'markup'
 		}
 	};
 
@@ -27,11 +18,10 @@
 	 * @param {string} flags
 	 * @returns {RegExp}
 	 */
-	function withID(source, flags) {
-		return RegExp(source.replace(/<ID>/g, function () { return ID; }), flags);
-	}
+	var withID = (source, flags) =>
+		RegExp(source.replace(/<ID>/g, ID), flags);
 
-	Prism.languages.dot = {
+	Prism.languages.gv = Prism.languages.dot = {
 		'comment': {
 			pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
 			greedy: true
@@ -71,6 +61,4 @@
 		'punctuation': /[\[\]{};,]/
 	};
 
-	Prism.languages.gv = Prism.languages.dot;
-
 }(Prism));
diff --git a/components/prism-ejs.js b/components/prism-ejs.js
index cd590b46efa523a559718d400c9fe52d2e449270..b2a66ec994dc986d66dfb679cf92f2e0eaf949c3 100644
--- a/components/prism-ejs.js
+++ b/components/prism-ejs.js
@@ -1,6 +1,6 @@
 (function (Prism) {
 
-	Prism.languages.ejs = {
+	Prism.languages.eta = Prism.languages.ejs = {
 		'delimiter': {
 			pattern: /^<%[-_=]?|[-_]?%>$/,
 			alias: 'punctuation'
@@ -8,19 +8,17 @@
 		'comment': /^#[\s\S]*/,
 		'language-javascript': {
 			pattern: /[\s\S]+/,
-			inside: Prism.languages.javascript
+			inside: 'js'
 		}
 	};
 
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
 		Prism.languages['markup-templating'].buildPlaceholders(env, 'ejs', ejsPattern);
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'ejs');
 	});
 
-	Prism.languages.eta = Prism.languages.ejs;
-
 }(Prism));
diff --git a/components/prism-elixir.js b/components/prism-elixir.js
index 23fafc0514b827400d3ac153e5754ef8de27e3c8..93c529460eb7fe7fe23e9a3e7a20f504a2b7a1ee 100644
--- a/components/prism-elixir.js
+++ b/components/prism-elixir.js
@@ -1,4 +1,4 @@
-Prism.languages.elixir = {
+var elixir = Prism.languages.elixir = {
 	'doc': {
 		pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
 		inside: {
@@ -19,25 +19,16 @@ Prism.languages.elixir = {
 		{
 			// ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
 			pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
-			greedy: true,
-			inside: {
-				// See interpolation below
-			}
+			greedy: true
 		},
 		{
 			pattern: /("""|''')[\s\S]*?\1/,
-			greedy: true,
-			inside: {
-				// See interpolation below
-			}
+			greedy: true
 		},
 		{
 			// Multi-line strings are allowed
 			pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
-			greedy: true,
-			inside: {
-				// See interpolation below
-			}
+			greedy: true
 		}
 	],
 	'atom': {
@@ -82,7 +73,7 @@ Prism.languages.elixir = {
 	'punctuation': /<<|>>|[.,%\[\]{}()]/
 };
 
-Prism.languages.elixir.string.forEach(function (o) {
+elixir.string.forEach(o => {
 	o.inside = {
 		'interpolation': {
 			pattern: /#\{[^}]+\}/,
@@ -91,7 +82,7 @@ Prism.languages.elixir.string.forEach(function (o) {
 					pattern: /^#\{|\}$/,
 					alias: 'punctuation'
 				},
-				rest: Prism.languages.elixir
+				rest: elixir
 			}
 		}
 	};
diff --git a/components/prism-erb.js b/components/prism-erb.js
index 21dd7c228db4f299b7d4a16d3e2991abeaded908..b1081417c8134981db5b7b331c174615215392e3 100644
--- a/components/prism-erb.js
+++ b/components/prism-erb.js
@@ -9,16 +9,16 @@
 		'ruby': {
 			pattern: /\s*\S[\s\S]*/,
 			alias: 'language-ruby',
-			inside: Prism.languages.ruby
+			inside: 'ruby'
 		}
 	};
 
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		var erbPattern = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
 		Prism.languages['markup-templating'].buildPlaceholders(env, 'erb', erbPattern);
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'erb');
 	});
 
diff --git a/components/prism-etlua.js b/components/prism-etlua.js
index b8610c8eb99e2bb05459907546e0a1cd6c25fef4..a4501c991de5365a99aa210b38fa4afeeafc9852 100644
--- a/components/prism-etlua.js
+++ b/components/prism-etlua.js
@@ -7,16 +7,16 @@
 		},
 		'language-lua': {
 			pattern: /[\s\S]+/,
-			inside: Prism.languages.lua
+			inside: 'lua'
 		}
 	};
 
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		var pattern = /<%[\s\S]+?%>/g;
 		Prism.languages['markup-templating'].buildPlaceholders(env, 'etlua', pattern);
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'etlua');
 	});
 
diff --git a/components/prism-factor.js b/components/prism-factor.js
index 8db7bd3a9b73e404b3b5a6bc29b4a6b94a83436d..af7c73459ccf01000155a3161a7c7b1b6cc7937a 100644
--- a/components/prism-factor.js
+++ b/components/prism-factor.js
@@ -345,15 +345,13 @@
 		}
 	};
 
-	var escape = function (str) {
-		return (str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1');
-	};
+	var escape = str =>
+		(str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1');
 
-	var arrToWordsRegExp = function (arr) {
-		return new RegExp(
+	var arrToWordsRegExp = arr =>
+		RegExp(
 			'(^|\\s)(?:' + arr.map(escape).join('|') + ')(?=\\s|$)'
 		);
-	};
 
 	var builtins = {
 		'kernel-builtin': [
@@ -374,7 +372,7 @@
 		// that's all for now
 	};
 
-	Object.keys(builtins).forEach(function (k) {
+	Object.keys(builtins).forEach(k => {
 		factor[k].pattern = arrToWordsRegExp(builtins[k]);
 	});
 
diff --git a/components/prism-false.js b/components/prism-false.js
index ad1e4943b157fd3920e5f31c57e49ced475f7cf6..fc03d6a298892b43bd1a933846e2fc911d24b2a8 100644
--- a/components/prism-false.js
+++ b/components/prism-false.js
@@ -5,9 +5,7 @@
 	 * @see {@link https://github.com/PrismJS/prism/issues/2801#issue-829717504}
 	 */
 	Prism.languages['false'] = {
-		'comment': {
-			pattern: /\{[^}]*\}/
-		},
+		'comment': /\{[^}]*\}/,
 		'string': {
 			pattern: /"[^"]*"/,
 			greedy: true
diff --git a/components/prism-flow.js b/components/prism-flow.js
index 32485817754c65985ddc690d36407a633f89b2a5..ac4801d01f3fa5b05d028215b5fee092b58ab34d 100644
--- a/components/prism-flow.js
+++ b/components/prism-flow.js
@@ -1,5 +1,5 @@
 (function (Prism) {
-	Prism.languages.flow = Prism.languages.extend('javascript', {});
+	var flow = Prism.languages.flow = Prism.languages.extend('js', {});
 
 	Prism.languages.insertBefore('flow', 'keyword', {
 		'type': [
@@ -9,8 +9,8 @@
 			}
 		]
 	});
-	Prism.languages.flow['function-variable'].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
-	delete Prism.languages.flow['parameter'];
+	flow['function-variable'].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
+	delete flow['parameter'];
 
 	Prism.languages.insertBefore('flow', 'operator', {
 		'flow-punctuation': {
@@ -19,10 +19,10 @@
 		}
 	});
 
-	if (!Array.isArray(Prism.languages.flow.keyword)) {
-		Prism.languages.flow.keyword = [Prism.languages.flow.keyword];
+	if (!Array.isArray(flow.keyword)) {
+		flow.keyword = [flow.keyword];
 	}
-	Prism.languages.flow.keyword.unshift(
+	flow.keyword.unshift(
 		{
 			pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
 			lookbehind: true
diff --git a/components/prism-ftl.js b/components/prism-ftl.js
index bc1984880ad7aa3b4485719c49be8fd3b0377e2f..a0d0091355db02d3083bbc9b83932b83e82b47bb 100644
--- a/components/prism-ftl.js
+++ b/components/prism-ftl.js
@@ -5,7 +5,7 @@
 	// FTL expression with 4 levels of nesting supported
 	var FTL_EXPR = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source;
 	for (var i = 0; i < 2; i++) {
-		FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function () { return FTL_EXPR; });
+		FTL_EXPR = FTL_EXPR.replace(/<expr>/g, FTL_EXPR);
 	}
 	FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\s\S]/.source);
 
@@ -18,18 +18,17 @@
 				greedy: true
 			},
 			{
-				pattern: RegExp(/("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(/<expr>/g, function () { return FTL_EXPR; })),
+				pattern: RegExp(/("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(/<expr>/g, FTL_EXPR)),
 				greedy: true,
 				inside: {
 					'interpolation': {
-						pattern: RegExp(/((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(/<expr>/g, function () { return FTL_EXPR; })),
+						pattern: RegExp(/((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(/<expr>/g, FTL_EXPR)),
 						lookbehind: true,
 						inside: {
 							'interpolation-punctuation': {
 								pattern: /^\$\{|\}$/,
 								alias: 'punctuation'
-							},
-							rest: null
+							}
 						}
 					}
 				}
@@ -85,13 +84,13 @@
 		}
 	};
 
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		// eslint-disable-next-line regexp/no-useless-lazy
-		var pattern = RegExp(/<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(/<expr>/g, function () { return FTL_EXPR; }), 'gi');
+		var pattern = RegExp(/<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(/<expr>/g, FTL_EXPR), 'gi');
 		Prism.languages['markup-templating'].buildPlaceholders(env, 'ftl', pattern);
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'ftl');
 	});
 
diff --git a/components/prism-gap.js b/components/prism-gap.js
index be53a6eca77c311ebb9e8c553e0928b3c0c16161..4562ca215c67814721e3ca1be3b1cbbe6d9b1036 100644
--- a/components/prism-gap.js
+++ b/components/prism-gap.js
@@ -1,16 +1,17 @@
 // https://www.gap-system.org/Manuals/doc/ref/chap4.html
 // https://www.gap-system.org/Manuals/doc/ref/chap27.html
 
-Prism.languages.gap = {
+var gap = {
+	pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
+	lookbehind: true
+};
+
+gap.inside = Prism.languages.gap = {
 	'shell': {
 		pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
 		greedy: true,
 		inside: {
-			'gap': {
-				pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
-				lookbehind: true,
-				inside: null // see below
-			},
+			'gap': gap,
 			'punctuation': /^gap>/
 		}
 	},
@@ -50,5 +51,3 @@ Prism.languages.gap = {
 	'operator': /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
 	'punctuation': /[()[\]{},;.:]/
 };
-
-Prism.languages.gap.shell.inside.gap.inside = Prism.languages.gap;
diff --git a/components/prism-gn.js b/components/prism-gn.js
index 0fcb05ac5ff83fb86eb46d1cf157363c5a4b16f4..30d4623cfe53c7c03679e5b3f484d3e8c1b01bc7 100644
--- a/components/prism-gn.js
+++ b/components/prism-gn.js
@@ -1,6 +1,10 @@
 // https://gn.googlesource.com/gn/+/refs/heads/main/docs/reference.md#grammar
 
-Prism.languages.gn = {
+var expression = {
+	pattern: /[\s\S]+/
+};
+
+expression.inside = Prism.languages.gni = Prism.languages.gn = {
 	'comment': {
 		pattern: /#.*/,
 		greedy: true
@@ -20,10 +24,7 @@ Prism.languages.gn = {
 						pattern: /^\$\{|\}$/,
 						alias: 'punctuation'
 					},
-					'expression': {
-						pattern: /[\s\S]+/,
-						inside: null // see below
-					}
+					'expression': expression
 				}
 			},
 			'string': /[\s\S]+/
@@ -45,7 +46,3 @@ Prism.languages.gn = {
 	'operator': /[-+!=<>]=?|&&|\|\|/,
 	'punctuation': /[(){}[\],.]/
 };
-
-Prism.languages.gn['string-literal'].inside['interpolation'].inside['expression'].inside = Prism.languages.gn;
-
-Prism.languages.gni = Prism.languages.gn;
diff --git a/components/prism-gradle.js b/components/prism-gradle.js
index 96020f64b2692e44ed577fee0a9f0ca69dcbe5a8..c3e6b5efeb882628f66d62a1d6fc6cb6481c1093 100644
--- a/components/prism-gradle.js
+++ b/components/prism-gradle.js
@@ -1,4 +1,8 @@
 (function (Prism) {
+	var expression = {
+		pattern: /[\s\S]+/
+	}
+
 	var interpolation = {
 		pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
 		lookbehind: true,
@@ -7,14 +11,11 @@
 				pattern: /^\$\{?|\}$/,
 				alias: 'punctuation',
 			},
-			'expression': {
-				pattern: /[\s\S]+/,
-				inside: null,
-			},
+			'expression': expression,
 		},
 	};
 
-	Prism.languages.gradle = Prism.languages.extend('clike', {
+	expression.inside = Prism.languages.gradle = Prism.languages.extend('clike', {
 		'string': {
 			pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
 			greedy: true,
@@ -59,5 +60,4 @@
 		},
 	});
 
-	interpolation.inside.expression.inside = Prism.languages.gradle;
 }(Prism));
diff --git a/components/prism-graphql.js b/components/prism-graphql.js
index 988f4e606ade5ef623173153f58f02e9489e393f..e8f54753ea40438fe6bde4dddf137d681f8710a4 100644
--- a/components/prism-graphql.js
+++ b/components/prism-graphql.js
@@ -8,7 +8,7 @@ Prism.languages.graphql = {
 			'language-markdown': {
 				pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
 				lookbehind: true,
-				inside: Prism.languages.markdown
+				inside: 'md'
 			}
 		}
 	},
@@ -60,8 +60,8 @@ Prism.languages.graphql = {
 	'property': /\w+/
 };
 
-Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
-	if (env.language !== 'graphql') {
+Prism.hooks.add('after-tokenize', env => {
+	if (env.language != 'graphql') {
 		return;
 	}
 
@@ -71,9 +71,9 @@ Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
 	 * @typedef {InstanceType<import("./prism-core")["Token"]>} Token
 	 * @type {Token[]}
 	 */
-	var validTokens = env.tokens.filter(function (token) {
-		return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';
-	});
+	var validTokens = env.tokens.filter(token =>
+		typeof token != 'string' && token.type != 'comment' && token.type != 'scalar'
+	);
 
 	var currentIndex = 0;
 
@@ -83,9 +83,8 @@ Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
 	 * @param {number} offset
 	 * @returns {Token | undefined}
 	 */
-	function getToken(offset) {
-		return validTokens[currentIndex + offset];
-	}
+	var getToken = offset =>
+		validTokens[currentIndex + offset];
 
 	/**
 	 * Returns whether the token relative to the current index has the given type.
@@ -94,7 +93,7 @@ Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
 	 * @param {number} [offset=0]
 	 * @returns {boolean}
 	 */
-	function isTokenType(types, offset) {
+	var isTokenType = (types, offset) => {
 		offset = offset || 0;
 		for (var i = 0; i < types.length; i++) {
 			var token = getToken(i + offset);
@@ -116,14 +115,14 @@ Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
 	 * @param {RegExp} close
 	 * @returns {number}
 	 */
-	function findClosingBracket(open, close) {
+	var findClosingBracket = (open, close) => {
 		var stackHeight = 1;
 
 		for (var i = currentIndex; i < validTokens.length; i++) {
 			var token = validTokens[i];
 			var content = token.content;
 
-			if (token.type === 'punctuation' && typeof content === 'string') {
+			if (token.type == 'punctuation' && typeof content == 'string') {
 				if (open.test(content)) {
 					stackHeight++;
 				} else if (close.test(content)) {
@@ -146,7 +145,7 @@ Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
 	 * @param {string} alias
 	 * @returns {void}
 	 */
-	function addAlias(token, alias) {
+	var addAlias = (token, alias) => {
 		var aliases = token.alias;
 		if (!aliases) {
 			token.alias = aliases = [];
@@ -160,24 +159,24 @@ Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
 		var startToken = validTokens[currentIndex++];
 
 		// add special aliases for mutation tokens
-		if (startToken.type === 'keyword' && startToken.content === 'mutation') {
+		if (startToken.type === 'keyword' && startToken.content == 'mutation') {
 			// any array of the names of all input variables (if any)
 			var inputVariables = [];
 
-			if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {
+			if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content == '(') {
 				// definition
 
 				currentIndex += 2; // skip 'definition-mutation' and 'punctuation'
 
 				var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
-				if (definitionEnd === -1) {
+				if (definitionEnd == -1) {
 					continue;
 				}
 
 				// find all input variables
 				for (; currentIndex < definitionEnd; currentIndex++) {
 					var t = getToken(0);
-					if (t.type === 'variable') {
+					if (t.type == 'variable') {
 						addAlias(t, 'variable-input');
 						inputVariables.push(t.content);
 					}
@@ -186,21 +185,21 @@ Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
 				currentIndex = definitionEnd + 1;
 			}
 
-			if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {
+			if (isTokenType(['punctuation', 'property-query']) && getToken(0).content == '{') {
 				currentIndex++; // skip opening bracket
 
 				addAlias(getToken(0), 'property-mutation');
 
 				if (inputVariables.length > 0) {
 					var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
-					if (mutationEnd === -1) {
+					if (mutationEnd == -1) {
 						continue;
 					}
 
 					// give references to input variables a special alias
 					for (var i = currentIndex; i < mutationEnd; i++) {
 						var varToken = validTokens[i];
-						if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {
+						if (varToken.type == 'variable' && inputVariables.indexOf(varToken.content) >= 0) {
 							addAlias(varToken, 'variable-input');
 						}
 					}
diff --git a/components/prism-groovy.js b/components/prism-groovy.js
index 820152389943f1549de0acec8c7491abd2cfb739..89bd71a38e8058d8c3148173b8a61a82e506416d 100644
--- a/components/prism-groovy.js
+++ b/components/prism-groovy.js
@@ -1,5 +1,9 @@
 (function (Prism) {
 
+	var expression = {
+		pattern: /[\s\S]+/
+	}
+
 	var interpolation = {
 		pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
 		lookbehind: true,
@@ -8,14 +12,11 @@
 				pattern: /^\$\{?|\}$/,
 				alias: 'punctuation'
 			},
-			'expression': {
-				pattern: /[\s\S]+/,
-				inside: null // see below
-			}
+			'expression': expression
 		}
 	};
 
-	Prism.languages.groovy = Prism.languages.extend('clike', {
+	expression.inside = Prism.languages.groovy = Prism.languages.extend('clike', {
 		'string': {
 			// https://groovy-lang.org/syntax.html#_dollar_slashy_string
 			pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
@@ -60,6 +61,4 @@
 		}
 	});
 
-	interpolation.inside.expression.inside = Prism.languages.groovy;
-
 }(Prism));
diff --git a/components/prism-haml.js b/components/prism-haml.js
index ac7f37be603b654d14d8e275ec1210529b2be441..13dbfded3fd3564944c0005ae895d1b8fdd0a098 100644
--- a/components/prism-haml.js
+++ b/components/prism-haml.js
@@ -20,12 +20,12 @@
 			{
 				pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
 				lookbehind: true,
-				inside: Prism.languages.ruby
+				inside: 'ruby'
 			},
 			{
 				pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
 				lookbehind: true,
-				inside: Prism.languages.ruby
+				inside: 'ruby'
 			}
 		],
 
@@ -44,7 +44,7 @@
 		'markup': {
 			pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
 			lookbehind: true,
-			inside: Prism.languages.markup
+			inside: 'markup'
 		},
 		'doctype': {
 			pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
@@ -61,7 +61,7 @@
 						// Allows for one nested group of braces
 						pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
 						lookbehind: true,
-						inside: Prism.languages.ruby
+						inside: 'ruby'
 					},
 					{
 						pattern: /\([^)]+\)/,
@@ -76,7 +76,7 @@
 					},
 					{
 						pattern: /\[[^\]]+\]/,
-						inside: Prism.languages.ruby
+						inside: 'ruby'
 					}
 				],
 				'punctuation': /[<>]/
@@ -85,7 +85,7 @@
 		'code': {
 			pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
 			lookbehind: true,
-			inside: Prism.languages.ruby
+			inside: 'ruby'
 		},
 		// Interpolations in plain text
 		'interpolation': {
@@ -97,7 +97,7 @@
 				},
 				'ruby': {
 					pattern: /[\s\S]+/,
-					inside: Prism.languages.ruby
+					inside: 'ruby'
 				}
 			}
 		},
@@ -108,11 +108,12 @@
 	};
 
 	var filter_pattern = '((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+';
+	var allFilters = {};
 
 	// Non exhaustive list of available filters and associated languages
-	var filters = [
+	[
 		'css',
-		{ filter: 'coffee', language: 'coffeescript' },
+		'coffee',
 		'erb',
 		'javascript',
 		'less',
@@ -120,30 +121,25 @@
 		'ruby',
 		'scss',
 		'textile'
-	];
-	var all_filters = {};
-	for (var i = 0, l = filters.length; i < l; i++) {
-		var filter = filters[i];
-		filter = typeof filter === 'string' ? { filter: filter, language: filter } : filter;
-		if (Prism.languages[filter.language]) {
-			all_filters['filter-' + filter.filter] = {
-				pattern: RegExp(filter_pattern.replace('{{filter_name}}', function () { return filter.filter; })),
-				lookbehind: true,
-				inside: {
-					'filter-name': {
-						pattern: /^:[\w-]+/,
-						alias: 'symbol'
-					},
-					'text': {
-						pattern: /[\s\S]+/,
-						alias: [filter.language, 'language-' + filter.language],
-						inside: Prism.languages[filter.language]
-					}
+	].forEach(filter => {
+		var language = filter == 'coffee' ? 'coffeescript' : filter;
+		allFilters['filter-' + filter] = {
+			pattern: RegExp(filter_pattern.replace('{{filter_name}}', filter)),
+			lookbehind: true,
+			inside: {
+				'filter-name': {
+					pattern: /^:[\w-]+/,
+					alias: 'symbol'
+				},
+				'text': {
+					pattern: /[\s\S]+/,
+					alias: [language, 'language-' + language],
+					inside: language
 				}
-			};
-		}
-	}
+			}
+		};
+	})
 
-	Prism.languages.insertBefore('haml', 'filter', all_filters);
+	Prism.languages.insertBefore('haml', 'filter', allFilters);
 
 }(Prism));
diff --git a/components/prism-handlebars.js b/components/prism-handlebars.js
index 5cc796a1910a109b15cfb56436f8a0ff5fbf74f2..aea79157cd8738c91658c95fa0419c2ae3273da7 100644
--- a/components/prism-handlebars.js
+++ b/components/prism-handlebars.js
@@ -25,12 +25,12 @@
 		'variable': /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
 	};
 
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
 		Prism.languages['markup-templating'].buildPlaceholders(env, 'handlebars', handlebarsPattern);
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'handlebars');
 	});
 
diff --git a/components/prism-haxe.js b/components/prism-haxe.js
index fffef0228d8f727a58d827f3480193bc8e1579fb..efddaf6490443008863d2f53c3713880321ed378 100644
--- a/components/prism-haxe.js
+++ b/components/prism-haxe.js
@@ -1,4 +1,4 @@
-Prism.languages.haxe = Prism.languages.extend('clike', {
+var haxe = Prism.languages.haxe = Prism.languages.extend('clike', {
 	'string': {
 		// Strings can be multi-line
 		pattern: /"(?:[^"\\]|\\[\s\S])*"/,
@@ -36,7 +36,7 @@ Prism.languages.insertBefore('haxe', 'string', {
 					},
 					'expression': {
 						pattern: /[\s\S]+/,
-						inside: Prism.languages.haxe
+						inside: haxe
 					},
 				}
 			},
@@ -55,7 +55,7 @@ Prism.languages.insertBefore('haxe', 'class-name', {
 				pattern: /^(~\/)[\s\S]+(?=\/$)/,
 				lookbehind: true,
 				alias: 'language-regex',
-				inside: Prism.languages.regex
+				inside: 'regex'
 			},
 			'regex-delimiter': /^~\/|\/$/,
 		}
diff --git a/components/prism-http.js b/components/prism-http.js
index d14eb379a424d8452a2914139877f06935095be1..d48d42d59db448bec25dc446416d36f138395917 100644
--- a/components/prism-http.js
+++ b/components/prism-http.js
@@ -1,12 +1,10 @@
 (function (Prism) {
 
 	/**
-	 * @param {string} name
+	 * @param {RegExp} name
 	 * @returns {RegExp}
 	 */
-	function headerValueOf(name) {
-		return RegExp('(^(?:' + name + '):[ \t]*(?![ \t]))[^]+', 'i');
-	}
+	var headerValueOf = name => RegExp('(^(?:' + name.source + '):[ \t]*(?![ \t]))[^]+', 'i');
 
 	Prism.languages.http = {
 		'request-line': {
@@ -22,7 +20,7 @@
 					pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
 					lookbehind: true,
 					alias: 'url',
-					inside: Prism.languages.uri
+					inside: 'uri'
 				},
 				// HTTP Version
 				'http-version': {
@@ -59,25 +57,25 @@
 			inside: {
 				'header-value': [
 					{
-						pattern: headerValueOf(/Content-Security-Policy/.source),
+						pattern: headerValueOf(/Content-Security-Policy/),
 						lookbehind: true,
 						alias: ['csp', 'languages-csp'],
-						inside: Prism.languages.csp
+						inside: 'csp'
 					},
 					{
-						pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
+						pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/),
 						lookbehind: true,
 						alias: ['hpkp', 'languages-hpkp'],
-						inside: Prism.languages.hpkp
+						inside: 'hpkp'
 					},
 					{
-						pattern: headerValueOf(/Strict-Transport-Security/.source),
+						pattern: headerValueOf(/Strict-Transport-Security/),
 						lookbehind: true,
 						alias: ['hsts', 'languages-hsts'],
-						inside: Prism.languages.hsts
+						inside: 'hsts'
 					},
 					{
-						pattern: headerValueOf(/[^:]+/.source),
+						pattern: headerValueOf(/[^:]+/),
 						lookbehind: true
 					}
 				],
@@ -91,22 +89,19 @@
 	};
 
 	// Create a mapping of Content-Type headers to language definitions
-	var langs = Prism.languages;
-	var httpLanguages = {
-		'application/javascript': langs.javascript,
-		'application/json': langs.json || langs.javascript,
-		'application/xml': langs.xml,
-		'text/xml': langs.xml,
-		'text/html': langs.html,
-		'text/css': langs.css,
-		'text/plain': langs.plain
-	};
+
+	var httpLanguages = [
+		'application/javascript',
+		'application/json',
+		'application/xml',
+		'text/xml',
+		'text/html',
+		'text/css',
+		'text/plain'
+	];
 
 	// Declare which types can also be suffixes
-	var suffixTypes = {
-		'application/json': true,
-		'application/xml': true
-	};
+	var suffixTypes = ['application/json', 'application/xml'];
 
 	/**
 	 * Returns a pattern for the given content type which matches it and any type which has it as a suffix.
@@ -114,38 +109,24 @@
 	 * @param {string} contentType
 	 * @returns {string}
 	 */
-	function getSuffixPattern(contentType) {
-		var suffix = contentType.replace(/^[a-z]+\//, '');
-		var suffixPattern = '\\w+/(?:[\\w.-]+\\+)+' + suffix + '(?![+\\w.-])';
-		return '(?:' + contentType + '|' + suffixPattern + ')';
-	}
+	var getSuffixPattern = (contentType, lang) =>
+		'(?:' + contentType + '|\\w+/(?:[\\w.-]+\\+)+' + lang + '(?![+\\w.-]))';
 
 	// Insert each content type parser that has its associated language
 	// currently loaded.
-	var options;
-	for (var contentType in httpLanguages) {
-		if (httpLanguages[contentType]) {
-			options = options || {};
-
-			var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
-			options[contentType.replace(/\//g, '-')] = {
-				pattern: RegExp(
-					'(' + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ')' +
-					// This is a little interesting:
-					// The HTTP format spec required 1 empty line before the body to make everything unambiguous.
-					// However, when writing code by hand (e.g. to display on a website) people can forget about this,
-					// so we want to be liberal here. We will allow the empty line to be omitted if the first line of
-					// the body does not start with a [\w-] character (as headers do).
-					/[^ \t\w-][\s\S]*/.source,
-					'i'
-				),
-				lookbehind: true,
-				inside: httpLanguages[contentType]
-			};
-		}
-	}
-	if (options) {
-		Prism.languages.insertBefore('http', 'header', options);
-	}
+	var options = {};
+	httpLanguages.forEach(contentType => {
+		var lang = contentType.replace(/^[a-z]+\//, '')
+		var pattern = suffixTypes.includes(contentType) ? getSuffixPattern(contentType, lang) : contentType;
+		options[contentType.replace(/\//g, '-')] = {
+			pattern: RegExp(
+				'(content-type:\\s*'+ pattern + '(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n))[^ \\t\\w-][\\s\\S]*',
+				'i'
+			),
+			lookbehind: true,
+			inside: lang == 'json' ? Prism.languages.json || 'js' : lang
+		};
+	});
+	Prism.languages.insertBefore('http', 'header', options);
 
 }(Prism));
diff --git a/components/prism-icu-message-format.js b/components/prism-icu-message-format.js
index a4de0db52f835e6d6e5ea220727cad242a8c7eee..b6561c1cb451e4cc1f54f2854b5a43c85b717f7f 100644
--- a/components/prism-icu-message-format.js
+++ b/components/prism-icu-message-format.js
@@ -8,12 +8,11 @@
 	 * @param {number} level
 	 * @returns {string}
 	 */
-	function nested(source, level) {
-		if (level <= 0) {
-			return /[]/.source;
-		} else {
-			return source.replace(/<SELF>/g, function () { return nested(source, level - 1); });
+	var nested = (source, level) => {
+		if (level) {
+			return source.replace(/<SELF>/g, nested(source, level - 1));
 		}
+		return "[]";
 	}
 
 	var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
@@ -31,20 +30,33 @@
 		}
 	};
 
+	var message = {
+		pattern: /^(\{)[\s\S]+(?=\}$)/,
+		lookbehind: true
+	};
+
+	var choiceStyleInside = {
+		'punctuation': /\|/,
+		'range': {
+			pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
+			lookbehind: true,
+			inside: {
+				'operator': /[<#\u2264]/,
+				'number': /\S+/
+			}
+		}
+	};
+
 	var argumentSource = nested(
 		/\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source
-			.replace(/<STR>/g, function () { return stringPattern.source; }),
+			.replace(/<STR>/g, stringPattern.source),
 		8
 	);
 
 	var nestedMessage = {
 		pattern: RegExp(argumentSource),
 		inside: {
-			'message': {
-				pattern: /^(\{)[\s\S]+(?=\}$)/,
-				lookbehind: true,
-				inside: null // see below
-			},
+			'message': message,
 			'message-delimiter': {
 				pattern: /./,
 				alias: 'punctuation'
@@ -52,7 +64,7 @@
 		}
 	};
 
-	Prism.languages['icu-message-format'] = {
+	choiceStyleInside.rest = message.inside = Prism.languages['icu-message-format'] = {
 		'argument': {
 			pattern: RegExp(argumentSource),
 			greedy: true,
@@ -69,18 +81,7 @@
 							// https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
 							pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
 							lookbehind: true,
-							inside: {
-								'punctuation': /\|/,
-								'range': {
-									pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
-									lookbehind: true,
-									inside: {
-										'operator': /[<#\u2264]/,
-										'number': /\S+/
-									}
-								},
-								rest: null // see below
-							}
+							inside: choiceStyleInside
 						},
 						'plural-style': {
 							// https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
@@ -142,7 +143,4 @@
 		'string': string
 	};
 
-	nestedMessage.inside.message.inside = Prism.languages['icu-message-format'];
-	Prism.languages['icu-message-format'].argument.inside.content.inside['choice-style'].inside.rest = Prism.languages['icu-message-format'];
-
 }(Prism));
diff --git a/components/prism-idris.js b/components/prism-idris.js
index 3717ea02ab153a5a234edfcfe8596a7274af0524..17ab4b16b6073065a05ff792f28f1249e593dbcb 100644
--- a/components/prism-idris.js
+++ b/components/prism-idris.js
@@ -1,7 +1,5 @@
 Prism.languages.idris = Prism.languages.extend('haskell', {
-	'comment': {
-		pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m,
-	},
+	'comment': /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m,
 	'keyword': /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
 	'builtin': undefined
 });
diff --git a/components/prism-java.js b/components/prism-java.js
index 873154cfed23f828ca3d0f6ae6a4cd1b01c9128f..c3233f6dcd5b45673feafc7b1a4d1759d923dcf4 100644
--- a/components/prism-java.js
+++ b/components/prism-java.js
@@ -7,7 +7,7 @@
 
 	// based on the java naming conventions
 	var className = {
-		pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
+		pattern: RegExp(`(^|[^\\w.])${classNamePrefix}[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b`),
 		lookbehind: true,
 		inside: {
 			'namespace': {
@@ -31,14 +31,14 @@
 			{
 				// variables, parameters, and constructor references
 				// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
-				pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
+				pattern: RegExp(`(^|[^\\w.])${classNamePrefix}[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)`),
 				lookbehind: true,
 				inside: className.inside
 			},
 			{
 				// class names based on keyword
 				// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
-				pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
+				pattern: RegExp(`(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)${classNamePrefix}[A-Z]\\w*\\b`),
 				lookbehind: true,
 				inside: className.inside
 			}
@@ -89,7 +89,7 @@
 		},
 		'import': [
 			{
-				pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
+				pattern: RegExp(`(\\bimport\\s+)${classNamePrefix}(?:[A-Z]\\w*|\\*)(?=\\s*;)`),
 				lookbehind: true,
 				inside: {
 					'namespace': className.inside.namespace,
@@ -99,7 +99,7 @@
 				}
 			},
 			{
-				pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
+				pattern: RegExp(`(\\bimport\\s+static\\s+)${classNamePrefix}(?:\\w+|\\*)(?=\\s*;)`),
 				lookbehind: true,
 				alias: 'static',
 				inside: {
@@ -113,8 +113,8 @@
 		],
 		'namespace': {
 			pattern: RegExp(
-				/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/
-					.source.replace(/<keyword>/g, function () { return keywords.source; })),
+				`(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!${keywords.source})[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?`
+			),
 			lookbehind: true,
 			inside: {
 				'punctuation': /\./,
diff --git a/components/prism-javadoc.js b/components/prism-javadoc.js
index c16a1c14799abe8be80e23aa8354cc2e9fe7eb5e..4878f98c42d43383b76744ecc72121a9471c1c8c 100644
--- a/components/prism-javadoc.js
+++ b/components/prism-javadoc.js
@@ -3,12 +3,15 @@
 	var codeLinePattern = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m;
 
 	var memberReference = /#\s*\w+(?:\s*\([^()]*\))?/.source;
-	var reference = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(/<mem>/g, function () { return memberReference; });
+	var reference = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(/<mem>/g, memberReference);
+
+	var java = Prism.languages.java
+	var markup = Prism.languages.markup
+	var javadoc = Prism.languages.javadoc = Prism.languages.extend('javadoclike', {});
 
-	Prism.languages.javadoc = Prism.languages.extend('javadoclike', {});
 	Prism.languages.insertBefore('javadoc', 'keyword', {
 		'reference': {
-			pattern: RegExp(/(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + '(?:' + reference + ')'),
+			pattern: RegExp(`(@(?:exception|link|linkplain|see|throws|value)\\s+(?:\\*\\s*)?)(?:${reference})`),
 			lookbehind: true,
 			inside: {
 				'function': {
@@ -26,7 +29,7 @@
 					}
 				},
 				'class-name': /\b[A-Z]\w*/,
-				'keyword': Prism.languages.java.keyword,
+				'keyword': java.keyword,
 				'punctuation': /[#()[\],.]/
 			}
 		},
@@ -47,7 +50,7 @@
 						// there can't be any HTML inside of {@code} tags
 						pattern: codeLinePattern,
 						lookbehind: true,
-						inside: Prism.languages.java,
+						inside: java,
 						alias: 'language-java'
 					}
 				}
@@ -61,12 +64,12 @@
 						lookbehind: true,
 						inside: {
 							// highlight HTML tags and entities
-							'tag': Prism.languages.markup.tag,
-							'entity': Prism.languages.markup.entity,
+							'tag': markup.tag,
+							'entity': markup.entity,
 							'code': {
 								// everything else is Java code
 								pattern: /.+/,
-								inside: Prism.languages.java,
+								inside: java,
 								alias: 'language-java'
 							}
 						}
@@ -74,9 +77,9 @@
 				}
 			}
 		],
-		'tag': Prism.languages.markup.tag,
-		'entity': Prism.languages.markup.entity,
+		'tag': markup.tag,
+		'entity': markup.entity,
 	});
 
-	Prism.languages.javadoclike.addSupport('java', Prism.languages.javadoc);
+	Prism.languages.javadoclike.addSupport('java', javadoc);
 }(Prism));
diff --git a/components/prism-javadoclike.js b/components/prism-javadoclike.js
index 187d2cd74a6848a0ac8bd67da899ce72514dbdf9..c7868c8f10c2d18242b8721e786a1cd269f3e6c2 100644
--- a/components/prism-javadoclike.js
+++ b/components/prism-javadoclike.js
@@ -21,26 +21,23 @@
 	 * @param {string} lang the language add doc comment support to.
 	 * @param {(pattern: {inside: {rest: undefined}}) => void} callback the function called with each doc comment pattern as argument.
 	 */
-	function docCommentSupport(lang, callback) {
-		var tokenName = 'doc-comment';
-
+	var docCommentSupport = (lang, callback) => {
 		var grammar = Prism.languages[lang];
 		if (!grammar) {
 			return;
 		}
+		var tokenName = 'doc-comment';
 		var token = grammar[tokenName];
 
 		if (!token) {
 			// add doc comment: /** */
-			var definition = {};
-			definition[tokenName] = {
-				pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
-				lookbehind: true,
-				alias: 'comment'
-			};
-
-			grammar = Prism.languages.insertBefore(lang, 'comment', definition);
-			token = grammar[tokenName];
+			Prism.languages.insertBefore(lang, 'comment', token = {
+				[tokenName]: {
+					pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
+					lookbehind: true,
+					alias: 'comment'
+				}
+			});
 		}
 
 		if (token instanceof RegExp) { // convert regex to object
@@ -65,23 +62,16 @@
 	 * @param {string[]|string} languages
 	 * @param {Object} docLanguage
 	 */
-	function addSupport(languages, docLanguage) {
-		if (typeof languages === 'string') {
-			languages = [languages];
-		}
-
-		languages.forEach(function (lang) {
-			docCommentSupport(lang, function (pattern) {
-				if (!pattern.inside) {
-					pattern.inside = {};
-				}
-				pattern.inside.rest = docLanguage;
+	var addSupport = (languages, docLanguage) => {
+		(languages.map ? languages : [languages]).forEach(lang => {
+			docCommentSupport(lang, pattern => {
+				(pattern.inside ||= {}).rest = docLanguage;
 			});
 		});
 	}
 
 	Object.defineProperty(javaDocLike, 'addSupport', { value: addSupport });
 
-	javaDocLike.addSupport(['java', 'javascript', 'php'], javaDocLike);
+	addSupport(['java', 'javascript', 'php'], javaDocLike);
 
 }(Prism));
diff --git a/components/prism-javascript.js b/components/prism-javascript.js
index 7eda6c617f96726ca2ea12cda1e39527d67e7295..f81496b40e16e9afcee418ae1740d1a21598ed41 100644
--- a/components/prism-javascript.js
+++ b/components/prism-javascript.js
@@ -1,76 +1,50 @@
-Prism.languages.javascript = Prism.languages.extend('clike', {
+var js = Prism.languages.js = Prism.languages.javascript = Prism.languages.extend('clike', {
 	'class-name': [
-		Prism.languages.clike['class-name'],
+		{
+			pattern: /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,
+			lookbehind: true,
+			inside: {
+				'punctuation': /[.\\]/
+			}
+		},
 		{
 			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
 			lookbehind: true
 		}
 	],
 	'keyword': [
+		{
+			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|export|from(?=\s*(?:['"]|$))|import)\b/,
+			lookbehind: true,
+			alias: 'module'
+		},
 		{
 			pattern: /((?:^|\})\s*)catch\b/,
-			lookbehind: true
+			lookbehind: true,
+			alias: 'control-flow'
 		},
 		{
-			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
+			pattern: /(^|[^.]|\.\.\.\s*)\b(?:await|break|case|continue|default|do|else|finally(?=\s*(?:\{|$))|for|if|return|switch|throw|try|while|yield)\b/,
+			lookbehind: true,
+			alias: 'control-flow'
+		},
+		{
+			pattern: /(^|[^.]|\.\.\.\s*)\b(?:async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|class|const|debugger|delete|enum|extends|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|static|super|this|typeof|undefined|var|void|with)\b/,
 			lookbehind: true
 		},
 	],
 	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
 	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
 	'number': {
-		pattern: RegExp(
-			/(^|[^\w$])/.source +
-			'(?:' +
-			(
-				// constant
-				/NaN|Infinity/.source +
-				'|' +
-				// binary integer
-				/0[bB][01]+(?:_[01]+)*n?/.source +
-				'|' +
-				// octal integer
-				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
-				'|' +
-				// hexadecimal integer
-				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
-				'|' +
-				// decimal bigint
-				/\d+(?:_\d+)*n/.source +
-				'|' +
-				// decimal number (integer or float) but no bigint
-				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
-			) +
-			')' +
-			/(?![\w$])/.source
-		),
+		pattern: /(^|[^\w$])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?|\d+(?:_\d+)*n|(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?)(?![\w$])/,
 		lookbehind: true
 	},
 	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
 });
 
-Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
-
-Prism.languages.insertBefore('javascript', 'keyword', {
+Prism.languages.insertBefore('js', 'keyword', {
 	'regex': {
-		pattern: RegExp(
-			// lookbehind
-			// eslint-disable-next-line regexp/no-dupe-characters-character-class
-			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
-			// Regex pattern:
-			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
-			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
-			// with the only syntax, so we have to define 2 different regex patterns.
-			/\//.source +
-			'(?:' +
-			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
-			'|' +
-			// `v` flag syntax. This supports 3 levels of nested character classes.
-			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
-			')' +
-			// lookahead
-			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
-		),
+		pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}|(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
 		lookbehind: true,
 		greedy: true,
 		inside: {
@@ -78,7 +52,7 @@ Prism.languages.insertBefore('javascript', 'keyword', {
 				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
 				lookbehind: true,
 				alias: 'language-regex',
-				inside: Prism.languages.regex
+				inside: 'regex'
 			},
 			'regex-delimiter': /^\/|\/$/,
 			'regex-flags': /^[a-z]+$/,
@@ -90,38 +64,26 @@ Prism.languages.insertBefore('javascript', 'keyword', {
 		alias: 'function'
 	},
 	'parameter': [
-		{
-			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
-			lookbehind: true,
-			inside: Prism.languages.javascript
-		},
-		{
-			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
-			lookbehind: true,
-			inside: Prism.languages.javascript
-		},
-		{
-			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
-			lookbehind: true,
-			inside: Prism.languages.javascript
-		},
-		{
-			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
-			lookbehind: true,
-			inside: Prism.languages.javascript
-		}
-	],
+		/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
+		/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
+		/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
+		/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/
+	].map(pattern => ({
+		pattern,
+		lookbehind: true,
+		inside: js
+	})),
 	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
 });
 
-Prism.languages.insertBefore('javascript', 'string', {
+Prism.languages.insertBefore('js', 'string', {
 	'hashbang': {
 		pattern: /^#!.*/,
 		greedy: true,
 		alias: 'comment'
 	},
 	'template-string': {
-		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
+		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}|(?!\$\{)[^\\`])*`/g,
 		greedy: true,
 		inside: {
 			'template-punctuation': {
@@ -129,14 +91,14 @@ Prism.languages.insertBefore('javascript', 'string', {
 				alias: 'string'
 			},
 			'interpolation': {
-				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
+				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}/,
 				lookbehind: true,
 				inside: {
 					'interpolation-punctuation': {
 						pattern: /^\$\{|\}$/,
 						alias: 'punctuation'
 					},
-					rest: Prism.languages.javascript
+					rest: js
 				}
 			},
 			'string': /[\s\S]+/
@@ -156,17 +118,12 @@ Prism.languages.insertBefore('javascript', 'operator', {
 		lookbehind: true,
 		alias: 'property'
 	},
+	'spread': {
+		pattern: /\.{3}/,
+		alias: 'operator'
+	},
+	'arrow': {
+		pattern: /=>/,
+		alias: 'operator'
+	}
 });
-
-if (Prism.languages.markup) {
-	Prism.languages.markup.tag.addInlined('script', 'javascript');
-
-	// add attribute support for all DOM events.
-	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
-	Prism.languages.markup.tag.addAttribute(
-		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
-		'javascript'
-	);
-}
-
-Prism.languages.js = Prism.languages.javascript;
diff --git a/components/prism-jolie.js b/components/prism-jolie.js
index 6b54f864729c7a7aaea8c1d99d06f4b3e9f89ea6..85e79dd82ba08998f031ce5e0bc9931aec4ad014 100644
--- a/components/prism-jolie.js
+++ b/components/prism-jolie.js
@@ -35,7 +35,5 @@ Prism.languages.insertBefore('jolie', 'keyword', {
 			'operator': /=>/
 		}
 	},
-	'property': {
-		pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
-	}
+	'property': /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
 });
diff --git a/components/prism-jq.js b/components/prism-jq.js
index 3cc030e72fd1325f4719b8cf89178670898edecc..00581d047cc7ae9a35b76ca2dd9e74676389825a 100644
--- a/components/prism-jq.js
+++ b/components/prism-jq.js
@@ -1,23 +1,23 @@
 (function (Prism) {
 
+	var content = {
+		pattern: /^(\\\()[\s\S]+(?=\)$)/,
+		lookbehind: true
+	};
 	var interpolation = /\\\((?:[^()]|\([^()]*\))*\)/.source;
-	var string = RegExp(/(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(/__/g, function () { return interpolation; }));
+	var string = RegExp(/(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(/__/g, interpolation));
 	var stringInterpolation = {
 		'interpolation': {
 			pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + interpolation),
 			lookbehind: true,
 			inside: {
-				'content': {
-					pattern: /^(\\\()[\s\S]+(?=\)$)/,
-					lookbehind: true,
-					inside: null // see below
-				},
+				'content': content,
 				'punctuation': /^\\\(|\)$/
 			}
 		}
 	};
 
-	var jq = Prism.languages.jq = {
+	content.inside = Prism.languages.jq = {
 		'comment': /#.*/,
 		'property': {
 			pattern: RegExp(string.source + /(?=\s*:(?!:))/.source),
@@ -64,6 +64,4 @@
 		}
 	};
 
-	stringInterpolation.interpolation.inside.content.inside = jq;
-
 }(Prism));
diff --git a/components/prism-js-extras.js b/components/prism-js-extras.js
index 64cac5af9baa7cbc06390623019140f15e7380e7..ad5ed796ab72edd4d9847d3e43f44b8925d67551 100644
--- a/components/prism-js-extras.js
+++ b/components/prism-js-extras.js
@@ -1,22 +1,27 @@
 (function (Prism) {
 
-	Prism.languages.insertBefore('javascript', 'function-variable', {
+	var js = Prism.languages.js;
+	var withId = pattern => RegExp(
+		pattern.source.replace(/<ID>/g, '(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*')
+	);
+
+	Prism.languages.insertBefore('js', 'function-variable', {
 		'method-variable': {
-			pattern: RegExp('(\\.\\s*)' + Prism.languages.javascript['function-variable'].pattern.source),
+			pattern: RegExp('(\\.\\s*)' + js['function-variable'].pattern.source),
 			lookbehind: true,
 			alias: ['function-variable', 'method', 'function', 'property-access']
 		}
 	});
 
-	Prism.languages.insertBefore('javascript', 'function', {
+	Prism.languages.insertBefore('js', 'function', {
 		'method': {
-			pattern: RegExp('(\\.\\s*)' + Prism.languages.javascript['function'].source),
+			pattern: RegExp('(\\.\\s*)' + js['function'].source),
 			lookbehind: true,
 			alias: ['function', 'property-access']
 		}
 	});
 
-	Prism.languages.insertBefore('javascript', 'constant', {
+	Prism.languages.insertBefore('js', 'constant', {
 		'known-class-name': [
 			{
 				// standard built-ins
@@ -32,66 +37,24 @@
 		]
 	});
 
-	/**
-	 * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.
-	 *
-	 * @param {string} source
-	 * @param {string} [flags]
-	 * @returns {RegExp}
-	 */
-	function withId(source, flags) {
-		return RegExp(
-			source.replace(/<ID>/g, function () { return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source; }),
-			flags);
-	}
-	Prism.languages.insertBefore('javascript', 'keyword', {
+	Prism.languages.insertBefore('js', 'keyword', {
 		'imports': {
 			// https://tc39.es/ecma262/#sec-imports
-			pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
+			pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/),
 			lookbehind: true,
-			inside: Prism.languages.javascript
+			inside: js
 		},
 		'exports': {
 			// https://tc39.es/ecma262/#sec-exports
-			pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
+			pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/),
 			lookbehind: true,
-			inside: Prism.languages.javascript
+			inside: js
 		}
 	});
 
-	Prism.languages.javascript['keyword'].unshift(
-		{
-			pattern: /\b(?:as|default|export|from|import)\b/,
-			alias: 'module'
-		},
-		{
-			pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
-			alias: 'control-flow'
-		},
-		{
-			pattern: /\bnull\b/,
-			alias: ['null', 'nil']
-		},
-		{
-			pattern: /\bundefined\b/,
-			alias: 'nil'
-		}
-	);
-
-	Prism.languages.insertBefore('javascript', 'operator', {
-		'spread': {
-			pattern: /\.{3}/,
-			alias: 'operator'
-		},
-		'arrow': {
-			pattern: /=>/,
-			alias: 'operator'
-		}
-	});
-
-	Prism.languages.insertBefore('javascript', 'punctuation', {
+	Prism.languages.insertBefore('js', 'punctuation', {
 		'property-access': {
-			pattern: withId(/(\.\s*)#?<ID>/.source),
+			pattern: withId(/(\.\s*)#?<ID>/),
 			lookbehind: true
 		},
 		'maybe-class-name': {
@@ -109,27 +72,21 @@
 		}
 	});
 
-
 	// add 'maybe-class-name' to tokens which might be a class name
-	var maybeClassNameTokens = ['function', 'function-variable', 'method', 'method-variable', 'property-access'];
-
-	for (var i = 0; i < maybeClassNameTokens.length; i++) {
-		var token = maybeClassNameTokens[i];
-		var value = Prism.languages.javascript[token];
 
+	['function', 'function-variable', 'method', 'method-variable', 'property-access'].forEach(token => {
+		var value = js[token];
+	
 		// convert regex to object
-		if (Prism.util.type(value) === 'RegExp') {
-			value = Prism.languages.javascript[token] = {
+		if (value instanceof RegExp) {
+			value = js[token] = {
 				pattern: value
 			};
 		}
-
+	
 		// keep in mind that we don't support arrays
-
-		var inside = value.inside || {};
-		value.inside = inside;
-
-		inside['maybe-class-name'] = /^[A-Z][\s\S]*/;
-	}
+	
+		(value.inside ||= {})['maybe-class-name'] = /^[A-Z][\s\S]*/;
+	})
 
 }(Prism));
diff --git a/components/prism-js-templates.js b/components/prism-js-templates.js
index 8562126cd46ec862b8adfa76c2e8722d0aff28e9..dae0e2c69168afa256199f5c8a141624370465ea 100644
--- a/components/prism-js-templates.js
+++ b/components/prism-js-templates.js
@@ -1,13 +1,14 @@
 (function (Prism) {
 
-	var templateString = Prism.languages.javascript['template-string'];
+	var js = Prism.languages.js
+	var templateString = js['template-string'];
 
 	// see the pattern in prism-javascript.js
 	var templateLiteralPattern = templateString.pattern.source;
-	var interpolationObject = templateString.inside['interpolation'];
-	var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];
-	var interpolationPattern = interpolationObject.pattern.source;
-
+	var {
+		pattern: interpolationPattern,
+		inside: { ['interpolation-punctuation']: interpolationPunctuationObject }
+	} = templateString.inside.interpolation;
 
 	/**
 	 * Creates a new pattern to match a template string with a special tag.
@@ -15,60 +16,54 @@
 	 * This will return `undefined` if there is no grammar with the given language id.
 	 *
 	 * @param {string} language The language id of the embedded language. E.g. `markdown`.
-	 * @param {string} tag The regex pattern to match the tag.
+	 * @param {RegExp} tag The regex pattern to match the tag.
 	 * @returns {object | undefined}
 	 * @example
 	 * createTemplate('css', /\bcss/.source);
 	 */
-	function createTemplate(language, tag) {
-		if (!Prism.languages[language]) {
-			return undefined;
-		}
-
-		return {
-			pattern: RegExp('((?:' + tag + ')\\s*)' + templateLiteralPattern),
-			lookbehind: true,
-			greedy: true,
-			inside: {
-				'template-punctuation': {
-					pattern: /^`|`$/,
-					alias: 'string'
-				},
-				'embedded-code': {
-					pattern: /[\s\S]+/,
-					alias: language
-				}
+	var createTemplate = (language, tag) => ({
+		pattern: RegExp('((?:' + tag.source + ')\\s*)' + templateLiteralPattern),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'template-punctuation': {
+				pattern: /^`|`$/,
+				alias: 'string'
+			},
+			'embedded-code': {
+				pattern: /[\s\S]+/,
+				alias: language
 			}
-		};
-	}
+		}
+	});
 
 
-	Prism.languages.javascript['template-string'] = [
+	js['template-string'] = [
 		// styled-jsx:
 		//   css`a { color: #25F; }`
 		// styled-components:
 		//   styled.h1`color: red;`
-		createTemplate('css', /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
+		createTemplate('css', /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/),
 
 		// html`<p></p>`
 		// div.innerHTML = `<p></p>`
-		createTemplate('html', /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
+		createTemplate('html', /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/),
 
 		// svg`<path fill="#fff" d="M55.37 ..."/>`
-		createTemplate('svg', /\bsvg/.source),
+		createTemplate('svg', /\bsvg/),
 
 		// md`# h1`, markdown`## h2`
-		createTemplate('markdown', /\b(?:markdown|md)/.source),
+		createTemplate('markdown', /\b(?:markdown|md)/),
 
 		// gql`...`, graphql`...`, graphql.experimental`...`
-		createTemplate('graphql', /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
+		createTemplate('graphql', /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/),
 
 		// sql`...`
-		createTemplate('sql', /\bsql/.source),
+		createTemplate('sql', /\bsql/),
 
 		// vanilla template string
 		templateString
-	].filter(Boolean);
+	];
 
 
 	/**
@@ -78,9 +73,7 @@
 	 * @param {string} language
 	 * @returns {string}
 	 */
-	function getPlaceholder(counter, language) {
-		return '___' + language.toUpperCase() + '_' + counter + '___';
-	}
+	var getPlaceholder = (counter, language) => `___${language.toUpperCase()}_${counter}___`
 
 	/**
 	 * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.
@@ -90,7 +83,7 @@
 	 * @param {string} language
 	 * @returns {(string|Token)[]}
 	 */
-	function tokenizeWithHooks(code, grammar, language) {
+	var tokenizeWithHooks = (code, grammar, language) => {
 		var env = {
 			code: code,
 			grammar: grammar,
@@ -108,13 +101,14 @@
 	 * @param {string} expression The code of the expression. E.g. `"${42}"`
 	 * @returns {Token}
 	 */
-	function tokenizeInterpolationExpression(expression) {
-		var tempGrammar = {};
-		tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;
+	var tokenizeInterpolationExpression = (expression, alias) => {
+		var tempGrammar = {
+			['interpolation-punctuation']: interpolationPunctuationObject
+		};
 
 		/** @type {Array} */
 		var tokens = Prism.tokenize(expression, tempGrammar);
-		if (tokens.length === 3) {
+		if (tokens.length == 3) {
 			/**
 			 * The token array will look like this
 			 * [
@@ -123,14 +117,10 @@
 			 *     ["interpolation-punctuation", "}"]
 			 * ]
 			 */
-
-			var args = [1, 1];
-			args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));
-
-			tokens.splice.apply(tokens, args);
+			tokens.splice(1, 1, ...tokenizeWithHooks(tokens[1], js, 'javascript'));
 		}
 
-		return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);
+		return new Prism.Token('interpolation', tokens, alias, expression);
 	}
 
 	/**
@@ -150,14 +140,14 @@
 	 * @param {string} language
 	 * @returns {Token}
 	 */
-	function tokenizeEmbedded(code, grammar, language) {
+	var tokenizeEmbedded = (code, grammar = {}, language, alias) => {
 		// 1. First filter out all interpolations
 
 		// because they might be escaped, we need a lookbehind, so we use Prism
 		/** @type {(Token|string)[]} */
 		var _tokens = Prism.tokenize(code, {
 			'interpolation': {
-				pattern: RegExp(interpolationPattern),
+				pattern: interpolationPattern,
 				lookbehind: true
 			}
 		});
@@ -166,25 +156,20 @@
 		var placeholderCounter = 0;
 		/** @type {Object<string, string>} */
 		var placeholderMap = {};
-		var embeddedCode = _tokens.map(function (token) {
-			if (typeof token === 'string') {
-				return token;
-			} else {
-				var interpolationExpression = token.content;
-
-				var placeholder;
-				while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { /* noop */ }
-				placeholderMap[placeholder] = interpolationExpression;
-				return placeholder;
-			}
+		var embeddedCode = _tokens.map(token => {
+			if (typeof token == 'string') return token;
+			var interpolationExpression = token.content;
+
+			var placeholder;
+			while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) != -1) { /* noop */ }
+			placeholderMap[placeholder] = interpolationExpression;
+			return placeholder;
 		}).join('');
 
-
 		// 2. Tokenize the embedded code
 
 		var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);
 
-
 		// 3. Re-insert the interpolation
 
 		var placeholders = Object.keys(placeholderMap);
@@ -195,51 +180,43 @@
 		 * @param {(Token|string)[]} tokens
 		 * @returns {void}
 		 */
-		function walkTokens(tokens) {
-			for (var i = 0; i < tokens.length; i++) {
-				if (placeholderCounter >= placeholders.length) {
-					return;
-				}
-
+		var walkTokens = tokens => {
+			for (var i = 0, l = placeholders.length; i < tokens.length && placeholderCounter < l; i++) {
 				var token = tokens[i];
+				var content = token.content;
 
-				if (typeof token === 'string' || typeof token.content === 'string') {
+				if (Array.isArray(content)) {
+					walkTokens(content)
+				}
+				else {
 					var placeholder = placeholders[placeholderCounter];
-					var s = typeof token === 'string' ? token : /** @type {string} */ (token.content);
+					var s = content || token;
 
 					var index = s.indexOf(placeholder);
-					if (index !== -1) {
+					if (index + 1) {
 						++placeholderCounter;
 
-						var before = s.substring(0, index);
-						var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
-						var after = s.substring(index + placeholder.length);
+						var before = s.slice(0, index);
+						var middle = tokenizeInterpolationExpression(placeholderMap[placeholder], alias);
+						var after = s.slice(index + placeholder.length);
 
-						var replacement = [];
+						var replacement = [middle];
 						if (before) {
-							replacement.push(before);
+							replacement.unshift(before)
 						}
-						replacement.push(middle);
 						if (after) {
 							var afterTokens = [after];
 							walkTokens(afterTokens);
-							replacement.push.apply(replacement, afterTokens);
+							replacement.push(...afterTokens);
 						}
 
-						if (typeof token === 'string') {
-							tokens.splice.apply(tokens, [i, 1].concat(replacement));
+						if (!content) {
+							tokens.splice(i, 1, ...replacement);
 							i += replacement.length - 1;
 						} else {
 							token.content = replacement;
 						}
 					}
-				} else {
-					var content = token.content;
-					if (Array.isArray(content)) {
-						walkTokens(content);
-					} else {
-						walkTokens([content]);
-					}
 				}
 			}
 		}
@@ -253,42 +230,31 @@
 	 *
 	 * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.
 	 */
-	var supportedLanguages = {
-		'javascript': true,
-		'js': true,
-		'typescript': true,
-		'ts': true,
-		'jsx': true,
-		'tsx': true,
-	};
-	Prism.hooks.add('after-tokenize', function (env) {
-		if (!(env.language in supportedLanguages)) {
+	var langs = ['javascript', 'typescript', 'jsx', 'tsx', 'js', 'ts']
+
+	Prism.hooks.add('after-tokenize', env => {
+		if (!langs.includes(env.language)) {
 			return;
 		}
 
+		var langAlias = 'language-' + env.language;
+
 		/**
 		 * Finds and tokenizes all template strings with an embedded languages.
 		 *
 		 * @param {(Token | string)[]} tokens
 		 * @returns {void}
 		 */
-		function findTemplateStrings(tokens) {
+		var findTemplateStrings = tokens => {
 			for (var i = 0, l = tokens.length; i < l; i++) {
 				var token = tokens[i];
-
-				if (typeof token === 'string') {
-					continue;
-				}
-
 				var content = token.content;
+
 				if (!Array.isArray(content)) {
-					if (typeof content !== 'string') {
-						findTemplateStrings([content]);
-					}
 					continue;
 				}
 
-				if (token.type === 'template-string') {
+				if (token.type == 'template-string') {
 					/**
 					 * A JavaScript template-string token will look like this:
 					 *
@@ -305,20 +271,12 @@
 					 */
 
 					var embedded = content[1];
-					if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {
+					if (content.length == 3 && embedded.type == 'embedded-code') {
 						// get string content
 						var code = stringContent(embedded);
+						var language = embedded.alias;
 
-						var alias = embedded.alias;
-						var language = Array.isArray(alias) ? alias[0] : alias;
-
-						var grammar = Prism.languages[language];
-						if (!grammar) {
-							// the embedded language isn't registered.
-							continue;
-						}
-
-						content[1] = tokenizeEmbedded(code, grammar, language);
+						content[1] = tokenizeEmbedded(code, Prism.languages[language], language, langAlias);
 					}
 				} else {
 					findTemplateStrings(content);
@@ -336,14 +294,13 @@
 	 * @param {string | Token | (string | Token)[]} value
 	 * @returns {string}
 	 */
-	function stringContent(value) {
-		if (typeof value === 'string') {
+	var stringContent = value => {
+		if (typeof value == 'string') {
 			return value;
-		} else if (Array.isArray(value)) {
+		} if (Array.isArray(value)) {
 			return value.map(stringContent).join('');
-		} else {
-			return stringContent(value.content);
 		}
+		return stringContent(value.content);
 	}
 
 }(Prism));
diff --git a/components/prism-jsdoc.js b/components/prism-jsdoc.js
index fab3c192dc3e532db09523bf7c827084c5d7fc99..26f29fb63f9ecff0ca3fdfcdead7ac3739cbac41 100644
--- a/components/prism-jsdoc.js
+++ b/components/prism-jsdoc.js
@@ -1,9 +1,9 @@
 (function (Prism) {
 
-	var javascript = Prism.languages.javascript;
+	var javascript = Prism.languages.js;
 
 	var type = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source;
-	var parameterPrefix = '(@(?:arg|argument|param|property)\\s+(?:' + type + '\\s+)?)';
+	var parameterPrefix = `(@(?:arg|argument|param|property)\\s+(?:${type}\\s+)?)`;
 
 	Prism.languages.jsdoc = Prism.languages.extend('javadoclike', {
 		'parameter': {
@@ -40,7 +40,7 @@
 		},
 		'class-name': [
 			{
-				pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function () { return type; })),
+				pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, type)),
 				lookbehind: true,
 				inside: {
 					'punctuation': /\./
@@ -53,7 +53,7 @@
 					'string': javascript.string,
 					'number': javascript.number,
 					'boolean': javascript.boolean,
-					'keyword': Prism.languages.typescript.keyword,
+					'keyword': Prism.languages.ts.keyword,
 					'operator': /=>|\.\.\.|[&|?:*]/,
 					'punctuation': /[.,;=<>{}()[\]]/
 				}
diff --git a/components/prism-jsx.js b/components/prism-jsx.js
index ac6c2d64243ac329e7c8a159cdebf5b37eff6a4e..71a172bff1311aec56e573ce2fc26970ce2c5b94 100644
--- a/components/prism-jsx.js
+++ b/components/prism-jsx.js
@@ -1,125 +1,115 @@
 (function (Prism) {
 
-	var javascript = Prism.util.clone(Prism.languages.javascript);
+	var javascript = Prism.util.clone(Prism.languages.js);
+	var jsx = Prism.languages.jsx = Prism.languages.extend('markup', javascript);
+	var tag = jsx.tag;
 
 	var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
 	var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
-	var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
+	var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/;
 
 	/**
 	 * @param {string} source
 	 * @param {string} [flags]
 	 */
-	function re(source, flags) {
-		source = source
-			.replace(/<S>/g, function () { return space; })
-			.replace(/<BRACES>/g, function () { return braces; })
-			.replace(/<SPREAD>/g, function () { return spread; });
-		return RegExp(source, flags);
-	}
-
-	spread = re(spread).source;
+	var re = pattern => RegExp(pattern.source
+		.replace(/<S>/g, space)
+		.replace(/<BRACES>/g, braces)
+		.replace(/<SPREAD>/g, spread.source)
+	);
 
+	spread = re(spread);
 
-	Prism.languages.jsx = Prism.languages.extend('markup', javascript);
-	Prism.languages.jsx.tag.pattern = re(
-		/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
+	tag.pattern = re(
+		/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/
 	);
 
-	Prism.languages.jsx.tag.inside['tag'].pattern = /^<\/?[^\s>\/]*/;
-	Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
-	Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
-	Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];
+	tag.inside['tag'].pattern = /^<\/?[^\s>\/]*/;
+	tag.inside['attr-value'].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
+	tag.inside['tag'].inside['class-name'] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
+	tag.inside['comment'] = javascript['comment'];
+
+	delete jsx.style;
+	delete jsx.script;
+	delete jsx['markup-bracket'];
 
 	Prism.languages.insertBefore('inside', 'attr-name', {
 		'spread': {
-			pattern: re(/<SPREAD>/.source),
-			inside: Prism.languages.jsx
+			pattern: spread,
+			inside: jsx
 		}
-	}, Prism.languages.jsx.tag);
+	}, tag);
 
 	Prism.languages.insertBefore('inside', 'special-attr', {
 		'script': {
 			// Allow for two levels of nesting
-			pattern: re(/=<BRACES>/.source),
+			pattern: re(/=<BRACES>/),
 			alias: 'language-javascript',
 			inside: {
 				'script-punctuation': {
 					pattern: /^=(?=\{)/,
 					alias: 'punctuation'
 				},
-				rest: Prism.languages.jsx
+				rest: jsx
 			},
 		}
-	}, Prism.languages.jsx.tag);
+	}, tag);
 
-	// The following will handle plain text inside tags
-	var stringifyToken = function (token) {
-		if (!token) {
-			return '';
-		}
-		if (typeof token === 'string') {
-			return token;
-		}
-		if (typeof token.content === 'string') {
-			return token.content;
+	var stringifyToken = token => {
+		if (token && token.type) {
+			return Array.isArray(token = token.content) ? token.map(stringifyToken).join('') : token;
 		}
-		return token.content.map(stringifyToken).join('');
+		return token || '';
 	};
 
-	var walkTokens = function (tokens) {
-		var openedTags = [];
-		for (var i = 0; i < tokens.length; i++) {
+	var walkTokens = tokens => {
+		for (var i = 0, openedTags = []; i < tokens.length; i++) {
 			var token = tokens[i];
 			var notTagNorBrace = false;
+			var content = token.content;
+			var type = token.type;
+			var last;
 
-			if (typeof token !== 'string') {
-				if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {
+			if (type) {
+				if (type == 'tag' && content[0].type == 'tag') {
 					// We found a tag, now find its kind
 
-					if (token.content[0].content[0].content === '</') {
+					if (content[0].content[0].content == '</') {
 						// Closing tag
-						if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
+						if (openedTags[0] && openedTags[openedTags.length - 1][0] == stringifyToken(content[0].content[1])) {
 							// Pop matching opening tag
 							openedTags.pop();
 						}
 					} else {
-						if (token.content[token.content.length - 1].content === '/>') {
-							// Autoclosed tag, ignore
-						} else {
+						if (content[content.length - 1].content == '>') {
 							// Opening tag
-							openedTags.push({
-								tagName: stringifyToken(token.content[0].content[1]),
-								openedBraces: 0
-							});
+							openedTags.push([stringifyToken(content[0].content[1]), 0]);
 						}
 					}
-				} else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {
-
-					// Here we might have entered a JSX context inside a tag
-					openedTags[openedTags.length - 1].openedBraces++;
-
-				} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {
-
-					// Here we might have left a JSX context inside a tag
-					openedTags[openedTags.length - 1].openedBraces--;
-
+				} else if (openedTags[0] && type == 'punctuation') {
+					last = openedTags[openedTags.length - 1];
+					if (content == "{") last[1]++;
+					else if (last[1] && content == "}") last[1]--;
+					else {
+						notTagNorBrace = true;
+					}
 				} else {
 					notTagNorBrace = true;
 				}
 			}
-			if (notTagNorBrace || typeof token === 'string') {
-				if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
+			if (notTagNorBrace || !type) {
+				if (openedTags[0] && !openedTags[openedTags.length - 1][1]) {
 					// Here we are inside a tag, and not inside a JSX context.
 					// That's plain text: drop any tokens matched.
 					var plainText = stringifyToken(token);
+					var isText = token => token && (!token.type || token.type == 'plain-text');
 
 					// And merge text with adjacent text
-					if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {
+					if (isText(tokens[i + 1])) {
 						plainText += stringifyToken(tokens[i + 1]);
 						tokens.splice(i + 1, 1);
 					}
-					if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {
+					if (isText(tokens[i - 1])) {
 						plainText = stringifyToken(tokens[i - 1]) + plainText;
 						tokens.splice(i - 1, 1);
 						i--;
@@ -129,17 +119,16 @@
 				}
 			}
 
-			if (token.content && typeof token.content !== 'string') {
-				walkTokens(token.content);
+			if (Array.isArray(content)) {
+				walkTokens(content);
 			}
 		}
 	};
 
-	Prism.hooks.add('after-tokenize', function (env) {
-		if (env.language !== 'jsx' && env.language !== 'tsx') {
-			return;
+	Prism.hooks.add('after-tokenize', (env) => {
+		if (env.language == 'jsx' || env.language == 'tsx') {
+			walkTokens(env.tokens);
 		}
-		walkTokens(env.tokens);
 	});
 
 }(Prism));
diff --git a/components/prism-keepalived.js b/components/prism-keepalived.js
index 70a99944ba94d62889b3adace9c21c7663cf0699..bf0066fd6928179a4df114efba4af3342d1e2567 100644
--- a/components/prism-keepalived.js
+++ b/components/prism-keepalived.js
@@ -13,7 +13,7 @@ Prism.languages.keepalived = {
 	'ip': {
 		pattern: RegExp(
 			/\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source
-				.replace(/<ipv4>/g, function () { return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source; }),
+				.replace(/<ipv4>/g, /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source),
 			'i'
 		),
 		alias: 'number'
diff --git a/components/prism-kotlin.js b/components/prism-kotlin.js
index 3b45dcbf577fc2c9fa769ea260079addda729bcf..1488dc57cdd61accd86048404537bffdc41d58fb 100644
--- a/components/prism-kotlin.js
+++ b/components/prism-kotlin.js
@@ -1,5 +1,6 @@
 (function (Prism) {
-	Prism.languages.kotlin = Prism.languages.extend('clike', {
+
+	var kotlin = Prism.languages.kts = Prism.languages.kt = Prism.languages.kotlin = Prism.languages.extend('clike', {
 		'keyword': {
 			// The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
 			pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
@@ -20,7 +21,7 @@
 		'operator': /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
 	});
 
-	delete Prism.languages.kotlin['class-name'];
+	delete kotlin['class-name'];
 
 	var interpolationInside = {
 		'interpolation-punctuation': {
@@ -29,11 +30,11 @@
 		},
 		'expression': {
 			pattern: /[\s\S]+/,
-			inside: Prism.languages.kotlin
+			inside: kotlin
 		}
 	};
 
-	Prism.languages.insertBefore('kotlin', 'string', {
+	Prism.languages.insertBefore('kotlin', 'comment', {
 		// https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
 		'string-literal': [
 			{
@@ -67,7 +68,7 @@
 		}
 	});
 
-	delete Prism.languages.kotlin['string'];
+	delete kotlin['string'];
 
 	Prism.languages.insertBefore('kotlin', 'keyword', {
 		'annotation': {
@@ -83,6 +84,4 @@
 		}
 	});
 
-	Prism.languages.kt = Prism.languages.kotlin;
-	Prism.languages.kts = Prism.languages.kotlin;
 }(Prism));
diff --git a/components/prism-kumir.js b/components/prism-kumir.js
index 679574078b8c0067818883b4696bd6079655911c..901e96a220f626f84c7ef6c0c9d4d3fae9a282c1 100644
--- a/components/prism-kumir.js
+++ b/components/prism-kumir.js
@@ -11,18 +11,15 @@
 	/**
 	 * Surround a regular expression for IDs with patterns for non-ID sequences.
 	 *
-	 * @param {string} pattern A regular expression for identifiers.
+	 * @param {RegExp} pattern A regular expression for identifiers.
 	 * @param {string} [flags] The regular expression flags.
 	 * @returns {RegExp} A wrapped regular expression for identifiers.
 	 */
-	function wrapId(pattern, flags) {
-		return RegExp(pattern.replace(/<nonId>/g, nonId), flags);
-	}
+	var wrapId = (pattern, flags) =>
+		RegExp(pattern.source.replace(/<nonId>/g, nonId), flags);
 
-	Prism.languages.kumir = {
-		'comment': {
-			pattern: /\|.*/
-		},
+	Prism.languages.kum = Prism.languages.kumir = {
+		'comment': /\|.*/,
 
 		'prolog': {
 			pattern: /#.*/,
@@ -35,30 +32,30 @@
 		},
 
 		'boolean': {
-			pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
+			pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/),
 			lookbehind: true
 		},
 
 		'operator-word': {
-			pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
+			pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/),
 			lookbehind: true,
 			alias: 'keyword'
 		},
 
 		'system-variable': {
-			pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
+			pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/),
 			lookbehind: true,
 			alias: 'keyword'
 		},
 
 		'type': [
 			{
-				pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source),
+				pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/),
 				lookbehind: true,
 				alias: 'builtin'
 			},
 			{
-				pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),
+				pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/),
 				lookbehind: true,
 				alias: 'important'
 			}
@@ -70,20 +67,20 @@
 		 * "НАЗНАЧИТЬ", "Фввод", and "Фвывод" are not reserved words.
 		 */
 		'keyword': {
-			pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),
+			pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/),
 			lookbehind: true
 		},
 
 		/** Should be performed after searching for reserved words. */
 		'name': {
 			// eslint-disable-next-line regexp/no-super-linear-backtracking
-			pattern: wrapId(/(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),
+			pattern: wrapId(/(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/),
 			lookbehind: true
 		},
 
 		/** Should be performed after searching for names. */
 		'number': {
-			pattern: wrapId(/(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source, 'i'),
+			pattern: wrapId(/(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/, 'i'),
 			lookbehind: true
 		},
 
@@ -101,6 +98,4 @@
 		}
 	};
 
-	Prism.languages.kum = Prism.languages.kumir;
-
 }(Prism));
diff --git a/components/prism-latex.js b/components/prism-latex.js
index ec2361468bfcf3aebecb83934df01c74859516e5..4897481dc1c1850760d1eb6e40f1de496e9be370 100644
--- a/components/prism-latex.js
+++ b/components/prism-latex.js
@@ -7,7 +7,7 @@
 		}
 	};
 
-	Prism.languages.latex = {
+	Prism.languages.context = Prism.languages.tex = Prism.languages.latex = {
 		'comment': /%.*/,
 		// the verbatim environment prints whitespace to the document
 		'cdata': {
@@ -59,6 +59,4 @@
 		'punctuation': /[[\]{}&]/
 	};
 
-	Prism.languages.tex = Prism.languages.latex;
-	Prism.languages.context = Prism.languages.latex;
 }(Prism));
diff --git a/components/prism-latte.js b/components/prism-latte.js
index dd877a2323da5ecbf4809677ad817774bf187801..6c854635b2190362c39d57b8f7cd8e9edd183952 100644
--- a/components/prism-latte.js
+++ b/components/prism-latte.js
@@ -14,7 +14,7 @@
 		'php': {
 			pattern: /\S(?:[\s\S]*\S)?/,
 			alias: 'language-php',
-			inside: Prism.languages.php
+			inside: 'php'
 		}
 	};
 
@@ -39,7 +39,7 @@
 						],
 						'php': {
 							pattern: /\S(?:[\s\S]*\S)?/,
-							inside: Prism.languages.php
+							inside: 'php'
 						}
 					}
 				},
@@ -47,16 +47,15 @@
 		},
 	}, markupLatte.tag);
 
-	Prism.hooks.add('before-tokenize', function (env) {
-		if (env.language !== 'latte') {
-			return;
+	Prism.hooks.add('before-tokenize', env => {
+		if (env.language == 'latte') {
+			var lattePattern = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
+			Prism.languages['markup-templating'].buildPlaceholders(env, 'latte', lattePattern);
+			env.grammar = markupLatte;
 		}
-		var lattePattern = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
-		Prism.languages['markup-templating'].buildPlaceholders(env, 'latte', lattePattern);
-		env.grammar = markupLatte;
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'latte');
 	});
 
diff --git a/components/prism-lilypond.js b/components/prism-lilypond.js
index a2e7845ae84c5ec610444327bce76a6b5934a54d..da8d866917e6458444e6fc49adb39b45cea3ae94 100644
--- a/components/prism-lilypond.js
+++ b/components/prism-lilypond.js
@@ -3,17 +3,20 @@
 	var schemeExpression = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source;
 	// allow for up to pow(2, recursivenessLog2) many levels of recursive brace expressions
 	// For some reason, this can't be 4
-	var recursivenessLog2 = 5;
-	for (var i = 0; i < recursivenessLog2; i++) {
-		schemeExpression = schemeExpression.replace(/<expr>/g, function () { return schemeExpression; });
+	for (var i = 0; i < 5; i++) {
+		schemeExpression = schemeExpression.replace(/<expr>/g, schemeExpression);
 	}
 	schemeExpression = schemeExpression.replace(/<expr>/g, /[^\s\S]/.source);
 
+	var inside = {
+		pattern: /[\s\S]+/,
+		alias: 'language-lilypond'
+	};
 
-	var lilypond = Prism.languages.lilypond = {
+	inside.inside = Prism.languages.ly = Prism.languages.lilypond = {
 		'comment': /%(?:(?!\{).*|\{[\s\S]*?%\})/,
 		'embedded-scheme': {
-			pattern: RegExp(/(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(/<expr>/g, function () { return schemeExpression; }), 'm'),
+			pattern: RegExp(/(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(/<expr>/g, schemeExpression), 'm'),
 			lookbehind: true,
 			greedy: true,
 			inside: {
@@ -27,11 +30,7 @@
 							greedy: true,
 							inside: {
 								'punctuation': /^#\{|#\}$/,
-								'lilypond': {
-									pattern: /[\s\S]+/,
-									alias: 'language-lilypond',
-									inside: null // see below
-								}
+								'lilypond': inside
 							}
 						},
 						rest: Prism.languages.scheme
@@ -62,8 +61,4 @@
 		'number': /\b\d+(?:\/\d+)?\b/
 	};
 
-	lilypond['embedded-scheme'].inside['scheme'].inside['embedded-lilypond'].inside['lilypond'].inside = lilypond;
-
-	Prism.languages.ly = lilypond;
-
 }(Prism));
diff --git a/components/prism-liquid.js b/components/prism-liquid.js
index 8b9981a7a608317434691cc41b55194b0919740a..453fbfacc375f65a03ef7a32bbf7015e8d53aa83 100644
--- a/components/prism-liquid.js
+++ b/components/prism-liquid.js
@@ -40,11 +40,11 @@ Prism.languages.liquid = {
 	},
 };
 
-Prism.hooks.add('before-tokenize', function (env) {
+Prism.hooks.add('before-tokenize', env => {
 	var liquidPattern = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g;
 	var insideRaw = false;
 
-	Prism.languages['markup-templating'].buildPlaceholders(env, 'liquid', liquidPattern, function (match) {
+	Prism.languages['markup-templating'].buildPlaceholders(env, 'liquid', liquidPattern, match => {
 		var tagMatch = /^\{%-?\s*(\w+)/.exec(match);
 		if (tagMatch) {
 			var tag = tagMatch[1];
@@ -61,6 +61,6 @@ Prism.hooks.add('before-tokenize', function (env) {
 	});
 });
 
-Prism.hooks.add('after-tokenize', function (env) {
+Prism.hooks.add('after-tokenize', env => {
 	Prism.languages['markup-templating'].tokenizePlaceholders(env, 'liquid');
 });
diff --git a/components/prism-lisp.js b/components/prism-lisp.js
index e0e2392fdeb2147ed6b4de9c608f2de602979c8f..f047f78277ae0b9abab661b3cbbbccf2f6279fc6 100644
--- a/components/prism-lisp.js
+++ b/components/prism-lisp.js
@@ -6,18 +6,14 @@
 	 * @param {string} name
 	 * @returns {RegExp}
 	 */
-	function simple_form(name) {
-		return RegExp(/(\()/.source + '(?:' + name + ')' + /(?=[\s\)])/.source);
-	}
+	var simple_form = name => RegExp(`(\\()(?:${name})(?=[\\s\\)])`);
 	/**
 	 * booleans and numbers
 	 *
 	 * @param {string} pattern
 	 * @returns {RegExp}
 	 */
-	function primitive(pattern) {
-		return RegExp(/([\s([])/.source + '(?:' + pattern + ')' + /(?=[\s)])/.source);
-	}
+	var primitive = pattern => RegExp(`([\\s([])(?:${pattern})(?=[\\s)])`);
 
 	// Patterns in regular expressions
 
@@ -104,7 +100,7 @@
 			}
 		},
 		defun: {
-			pattern: RegExp(par + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + symbol + /\s+\(/.source + nestedPar + /\)/.source),
+			pattern: RegExp(`${par}(?:cl-)?(?:defmacro|defun\\*?)\\s+${symbol}\\s+\\(${nestedPar}\\)`),
 			lookbehind: true,
 			greedy: true,
 			inside: {
@@ -149,11 +145,11 @@
 	var arg = {
 		'lisp-marker': RegExp(marker),
 		'varform': {
-			pattern: RegExp(/\(/.source + symbol + /\s+(?=\S)/.source + nestedPar + /\)/.source),
+			pattern: RegExp(`\\(${symbol}\\s+(?=\\S)${nestedPar}\\)`),
 			inside: language
 		},
 		'argument': {
-			pattern: RegExp(/(^|[\s(])/.source + symbol),
+			pattern: RegExp('(^|[\\s(])' + symbol),
 			lookbehind: true,
 			alias: 'variable'
 		},
@@ -190,8 +186,5 @@
 	language['defun'].inside.arguments = Prism.util.clone(arglist);
 	language['defun'].inside.arguments.inside.sublist = arglist;
 
-	Prism.languages.lisp = language;
-	Prism.languages.elisp = language;
-	Prism.languages.emacs = language;
-	Prism.languages['emacs-lisp'] = language;
+	Prism.languages['emacs-lisp'] = Prism.languages.emacs = Prism.languages.elisp = Prism.languages.lisp = language;
 }(Prism));
diff --git a/components/prism-log.js b/components/prism-log.js
index d84defcb7057b22b12723c1bec5dffc9a1ecab07..80a881bfa6710d5fd3392aa0b59976bb582bb377 100644
--- a/components/prism-log.js
+++ b/components/prism-log.js
@@ -94,14 +94,7 @@ Prism.languages.log = {
 	},
 
 	'date': {
-		pattern: RegExp(
-			/\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source +
-			'|' +
-			/\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source +
-			'|' +
-			/\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source,
-			'i'
-		),
+		pattern: /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))|\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b|\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/i,
 		alias: 'number'
 	},
 	'time': {
diff --git a/components/prism-markdown.js b/components/prism-markdown.js
index 438f8ed8fcb682061959a2bf1be8d467861b7ecd..8374de6804d575a0d119a862933b8d106afdbda1 100644
--- a/components/prism-markdown.js
+++ b/components/prism-markdown.js
@@ -1,415 +1,293 @@
-(function (Prism) {
-
-	// Allow only one line break
-	var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
-
-	/**
-	 * This function is intended for the creation of the bold or italic pattern.
-	 *
-	 * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
-	 *
-	 * _Note:_ Keep in mind that this adds a capturing group.
-	 *
-	 * @param {string} pattern
-	 * @returns {RegExp}
-	 */
-	function createInline(pattern) {
-		pattern = pattern.replace(/<inner>/g, function () { return inner; });
-		return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
-	}
-
-
-	var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
-	var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () { return tableCell; });
-	var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
-
-
-	Prism.languages.markdown = Prism.languages.extend('markup', {});
-	Prism.languages.insertBefore('markdown', 'prolog', {
-		'front-matter-block': {
-			pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
-			lookbehind: true,
-			greedy: true,
-			inside: {
-				'punctuation': /^---|---$/,
-				'front-matter': {
-					pattern: /\S+(?:\s+\S+)*/,
-					alias: ['yaml', 'language-yaml'],
-					inside: Prism.languages.yaml
-				}
+// Allow only one line break
+var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
+
+/**
+ * This function is intended for the creation of the bold or italic pattern.
+ *
+ * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
+ *
+ * _Note:_ Keep in mind that this adds a capturing group.
+ *
+ * @param {RegExp} pattern
+ * @returns {RegExp}
+ */
+var createInline = pattern => RegExp(`((?:^|[^\\\\])(?:\\\\{2})*)(?:${pattern.source.replace(/<inner>/g, inner)})`);
+var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
+var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, tableCell);
+var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
+var markdown = Prism.languages.markdown = Prism.languages.md = Prism.languages.extend('markup', {});
+
+Prism.languages.insertBefore('markdown', 'prolog', {
+	'front-matter-block': {
+		pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'punctuation': /^---|---$/,
+			'front-matter': {
+				pattern: /\S+(?:\s+\S+)*/,
+				alias: ['yaml', 'language-yaml'],
+				inside: 'yaml'
 			}
-		},
-		'blockquote': {
-			// > ...
-			pattern: /^>(?:[\t ]*>)*/m,
-			alias: 'punctuation'
-		},
-		'table': {
-			pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
-			inside: {
-				'table-data-rows': {
-					pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
-					lookbehind: true,
-					inside: {
-						'table-data': {
-							pattern: RegExp(tableCell),
-							inside: Prism.languages.markdown
-						},
-						'punctuation': /\|/
-					}
-				},
-				'table-line': {
-					pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
-					lookbehind: true,
-					inside: {
-						'punctuation': /\||:?-{3,}:?/
-					}
-				},
-				'table-header-row': {
-					pattern: RegExp('^' + tableRow + '$'),
-					inside: {
-						'table-header': {
-							pattern: RegExp(tableCell),
-							alias: 'important',
-							inside: Prism.languages.markdown
-						},
-						'punctuation': /\|/
-					}
-				}
-			}
-		},
-		'code': [
-			{
-				// Prefixed by 4 spaces or 1 tab and preceded by an empty line
-				pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
+		}
+	},
+	'blockquote': {
+		// > ...
+		pattern: /^>(?:[\t ]*>)*/m,
+		alias: 'punctuation'
+	},
+	'table': {
+		pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
+		inside: {
+			'table-data-rows': {
+				pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
 				lookbehind: true,
-				alias: 'keyword'
-			},
-			{
-				// ```optional language
-				// code block
-				// ```
-				pattern: /^```[\s\S]*?^```$/m,
-				greedy: true,
 				inside: {
-					'code-block': {
-						pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
-						lookbehind: true
+					'table-data': {
+						pattern: RegExp(tableCell),
+						inside: markdown
 					},
-					'code-language': {
-						pattern: /^(```).+/,
-						lookbehind: true
-					},
-					'punctuation': /```/
+					'punctuation': /\|/
 				}
-			}
-		],
-		'title': [
-			{
-				// title 1
-				// =======
-
-				// title 2
-				// -------
-				pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
-				alias: 'important',
+			},
+			'table-line': {
+				pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
+				lookbehind: true,
 				inside: {
-					punctuation: /==+$|--+$/
+					'punctuation': /\||:?-{3,}:?/
 				}
 			},
-			{
-				// # title 1
-				// ###### title 6
-				pattern: /(^\s*)#.+/m,
-				lookbehind: true,
-				alias: 'important',
+			'table-header-row': {
+				pattern: RegExp('^' + tableRow + '$'),
 				inside: {
-					punctuation: /^#+|#+$/
+					'table-header': {
+						pattern: RegExp(tableCell),
+						alias: 'important',
+						inside: markdown
+					},
+					'punctuation': /\|/
 				}
 			}
-		],
-		'hr': {
-			// ***
-			// ---
-			// * * *
-			// -----------
-			pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
-			lookbehind: true,
-			alias: 'punctuation'
-		},
-		'list': {
-			// * item
-			// + item
-			// - item
-			// 1. item
-			pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
+		}
+	},
+	'code': [
+		{
+			// Prefixed by 4 spaces or 1 tab and preceded by an empty line
+			pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
 			lookbehind: true,
-			alias: 'punctuation'
-		},
-		'url-reference': {
-			// [id]: http://example.com "Optional title"
-			// [id]: http://example.com 'Optional title'
-			// [id]: http://example.com (Optional title)
-			// [id]: <http://example.com> "Optional title"
-			pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
-			inside: {
-				'variable': {
-					pattern: /^(!?\[)[^\]]+/,
-					lookbehind: true
-				},
-				'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
-				'punctuation': /^[\[\]!:]|[<>]/
-			},
-			alias: 'url'
+			alias: 'keyword'
 		},
-		'bold': {
-			// **strong**
-			// __strong__
-
-			// allow one nested instance of italic text using the same delimiter
-			pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
-			lookbehind: true,
+		{
+			// ```optional language
+			// code block
+			// ```
+			pattern: /^```[\s\S]*?^```$/m,
 			greedy: true,
 			inside: {
-				'content': {
-					pattern: /(^..)[\s\S]+(?=..$)/,
-					lookbehind: true,
-					inside: {} // see below
+				'code-block': {
+					pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
+					lookbehind: true
 				},
-				'punctuation': /\*\*|__/
-			}
-		},
-		'italic': {
-			// *em*
-			// _em_
-
-			// allow one nested instance of bold text using the same delimiter
-			pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
-			lookbehind: true,
-			greedy: true,
-			inside: {
-				'content': {
-					pattern: /(^.)[\s\S]+(?=.$)/,
-					lookbehind: true,
-					inside: {} // see below
+				'code-language': {
+					pattern: /^(```).+/,
+					lookbehind: true
 				},
-				'punctuation': /[*_]/
+				'punctuation': /```/
 			}
-		},
-		'strike': {
-			// ~~strike through~~
-			// ~strike~
-			// eslint-disable-next-line regexp/strict
-			pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
-			lookbehind: true,
-			greedy: true,
+		}
+	],
+	'title': [
+		{
+			// title 1
+			// =======
+
+			// title 2
+			// -------
+			pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
+			alias: 'important',
 			inside: {
-				'content': {
-					pattern: /(^~~?)[\s\S]+(?=\1$)/,
-					lookbehind: true,
-					inside: {} // see below
-				},
-				'punctuation': /~~?/
+				punctuation: /==+$|--+$/
 			}
 		},
-		'code-snippet': {
-			// `code`
-			// ``code``
-			pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
+		{
+			// # title 1
+			// ###### title 6
+			pattern: /(^\s*)#.+/m,
 			lookbehind: true,
-			greedy: true,
-			alias: ['code', 'keyword']
-		},
-		'url': {
-			// [example](http://example.com "Optional title")
-			// [example][id]
-			// [example] [id]
-			pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
-			lookbehind: true,
-			greedy: true,
+			alias: 'important',
 			inside: {
-				'operator': /^!/,
-				'content': {
-					pattern: /(^\[)[^\]]+(?=\])/,
-					lookbehind: true,
-					inside: {} // see below
-				},
-				'variable': {
-					pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
-					lookbehind: true
-				},
-				'url': {
-					pattern: /(^\]\()[^\s)]+/,
-					lookbehind: true
-				},
-				'string': {
-					pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
-					lookbehind: true
-				}
+				punctuation: /^#+|#+$/
 			}
 		}
-	});
-
-	['url', 'bold', 'italic', 'strike'].forEach(function (token) {
-		['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
-			if (token !== inside) {
-				Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
-			}
-		});
-	});
-
-	Prism.hooks.add('after-tokenize', function (env) {
-		if (env.language !== 'markdown' && env.language !== 'md') {
-			return;
+	],
+	'hr': {
+		// ***
+		// ---
+		// * * *
+		// -----------
+		pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
+		lookbehind: true,
+		alias: 'punctuation'
+	},
+	'list': {
+		// * item
+		// + item
+		// - item
+		// 1. item
+		pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
+		lookbehind: true,
+		alias: 'punctuation'
+	},
+	'url-reference': {
+		// [id]: http://example.com "Optional title"
+		// [id]: http://example.com 'Optional title'
+		// [id]: http://example.com (Optional title)
+		// [id]: <http://example.com> "Optional title"
+		pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
+		inside: {
+			'variable': {
+				pattern: /^(!?\[)[^\]]+/,
+				lookbehind: true
+			},
+			'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
+			'punctuation': /^[\[\]!:]|[<>]/
+		},
+		alias: 'url'
+	},
+	'bold': {
+		// **strong**
+		// __strong__
+
+		// allow one nested instance of italic text using the same delimiter
+		pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'content': {
+				pattern: /(^..)[\s\S]+(?=..$)/,
+				lookbehind: true,
+				inside: {} // see below
+			},
+			'punctuation': /\*\*|__/
 		}
-
-		function walkTokens(tokens) {
-			if (!tokens || typeof tokens === 'string') {
-				return;
-			}
-
-			for (var i = 0, l = tokens.length; i < l; i++) {
-				var token = tokens[i];
-
-				if (token.type !== 'code') {
-					walkTokens(token.content);
-					continue;
-				}
-
-				/*
-				 * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
-				 * is optional. But the grammar is defined so that there is only one case we have to handle:
-				 *
-				 * token.content = [
-				 *     <span class="punctuation">```</span>,
-				 *     <span class="code-language">xxxx</span>,
-				 *     '\n', // exactly one new lines (\r or \n or \r\n)
-				 *     <span class="code-block">...</span>,
-				 *     '\n', // exactly one new lines again
-				 *     <span class="punctuation">```</span>
-				 * ];
-				 */
-
-				var codeLang = token.content[1];
-				var codeBlock = token.content[3];
-
-				if (codeLang && codeBlock &&
-					codeLang.type === 'code-language' && codeBlock.type === 'code-block' &&
-					typeof codeLang.content === 'string') {
-
-					// this might be a language that Prism does not support
-
-					// do some replacements to support C++, C#, and F#
-					var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp');
-					// only use the first word
-					lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
-					var alias = 'language-' + lang;
-
-					// add alias
-					if (!codeBlock.alias) {
-						codeBlock.alias = [alias];
-					} else if (typeof codeBlock.alias === 'string') {
-						codeBlock.alias = [codeBlock.alias, alias];
-					} else {
-						codeBlock.alias.push(alias);
-					}
-				}
-			}
+	},
+	'italic': {
+		// *em*
+		// _em_
+
+		// allow one nested instance of bold text using the same delimiter
+		pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'content': {
+				pattern: /(^.)[\s\S]+(?=.$)/,
+				lookbehind: true,
+				inside: {} // see below
+			},
+			'punctuation': /[*_]/
 		}
-
-		walkTokens(env.tokens);
-	});
-
-	Prism.hooks.add('wrap', function (env) {
-		if (env.type !== 'code-block') {
-			return;
+	},
+	'strike': {
+		// ~~strike through~~
+		// ~strike~
+		// eslint-disable-next-line regexp/strict
+		pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'content': {
+				pattern: /(^~~?)[\s\S]+(?=\1$)/,
+				lookbehind: true,
+				inside: {} // see below
+			},
+			'punctuation': /~~?/
 		}
-
-		var codeLang = '';
-		for (var i = 0, l = env.classes.length; i < l; i++) {
-			var cls = env.classes[i];
-			var match = /language-(.+)/.exec(cls);
-			if (match) {
-				codeLang = match[1];
-				break;
-			}
+	},
+	'code-snippet': {
+		// `code`
+		// ``code``
+		pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
+		lookbehind: true,
+		greedy: true,
+		alias: ['code', 'keyword']
+	},
+	'url': {
+		// [example](http://example.com "Optional title")
+		// [example][id]
+		// [example] [id]
+		pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/),
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'operator': /^!/,
+			'content': {
+				pattern: /(^\[)[^\]]+(?=\])/,
+				lookbehind: true,
+				inside: {
+					'markup-bracket': markdown['markup-bracket']
+				}
+			},
+			'variable': {
+				pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
+				lookbehind: true
+			},
+			'url': {
+				pattern: /(^\]\()[^\s)]+/,
+				lookbehind: true
+			},
+			'string': {
+				pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
+				lookbehind: true
+			},
+			'markup-bracket': markdown['markup-bracket']
 		}
+	}
+});
 
-		var grammar = Prism.languages[codeLang];
-
-		if (!grammar) {
-			if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
-				var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
-				env.attributes['id'] = id;
-
-				Prism.plugins.autoloader.loadLanguages(codeLang, function () {
-					var ele = document.getElementById(id);
-					if (ele) {
-						ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
-					}
-				});
-			}
-		} else {
-			env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
+['url', 'bold', 'italic', 'strike'].forEach(token => {
+	['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(inside => {
+		if (token != inside) {
+			markdown[token].inside.content.inside[inside] = markdown[inside];
 		}
 	});
-
-	var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');
-
-	/**
-	 * A list of known entity names.
-	 *
-	 * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
-	 *
-	 * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
-	 */
-	var KNOWN_ENTITY_NAMES = {
-		'amp': '&',
-		'lt': '<',
-		'gt': '>',
-		'quot': '"',
-	};
-
-	// IE 11 doesn't support `String.fromCodePoint`
-	var fromCodePoint = String.fromCodePoint || String.fromCharCode;
-
-	/**
-	 * Returns the text content of a given HTML source code string.
-	 *
-	 * @param {string} html
-	 * @returns {string}
-	 */
-	function textContent(html) {
-		// remove all tags
-		var text = html.replace(tagPattern, '');
-
-		// decode known entities
-		text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
-			code = code.toLowerCase();
-
-			if (code[0] === '#') {
-				var value;
-				if (code[1] === 'x') {
-					value = parseInt(code.slice(2), 16);
-				} else {
-					value = Number(code.slice(1));
-				}
-
-				return fromCodePoint(value);
-			} else {
-				var known = KNOWN_ENTITY_NAMES[code];
-				if (known) {
-					return known;
+});
+
+var walkTokens = tokens => {
+	if (Array.isArray(tokens)) for (var i = 0, l = tokens.length; i < l; i++) {
+		var token = tokens[i];
+		var type = token.type;
+
+		if (type) {
+			if (type != 'code') walkTokens(token.content);
+			else {
+				var [, codeLang, , codeBlock] = token.content;
+
+				if (codeBlock && codeLang && codeBlock.type == 'code-block' && codeLang.type == 'code-language') {
+					var language = (/[a-z][\w-]*/i.exec(
+						codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp')
+					) || [''])[0].toLowerCase();
+
+					var alias = 'language-' + language;
+					var blockAlias = codeBlock.alias;
+					var code = codeBlock.content;
+					var grammar = Prism.languages[language];
+
+					if (Array.isArray(blockAlias)) blockAlias.push(alias)
+					else codeBlock.alias = blockAlias ? [blockAlias, alias] : [alias]
+
+					if (grammar && typeof code == 'string') {
+						var env = { code, language, grammar };
+						Prism.hooks.run('before-tokenize', env);
+						codeBlock.content = env.tokens = Prism.tokenize(env.code, env.grammar);
+						Prism.hooks.run('after-tokenize', env);
+					}
 				}
-
-				// unable to decode
-				return m;
 			}
-		});
-
-		return text;
+		}
 	}
+}
 
-	Prism.languages.md = Prism.languages.markdown;
-
-}(Prism));
+Prism.hooks.add('after-tokenize', env => {
+	if (env.language == 'markdown' || env.language == 'md') walkTokens(env.tokens);
+});
diff --git a/components/prism-markup-templating.js b/components/prism-markup-templating.js
index 2855b7c05962c82f9ce2850c769cb09e9ae1c455..c4579913a04b837a0c882ccf2669dd621f89a145 100644
--- a/components/prism-markup-templating.js
+++ b/components/prism-markup-templating.js
@@ -7,9 +7,8 @@
 	 * @param {string|number} index
 	 * @returns {string}
 	 */
-	function getPlaceholder(language, index) {
-		return '___' + language.toUpperCase() + index + '___';
-	}
+	var getPlaceholder = (language, index) =>
+		'___' + language.toUpperCase() + index + '___';
 
 	Object.defineProperties(Prism.languages['markup-templating'] = {}, {
 		buildPlaceholders: {
@@ -24,22 +23,22 @@
 			 * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
 			 * @param {(match: string) => boolean} [replaceFilter]
 			 */
-			value: function (env, language, placeholderPattern, replaceFilter) {
-				if (env.language !== language) {
+			value(env, language, placeholderPattern, replaceFilter) {
+				if (env.language != language) {
 					return;
 				}
 
 				var tokenStack = env.tokenStack = [];
 
-				env.code = env.code.replace(placeholderPattern, function (match) {
-					if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
+				env.code = env.code.replace(placeholderPattern, match => {
+					if (replaceFilter && !replaceFilter(match)) {
 						return match;
 					}
 					var i = tokenStack.length;
 					var placeholder;
 
 					// Check for existing strings
-					while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
+					while (env.code.indexOf(placeholder = getPlaceholder(language, i)) + 1) {
 						++i;
 					}
 
@@ -60,8 +59,8 @@
 			 * @param {object} env The environment of the `after-tokenize` hook.
 			 * @param {string} language The language id.
 			 */
-			value: function (env, language) {
-				if (env.language !== language || !env.tokenStack) {
+			value(env, language) {
+				if (env.language != language || !env.tokenStack) {
 					return;
 				}
 
@@ -71,45 +70,42 @@
 				var j = 0;
 				var keys = Object.keys(env.tokenStack);
 
-				function walkTokens(tokens) {
-					for (var i = 0; i < tokens.length; i++) {
-						// all placeholders are replaced already
-						if (j >= keys.length) {
-							break;
-						}
-
+				var walkTokens = tokens => {
+					for (var i = 0; i < tokens.length && j < keys.length; i++) {
 						var token = tokens[i];
-						if (typeof token === 'string' || (token.content && typeof token.content === 'string')) {
+						var content = token.content;
+						if (Array.isArray(content)) {
+							walkTokens(content);
+						}
+						else {
 							var k = keys[j];
 							var t = env.tokenStack[k];
-							var s = typeof token === 'string' ? token : token.content;
+							var s = content || token;
 							var placeholder = getPlaceholder(language, k);
 
 							var index = s.indexOf(placeholder);
-							if (index > -1) {
+							if (index + 1) {
 								++j;
 
-								var before = s.substring(0, index);
+								var before = s.slice(0, index);
 								var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);
-								var after = s.substring(index + placeholder.length);
+								var after = s.slice(index + placeholder.length);
 
 								var replacement = [];
 								if (before) {
-									replacement.push.apply(replacement, walkTokens([before]));
+									replacement.push(...walkTokens([before]));
 								}
 								replacement.push(middle);
 								if (after) {
-									replacement.push.apply(replacement, walkTokens([after]));
+									replacement.push(...walkTokens([after]));
 								}
 
-								if (typeof token === 'string') {
-									tokens.splice.apply(tokens, [i, 1].concat(replacement));
+								if (!content) {
+									tokens.splice(i, 1, ...replacement);
 								} else {
 									token.content = replacement;
 								}
 							}
-						} else if (token.content /* && typeof token.content !== 'string' */) {
-							walkTokens(token.content);
 						}
 					}
 
diff --git a/components/prism-markup.js b/components/prism-markup.js
index 651c62ee08d8cb4be4cf3535ae25cb931b9e2959..bb783caa07a4640af593cd78bb5f963978f8ae54 100644
--- a/components/prism-markup.js
+++ b/components/prism-markup.js
@@ -1,4 +1,63 @@
-Prism.languages.markup = {
+var markup = Prism.languages.svg = Prism.languages.mathml = Prism.languages.html = Prism.languages.markup = {};
+var entity = [
+	{
+		pattern: /&[\da-z]{1,8};/i,
+		alias: 'named-entity'
+	},
+	/&#x?[\da-f]{1,8};/i
+];
+var specialAttr = [];
+
+var addInlined = (tagName, lang) => ({
+	pattern: RegExp(`(<${tagName}[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/${tagName}>)`, 'i'),
+	lookbehind: true,
+	greedy: true,
+	inside: {
+		'included-cdata': {
+			pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
+			inside: {
+				['language-' + lang]: {
+					pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
+					lookbehind: true,
+					inside: lang
+				},
+				cdata: /^<!\[CDATA\[|\]\]>$/i
+			}
+		},
+		['language-' + lang]: {
+			pattern: /[\s\S]+/,
+			inside: lang
+		}
+	}
+});
+
+var addAttribute = (attrName, lang) => ({
+	pattern: RegExp(`(^|["'\\s])(?:${attrName})\\s*=\\s*(?:"[^"]*"|'[^']*'|[^\\s'">=]+(?=[\\s>]))`, 'i'),
+	lookbehind: true,
+	inside: {
+		'attr-name': /^[^\s=]+/,
+		'attr-value': {
+			pattern: /=[\s\S]+/,
+			inside: {
+				value: {
+					pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
+					lookbehind: true,
+					alias: [lang, 'language-' + lang],
+					inside: lang
+				},
+				'punctuation': [
+					{
+						pattern: /^=/,
+						alias: 'attr-equals'
+					},
+					/"|'/
+				]
+			}
+		}
+	}
+});
+
+Object.assign(markup, {
 	'comment': {
 		pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
 		greedy: true
@@ -16,7 +75,7 @@ Prism.languages.markup = {
 				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
 				lookbehind: true,
 				greedy: true,
-				inside: null // see below
+				inside: markup
 			},
 			'string': {
 				pattern: /"[^"]*"|'[^']*'/,
@@ -42,7 +101,7 @@ Prism.languages.markup = {
 					'namespace': /^[^\s>\/:]+:/
 				}
 			},
-			'special-attr': [],
+			'special-attr': specialAttr,
 			'attr-value': {
 				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
 				inside: {
@@ -55,7 +114,8 @@ Prism.languages.markup = {
 							pattern: /^(\s*)["']|["']$/,
 							lookbehind: true
 						}
-					]
+					],
+					entity
 				}
 			},
 			'punctuation': /\/?>/,
@@ -65,122 +125,21 @@ Prism.languages.markup = {
 					'namespace': /^[^\s>\/:]+:/
 				}
 			}
-
 		}
 	},
-	'entity': [
-		{
-			pattern: /&[\da-z]{1,8};/i,
-			alias: 'named-entity'
-		},
-		/&#x?[\da-f]{1,8};/i
-	]
-};
-
-Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
-	Prism.languages.markup['entity'];
-Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;
-
-// Plugin to make entity title show the real entity, idea by Roman Komarov
-Prism.hooks.add('wrap', function (env) {
-
-	if (env.type === 'entity') {
-		env.attributes['title'] = env.content.replace(/&amp;/, '&');
+	entity,
+	'markup-bracket': {
+		pattern: /[\[\](){}]/,
+		alias: 'punctuation'
 	}
 });
 
-Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
-	/**
-	 * Adds an inlined language to markup.
-	 *
-	 * An example of an inlined language is CSS with `<style>` tags.
-	 *
-	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
-	 * case insensitive.
-	 * @param {string} lang The language key.
-	 * @example
-	 * addInlined('style', 'css');
-	 */
-	value: function addInlined(tagName, lang) {
-		var includedCdataInside = {};
-		includedCdataInside['language-' + lang] = {
-			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
-			lookbehind: true,
-			inside: Prism.languages[lang]
-		};
-		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
-
-		var inside = {
-			'included-cdata': {
-				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
-				inside: includedCdataInside
-			}
-		};
-		inside['language-' + lang] = {
-			pattern: /[\s\S]+/,
-			inside: Prism.languages[lang]
-		};
-
-		var def = {};
-		def[tagName] = {
-			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
-			lookbehind: true,
-			greedy: true,
-			inside: inside
-		};
+Prism.languages.rss = Prism.languages.atom = Prism.languages.ssml = Prism.languages.xml = Prism.util.clone(markup);
 
-		Prism.languages.insertBefore('markup', 'cdata', def);
-	}
-});
-Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
-	/**
-	 * Adds an pattern to highlight languages embedded in HTML attributes.
-	 *
-	 * An example of an inlined language is CSS with `style` attributes.
-	 *
-	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
-	 * case insensitive.
-	 * @param {string} lang The language key.
-	 * @example
-	 * addAttribute('style', 'css');
-	 */
-	value: function (attrName, lang) {
-		Prism.languages.markup.tag.inside['special-attr'].push({
-			pattern: RegExp(
-				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
-				'i'
-			),
-			lookbehind: true,
-			inside: {
-				'attr-name': /^[^\s=]+/,
-				'attr-value': {
-					pattern: /=[\s\S]+/,
-					inside: {
-						'value': {
-							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
-							lookbehind: true,
-							alias: [lang, 'language-' + lang],
-							inside: Prism.languages[lang]
-						},
-						'punctuation': [
-							{
-								pattern: /^=/,
-								alias: 'attr-equals'
-							},
-							/"|'/
-						]
-					}
-				}
-			}
-		});
-	}
+Prism.languages.insertBefore('markup', 'cdata', {
+	'style': addInlined('style', 'css'),
+	'script': addInlined('script', 'javascript')
 });
 
-Prism.languages.html = Prism.languages.markup;
-Prism.languages.mathml = Prism.languages.markup;
-Prism.languages.svg = Prism.languages.markup;
-
-Prism.languages.xml = Prism.languages.extend('markup', {});
-Prism.languages.ssml = Prism.languages.xml;
-Prism.languages.atom = Prism.languages.xml;
-Prism.languages.rss = Prism.languages.xml;
+specialAttr[0] = addAttribute('style', 'css');
+specialAttr[1] = addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');
diff --git a/components/prism-maxscript.js b/components/prism-maxscript.js
index ba0a2b218ba535e40c4fb6d35cf84e282a978909..65f9a7d1a416bf9f2829b46d927d1a4588709e73 100644
--- a/components/prism-maxscript.js
+++ b/components/prism-maxscript.js
@@ -2,50 +2,26 @@
 
 	var keywords = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
 
-
 	Prism.languages.maxscript = {
 		'comment': {
-			pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
+			pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/g,
 			greedy: true
 		},
 		'string': {
-			pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
+			pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/g,
 			lookbehind: true,
 			greedy: true
 		},
 		'path': {
-			pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
+			pattern: /\$(?:[\w/\\.*?]|'[^']*')*/g,
 			greedy: true,
 			alias: 'string'
 		},
 
 		'function-call': {
-			pattern: RegExp(
-				'((?:' + (
-					// start of line
-					/^/.source +
-					'|' +
-					// operators and other language constructs
-					/[;=<>+\-*/^({\[]/.source +
-					'|' +
-					// keywords as part of statements
-					/\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source
-				) + ')[ \t]*)' +
-
-				'(?!' + keywords.source + ')' + /[a-z_]\w*\b/.source +
-
-				'(?=[ \t]*(?:' + (
-					// variable
-					'(?!' + keywords.source + ')' + /[a-z_]/.source +
-					'|' +
-					// number
-					/\d|-\.?\d/.source +
-					'|' +
-					// other expressions or literals
-					/[({'"$@#?]/.source
-				) + '))',
-				'im'
-			),
+			pattern: RegExp(`((?:^|[;=<>+\\-*/^({\\[]|\\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\\b)[ \t]*)(?!${
+				keywords.source
+			})[a-z_]\\w*\\b(?=[ \t]*(?:(?!${keywords.source})[a-z_]|\\d|-\\.?\\d|[({'"$@#?]))`, 'img'),
 			lookbehind: true,
 			greedy: true,
 			alias: 'function'
diff --git a/components/prism-mel.js b/components/prism-mel.js
index d05926674552f8c9b3494c00c4512400fd8a2402..7ccf3e2782e905b1c5b4b82029d4a3f4150befd6 100644
--- a/components/prism-mel.js
+++ b/components/prism-mel.js
@@ -1,4 +1,8 @@
-Prism.languages.mel = {
+var statement = {
+	pattern: /[\s\S]+/
+}
+
+statement.inside = Prism.languages.mel = {
 	'comment': {
 		pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
 		greedy: true
@@ -12,10 +16,7 @@ Prism.languages.mel = {
 				pattern: /^`|`$/,
 				alias: 'punctuation'
 			},
-			'statement': {
-				pattern: /[\s\S]+/,
-				inside: null // see below
-			}
+			'statement': statement
 		}
 	},
 	'string': {
@@ -42,5 +43,3 @@ Prism.languages.mel = {
 	'operator': /\+[+=]?|-[-=]?|&&|\|\||[<>]=?|[*\/!=]=?|[%^]/,
 	'punctuation': /[.,:;?\[\](){}]/
 };
-
-Prism.languages.mel['code'].inside['statement'].inside = Prism.languages.mel;
diff --git a/components/prism-mongodb.js b/components/prism-mongodb.js
index 9a4e1d06d01233a214b1a5a3047af28b626afcbe..96b94bf8693d3ab0c1acce52616df5a4c2522776 100644
--- a/components/prism-mongodb.js
+++ b/components/prism-mongodb.js
@@ -39,7 +39,7 @@
 		// aggregation pipeline query modifiers
 		'$comment', '$explain', '$hint', '$max', '$maxTimeMS', '$min', '$orderby', '$query',
 		'$returnKey', '$showDiskLoc', '$natural',
-	];
+	].map(operator => operator.replace('$', '\\$'));
 
 	var builtinFunctions = [
 		'ObjectId',
@@ -56,13 +56,9 @@
 		'UUID',
 	];
 
-	operators = operators.map(function (operator) {
-		return operator.replace('$', '\\$');
-	});
-
 	var operatorsSource = '(?:' + operators.join('|') + ')\\b';
 
-	Prism.languages.mongodb = Prism.languages.extend('javascript', {});
+	Prism.languages.mongodb = Prism.languages.extend('js', {});
 
 	Prism.languages.insertBefore('mongodb', 'string', {
 		'property': {
diff --git a/components/prism-moonscript.js b/components/prism-moonscript.js
index ee1023313425cd534fa985e9e0c12cea91e97cdb..0f3597834242e8d3c263cb0c56a67d376aa970a5 100644
--- a/components/prism-moonscript.js
+++ b/components/prism-moonscript.js
@@ -1,4 +1,9 @@
-Prism.languages.moonscript = {
+var moonscript = {
+	pattern: /(^#\{)[\s\S]+(?=\})/,
+	lookbehind: true
+};
+
+moonscript.inside = Prism.languages.moon = Prism.languages.moonscript = {
 	'comment': /--.*/,
 	'string': [
 		{
@@ -12,11 +17,7 @@ Prism.languages.moonscript = {
 				'interpolation': {
 					pattern: /#\{[^{}]*\}/,
 					inside: {
-						'moonscript': {
-							pattern: /(^#\{)[\s\S]+(?=\})/,
-							lookbehind: true,
-							inside: null // see beow
-						},
+						'moonscript': moonscript,
 						'interpolation-punctuation': {
 							pattern: /#\{|\}/,
 							alias: 'punctuation'
@@ -51,7 +52,3 @@ Prism.languages.moonscript = {
 	'operator': /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
 	'punctuation': /[.,()[\]{}\\]/
 };
-
-Prism.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = Prism.languages.moonscript;
-
-Prism.languages.moon = Prism.languages.moonscript;
diff --git a/components/prism-naniscript.js b/components/prism-naniscript.js
index 9284cc8ee2a14b822d340c6c3cda7ddea58e4767..dedb3a1a01099feb22f44f70acc8046d76b1f98e 100644
--- a/components/prism-naniscript.js
+++ b/components/prism-naniscript.js
@@ -30,7 +30,7 @@
 		]
 	};
 
-	Prism.languages.naniscript = {
+	Prism.languages.nani = Prism.languages.naniscript = {
 		// ; ...
 		'comment': {
 			pattern: /^([\t ]*);.*/m,
@@ -110,61 +110,51 @@
 			}
 		}
 	};
-	Prism.languages.nani = Prism.languages['naniscript'];
-
-	/** @typedef {InstanceType<import("./prism-core")["Token"]>} Token */
 
 	/**
 	 * This hook is used to validate generic-text tokens for balanced brackets.
 	 * Mark token as bad-line when contains not balanced brackets: {},[]
 	 */
-	Prism.hooks.add('after-tokenize', function (env) {
-		/** @type {(Token | string)[]} */
-		var tokens = env.tokens;
-		tokens.forEach(function (token) {
-			if (typeof token !== 'string' && token.type === 'generic-text') {
+	Prism.hooks.add('after-tokenize', env => {
+		if (env.language.slice(0, 4) == "nani") for (var tokens = env.tokens, i = 0, l = tokens.length; i < l; ) {
+			var token = tokens[i++];
+			if (token.type == 'generic-text') {
 				var content = getTextContent(token);
-				if (!isBracketsBalanced(content)) {
+				if (isBadLine(content)) {
 					token.type = 'bad-line';
 					token.content = content;
 				}
 			}
-		});
+		}
 	});
 
 	/**
 	 * @param {string} input
 	 * @returns {boolean}
 	 */
-	function isBracketsBalanced(input) {
-		var brackets = '[]{}';
-		var stack = [];
-		for (var i = 0; i < input.length; i++) {
-			var bracket = input[i];
-			var bracketsIndex = brackets.indexOf(bracket);
-			if (bracketsIndex !== -1) {
-				if (bracketsIndex % 2 === 0) {
-					stack.push(bracketsIndex + 1);
-				} else if (stack.pop() !== bracketsIndex) {
-					return false;
-				}
+	var isBadLine = input => {
+		for (var brackets = '[]{}', stack = [], i = 0, l = input.length; i < l; ) {
+			var bracketsIndex = brackets.indexOf(input[i++]);
+			if (bracketsIndex + 1) {
+				if (bracketsIndex % 2) {
+					if (stack.pop() != bracketsIndex) return true;
+				} else stack.push(bracketsIndex + 1);
 			}
 		}
-		return stack.length === 0;
+		return stack.length;
 	}
 
 	/**
 	 * @param {string | Token | (string | Token)[]} token
 	 * @returns {string}
 	 */
-	function getTextContent(token) {
-		if (typeof token === 'string') {
+	var getTextContent = token => {
+		if (typeof token == 'string') {
 			return token;
-		} else if (Array.isArray(token)) {
+		} if (Array.isArray(token)) {
 			return token.map(getTextContent).join('');
-		} else {
-			return getTextContent(token.content);
 		}
+		return getTextContent(token.content);
 	}
 
 }(Prism));
diff --git a/components/prism-nix.js b/components/prism-nix.js
index d06a76c18c200b6925c08d45c17c1e8cf80e7f59..e989dd095f1b1cb70f97bc8ab992737b2de792d0 100644
--- a/components/prism-nix.js
+++ b/components/prism-nix.js
@@ -1,4 +1,10 @@
-Prism.languages.nix = {
+var interpolation = {
+	// The lookbehind ensures the ${} is not preceded by \ or ''
+	pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
+	lookbehind: true
+};
+
+interpolation.inside = Prism.languages.nix = {
 	'comment': {
 		pattern: /\/\*[\s\S]*?\*\/|#.*/,
 		greedy: true
@@ -7,12 +13,7 @@ Prism.languages.nix = {
 		pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
 		greedy: true,
 		inside: {
-			'interpolation': {
-				// The lookbehind ensures the ${} is not preceded by \ or ''
-				pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
-				lookbehind: true,
-				inside: null // see below
-			}
+			'interpolation': interpolation
 		}
 	},
 	'url': [
@@ -33,5 +34,3 @@ Prism.languages.nix = {
 	'operator': /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
 	'punctuation': /[{}()[\].,:;]/
 };
-
-Prism.languages.nix.string.inside.interpolation.inside = Prism.languages.nix;
diff --git a/components/prism-parigp.js b/components/prism-parigp.js
index 4945e747901e783a3bed0403e08ad0cd646e0c7a..c1eefed3d8705a3470b80de198ae8d2da155b01c 100644
--- a/components/prism-parigp.js
+++ b/components/prism-parigp.js
@@ -7,18 +7,12 @@ Prism.languages.parigp = {
 	// PARI/GP does not care about white spaces at all
 	// so let's process the keywords to build an appropriate regexp
 	// (e.g. "b *r *e *a *k", etc.)
-	'keyword': (function () {
-		var keywords = [
-			'breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x',
-			'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime',
-			'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if',
-			'local', 'my', 'next', 'return', 'until', 'while'
-		];
-		keywords = keywords.map(function (keyword) {
-			return keyword.split('').join(' *');
-		}).join('|');
-		return RegExp('\\b(?:' + keywords + ')\\b');
-	}()),
+	'keyword': RegExp('\\b(?:' + [
+		'breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x',
+		'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime',
+		'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if',
+		'local', 'my', 'next', 'return', 'until', 'while'
+	].map(keyword => keyword.split('').join(' *')).join('|') + ')\\b'),
 	'function': /\b\w(?:[\w ]*\w)?(?= *\()/,
 	'number': {
 		// The lookbehind and the negative lookahead prevent from breaking the .. operator
diff --git a/components/prism-parser.js b/components/prism-parser.js
index 0ee4b87771143ada89458b2f36caa140142a546c..4396da84435135f533ca877929c1956da5d6d4c6 100644
--- a/components/prism-parser.js
+++ b/components/prism-parser.js
@@ -30,7 +30,7 @@
 		'punctuation': /[\[\](){};]/
 	});
 
-	parser = Prism.languages.insertBefore('parser', 'keyword', {
+	Prism.languages.insertBefore('parser', 'keyword', {
 		'parser-comment': {
 			pattern: /(\s)#.*/,
 			lookbehind: true,
@@ -70,4 +70,6 @@
 		}
 	}, parser['tag'].inside['attr-value']);
 
+	delete parser['markup-bracket'];
+
 }(Prism));
diff --git a/components/prism-pascal.js b/components/prism-pascal.js
index 2f9f5c0e0685f1c5cfe835ed33271670abd00cfc..9fc9d2b5e96628b8235f15c275fa6792af899f4e 100644
--- a/components/prism-pascal.js
+++ b/components/prism-pascal.js
@@ -4,7 +4,13 @@
 	Support inline asm ?
 */
 
-Prism.languages.pascal = {
+var asm = {
+	pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
+	lookbehind: true,
+	greedy: true
+}
+
+Prism.languages.objectpascal = asm.inside = Prism.languages.pascal = {
 	'directive': {
 		pattern: /\{\$[\s\S]*?\}/,
 		greedy: true,
@@ -18,12 +24,7 @@ Prism.languages.pascal = {
 		pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
 		greedy: true
 	},
-	'asm': {
-		pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
-		lookbehind: true,
-		greedy: true,
-		inside: null // see below
-	},
+	'asm': asm,
 	'keyword': [
 		{
 			// Turbo Pascal
@@ -62,10 +63,8 @@ Prism.languages.pascal = {
 	'punctuation': /\(\.|\.\)|[()\[\]:;,.]/
 };
 
-Prism.languages.pascal.asm.inside = Prism.languages.extend('pascal', {
+asm.inside = Prism.languages.extend('pascal', {
 	'asm': undefined,
 	'keyword': undefined,
 	'operator': undefined
 });
-
-Prism.languages.objectpascal = Prism.languages.pascal;
diff --git a/components/prism-pascaligo.js b/components/prism-pascaligo.js
index e9f57ebacf7b892592bc4506a249d09392b9f445..e8ec67dcf4eab05b9654185a3867d3bb6634f9c1 100644
--- a/components/prism-pascaligo.js
+++ b/components/prism-pascaligo.js
@@ -3,7 +3,7 @@
 	// Pascaligo is a layer 2 smart contract language for the tezos blockchain
 
 	var braces = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source;
-	var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(/<braces>/g, function () { return braces; });
+	var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(/<braces>/g, braces);
 
 	var pascaligo = Prism.languages.pascaligo = {
 		'comment': /\(\*[\s\S]+?\*\)|\/\/.*/,
@@ -13,18 +13,15 @@
 		},
 		'class-name': [
 			{
-				pattern: RegExp(/(\btype\s+\w+\s+is\s+)<type>/.source.replace(/<type>/g, function () { return type; }), 'i'),
-				lookbehind: true,
-				inside: null // see below
+				pattern: RegExp(/(\btype\s+\w+\s+is\s+)<type>/.source.replace(/<type>/g, type), 'i'),
+				lookbehind: true
 			},
 			{
-				pattern: RegExp(/<type>(?=\s+is\b)/.source.replace(/<type>/g, function () { return type; }), 'i'),
-				inside: null // see below
+				pattern: RegExp(/<type>(?=\s+is\b)/.source.replace(/<type>/g, type), 'i')
 			},
 			{
-				pattern: RegExp(/(:\s*)<type>/.source.replace(/<type>/g, function () { return type; })),
-				lookbehind: true,
-				inside: null // see below
+				pattern: RegExp(/(:\s*)<type>/.source.replace(/<type>/g, type)),
+				lookbehind: true
 			}
 		],
 		'keyword': {
@@ -50,12 +47,12 @@
 		'punctuation': /\(\.|\.\)|[()\[\]:;,.{}]/
 	};
 
-	var classNameInside = ['comment', 'keyword', 'builtin', 'operator', 'punctuation'].reduce(function (accum, key) {
+	var classNameInside = ['comment', 'keyword', 'builtin', 'operator', 'punctuation'].reduce((accum, key) => {
 		accum[key] = pascaligo[key];
 		return accum;
 	}, {});
 
-	pascaligo['class-name'].forEach(function (p) {
+	pascaligo['class-name'].forEach(p => {
 		p.inside = classNameInside;
 	});
 
diff --git a/components/prism-peoplecode.js b/components/prism-peoplecode.js
index 890b412196fd6208453392d3503c3e93b90cff4b..29154de676ae3fdf2dad5d42421eaf284b0db037 100644
--- a/components/prism-peoplecode.js
+++ b/components/prism-peoplecode.js
@@ -1,16 +1,7 @@
-Prism.languages.peoplecode = {
-	'comment': RegExp([
-		// C-style multiline comments
-		/\/\*[\s\S]*?\*\//.source,
-		// REM comments
-		/\bREM[^;]*;/.source,
-		// Nested <* *> comments
-		/<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
-		// /+ +/ comments
-		/\/\+[\s\S]*?\+\//.source,
-	].join('|')),
+Prism.languages.pcode = Prism.languages.peoplecode = {
+	'comment': /\/\*[\s\S]*?\*\/|\bREM[^;]*;|<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>|\/\+[\s\S]*?\+\//,
 	'string': {
-		pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
+		pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/g,
 		greedy: true
 	},
 	'variable': /%\w+/,
@@ -38,5 +29,3 @@ Prism.languages.peoplecode = {
 	'operator': /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
 	'punctuation': /[:.;,()[\]]/
 };
-
-Prism.languages.pcode = Prism.languages.peoplecode;
diff --git a/components/prism-perl.js b/components/prism-perl.js
index 6641fef7d309332bbf90fcbd4c70faa8ed3957e1..6108ec27bc53238adeaf63e76018cba10654b686 100644
--- a/components/prism-perl.js
+++ b/components/prism-perl.js
@@ -20,23 +20,7 @@
 		'string': [
 			{
 				pattern: RegExp(
-					/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source +
-					'(?:' +
-					[
-						// q/.../
-						/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
-
-						// q a...a
-						// eslint-disable-next-line regexp/strict
-						/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
-
-						// q(...)
-						// q{...}
-						// q[...]
-						// q<...>
-						brackets,
-					].join('|') +
-					')'
+					`\\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\\s*(?:([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1|([a-zA-Z0-9])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2|${brackets})`
 				),
 				greedy: true
 			},
@@ -57,24 +41,7 @@
 		'regex': [
 			{
 				pattern: RegExp(
-					/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source +
-					'(?:' +
-					[
-						// m/.../
-						/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
-
-						// m a...a
-						// eslint-disable-next-line regexp/strict
-						/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
-
-						// m(...)
-						// m{...}
-						// m[...]
-						// m<...>
-						brackets,
-					].join('|') +
-					')' +
-					/[msixpodualngc]*/.source
+					`\\b(?:m|qr)(?![a-zA-Z0-9])\\s*(?:([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1|([a-zA-Z0-9])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2|${brackets})[msixpodualngc]*`, 'g'
 				),
 				greedy: true
 			},
@@ -82,26 +49,7 @@
 			// The lookbehinds prevent -s from breaking
 			{
 				pattern: RegExp(
-					/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source +
-					'(?:' +
-					[
-						// s/.../.../
-						// eslint-disable-next-line regexp/strict
-						/([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
-
-						// s a...a...a
-						// eslint-disable-next-line regexp/strict
-						/([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
-
-						// s(...)(...)
-						// s{...}{...}
-						// s[...][...]
-						// s<...><...>
-						// s(...)[...]
-						brackets + /\s*/.source + brackets,
-					].join('|') +
-					')' +
-					/[msixpodualngcer]*/.source
+					`(^|[^-])\\b(?:s|tr|y)(?![a-zA-Z0-9])\\s*(?:([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2|([a-zA-Z0-9])(?:(?!\\3)[^\\\\]|\\\\[\\s\\S])*\\3(?:(?!\\3)[^\\\\]|\\\\[\\s\\S])*\\3|${brackets}\\s*${brackets})[msixpodualngcer]*`, 'g'
 				),
 				lookbehind: true,
 				greedy: true
diff --git a/components/prism-php.js b/components/prism-php.js
index 79e8bd1cdab35fc7522c15a6cb7e6a79dc513342..eb04d70d62c5882e9feb2824fafdb428f8e1273b 100644
--- a/components/prism-php.js
+++ b/components/prism-php.js
@@ -326,16 +326,14 @@
 		},
 	});
 
-	Prism.hooks.add('before-tokenize', function (env) {
-		if (!/<\?/.test(env.code)) {
-			return;
+	Prism.hooks.add('before-tokenize', env => {
+		if (env.code.includes('<?')) {
+			var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
+			Prism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);
 		}
-
-		var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
-		Prism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'php');
 	});
 
diff --git a/components/prism-plant-uml.js b/components/prism-plant-uml.js
index 70dd234507a6e9c0561ddfb85ed091fc82c05a85..12da20de4bede3287979f45c8d5dcde9552ff308 100644
--- a/components/prism-plant-uml.js
+++ b/components/prism-plant-uml.js
@@ -1,6 +1,10 @@
 (function (Prism) {
 	var variable = /\$\w+|%[a-z]+%/;
 
+	var expression = {
+		pattern: /(\[)[^[\]]+(?=\])/,
+		lookbehind: true
+	}
 	var arrowAttr = /\[[^[\]]*\]/.source;
 	var arrowDirection = /(?:[drlu]|do|down|le|left|ri|right|up)/.source;
 	var arrowBody = '(?:-+' + arrowDirection + '-+|\\.+' + arrowDirection + '\\.+|-+(?:' + arrowAttr + '-*)?|' + arrowAttr + '-+|\\.+(?:' + arrowAttr + '\\.*)?|' + arrowAttr + '\\.+)';
@@ -17,7 +21,7 @@
 		')' +
 		arrowSuffix;
 
-	Prism.languages['plant-uml'] = {
+	expression.inside = Prism.languages.plantuml = Prism.languages['plant-uml'] = {
 		'comment': {
 			pattern: /(^[ \t]*)(?:'.*|\/'[\s\S]*?'\/)/m,
 			lookbehind: true,
@@ -45,11 +49,7 @@
 			greedy: true,
 			alias: 'operator',
 			inside: {
-				'expression': {
-					pattern: /(\[)[^[\]]+(?=\])/,
-					lookbehind: true,
-					inside: null // see below
-				},
+				'expression': expression,
 				'punctuation': /\[(?=$|\])|^\]/
 			}
 		},
@@ -96,8 +96,4 @@
 		'punctuation': /[:,;()[\]{}]|\.{3}/
 	};
 
-	Prism.languages['plant-uml'].arrow.inside.expression.inside = Prism.languages['plant-uml'];
-
-	Prism.languages['plantuml'] = Prism.languages['plant-uml'];
-
 }(Prism));
diff --git a/components/prism-powershell.js b/components/prism-powershell.js
index 538026992eaa1ea3fbbf37c377cc14933466413a..a179c4799fa1e5e963f560c1424046d2ba8a1151 100644
--- a/components/prism-powershell.js
+++ b/components/prism-powershell.js
@@ -1,4 +1,8 @@
 (function (Prism) {
+	var string = {
+		pattern: /"(?:`[\s\S]|[^`"])*"/,
+		greedy: true
+	};
 
 	var powershell = Prism.languages.powershell = {
 		'comment': [
@@ -12,11 +16,7 @@
 			}
 		],
 		'string': [
-			{
-				pattern: /"(?:`[\s\S]|[^`"])*"/,
-				greedy: true,
-				inside: null // see below
-			},
+			string,
 			{
 				pattern: /'(?:[^']|'')*'/,
 				greedy: true
@@ -44,7 +44,7 @@
 	};
 
 	// Variable interpolation inside strings, and nested expressions
-	powershell.string[0].inside = {
+	string.inside = {
 		'function': {
 			// Allow for one level of nesting
 			pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
diff --git a/components/prism-pug.js b/components/prism-pug.js
index 0afee3fcb75ea77dc9993ae76d1f8bdf2dcdceb1..bf0870e8cf0e355f6292729b828dd0d544f3eddd 100644
--- a/components/prism-pug.js
+++ b/components/prism-pug.js
@@ -7,6 +7,16 @@
 	// - Add explicit support for plain text using |
 	// - Add support for markup embedded in plain text
 
+	var js = Prism.languages.js;
+	var filter_pattern = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source;
+
+	var langMap = {
+		atpl: 'twig',
+		coffee: 'coffeescript',
+		sass: 'scss'
+	}
+	var allFilters = {};
+
 	Prism.languages.pug = {
 
 		// Multiline stuff should appear before the rest
@@ -22,7 +32,7 @@
 		'multiline-script': {
 			pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
 			lookbehind: true,
-			inside: Prism.languages.javascript
+			inside: js
 		},
 
 		// See at the end of the file for known filters
@@ -68,7 +78,7 @@
 					pattern: /^(?:case|default|else|if|unless|when|while)\b/,
 					alias: 'keyword'
 				},
-				rest: Prism.languages.javascript
+				rest: js
 			}
 		},
 		'keyword': {
@@ -95,14 +105,14 @@
 						pattern: /^\+\w+/,
 						alias: 'function'
 					},
-					rest: Prism.languages.javascript
+					rest: js
 				}
 			}
 		],
 		'script': {
 			pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
 			lookbehind: true,
-			inside: Prism.languages.javascript
+			inside: js
 		},
 
 		'plain-text': {
@@ -116,7 +126,7 @@
 				'attributes': [
 					{
 						pattern: /&[^(]+\([^)]+\)/,
-						inside: Prism.languages.javascript
+						inside: js
 					},
 					{
 						pattern: /\([^)]+\)/,
@@ -124,7 +134,7 @@
 							'attr-value': {
 								pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
 								lookbehind: true,
-								inside: Prism.languages.javascript
+								inside: js
 							},
 							'attr-name': /[\w-]+(?=\s*!?=|\s*[,)])/,
 							'punctuation': /[!=(),]+/
@@ -140,49 +150,42 @@
 			{
 				pattern: /(^[\t ]*(?:-|!?=)).+/m,
 				lookbehind: true,
-				inside: Prism.languages.javascript
+				inside: js
 			}
 		],
 		'punctuation': /[.\-!=|]+/
 	};
 
-	var filter_pattern = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source;
-
-	// Non exhaustive list of available filters and associated languages
-	var filters = [
-		{ filter: 'atpl', language: 'twig' },
-		{ filter: 'coffee', language: 'coffeescript' },
+	// Non exhaustive list of available filters
+	[
+		'atpl',
+		'coffee',
 		'ejs',
 		'handlebars',
 		'less',
 		'livescript',
 		'markdown',
-		{ filter: 'sass', language: 'scss' },
+		'sass',
 		'stylus'
-	];
-	var all_filters = {};
-	for (var i = 0, l = filters.length; i < l; i++) {
-		var filter = filters[i];
-		filter = typeof filter === 'string' ? { filter: filter, language: filter } : filter;
-		if (Prism.languages[filter.language]) {
-			all_filters['filter-' + filter.filter] = {
-				pattern: RegExp(filter_pattern.replace('<filter_name>', function () { return filter.filter; }), 'm'),
-				lookbehind: true,
-				inside: {
-					'filter-name': {
-						pattern: /^:[\w-]+/,
-						alias: 'variable'
-					},
-					'text': {
-						pattern: /\S[\s\S]*/,
-						alias: [filter.language, 'language-' + filter.language],
-						inside: Prism.languages[filter.language]
-					}
+	].forEach(filter => {
+		var language = langMap[filter] || filter;
+		allFilters['filter-' + filter] = {
+			pattern: RegExp(filter_pattern.replace('<filter_name>', filter), 'm'),
+			lookbehind: true,
+			inside: {
+				'filter-name': {
+					pattern: /^:[\w-]+/,
+					alias: 'variable'
+				},
+				'text': {
+					pattern: /\S[\s\S]*/,
+					alias: [language, 'language-' + language],
+					inside: language
 				}
-			};
-		}
-	}
+			}
+		};
+	});
 
-	Prism.languages.insertBefore('pug', 'filter', all_filters);
+	Prism.languages.insertBefore('pug', 'filter', allFilters);
 
 }(Prism));
diff --git a/components/prism-puppet.js b/components/prism-puppet.js
index 0dcdbf2f5a6eebafe1e28d21a2c8c748e59cc1f7..913af610062707d1b5e6691e178502e0eaeb4fe3 100644
--- a/components/prism-puppet.js
+++ b/components/prism-puppet.js
@@ -1,5 +1,36 @@
 (function (Prism) {
-	Prism.languages.puppet = {
+	var interpolation = [
+		{
+			// Allow for one nested level of braces inside interpolation
+			pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
+			lookbehind: true,
+			inside: {
+				'short-variable': {
+					// Negative look-ahead prevent wrong highlighting of functions
+					pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
+					lookbehind: true,
+					alias: 'variable',
+					inside: {
+						'punctuation': /::/
+					}
+				},
+				'delimiter': {
+					pattern: /^\$/,
+					alias: 'variable'
+				}
+			}
+		},
+		{
+			pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
+			lookbehind: true,
+			alias: 'variable',
+			inside: {
+				'punctuation': /::/
+			}
+		}
+	];
+
+	interpolation[0].inside.rest = Prism.languages.puppet = {
 		'heredoc': [
 			// Matches the content of a quoted heredoc string (subject to interpolation)
 			{
@@ -8,8 +39,9 @@
 				alias: 'string',
 				inside: {
 					// Matches the end tag
-					'punctuation': /(?=\S).*\S(?= *$)/
+					'punctuation': /(?=\S).*\S(?= *$)/,
 					// See interpolation below
+					'interpolation': interpolation
 				}
 			},
 			// Matches the content of an unquoted heredoc string (no interpolation)
@@ -69,7 +101,7 @@
 				'double-quoted': {
 					pattern: /^"[\s\S]*"$/,
 					inside: {
-						// See interpolation below
+						'interpolation': interpolation
 					}
 				}
 			}
@@ -99,38 +131,4 @@
 		'operator': /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
 		'punctuation': /[\[\]{}().,;]|:+/
 	};
-
-	var interpolation = [
-		{
-			// Allow for one nested level of braces inside interpolation
-			pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
-			lookbehind: true,
-			inside: {
-				'short-variable': {
-					// Negative look-ahead prevent wrong highlighting of functions
-					pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
-					lookbehind: true,
-					alias: 'variable',
-					inside: {
-						'punctuation': /::/
-					}
-				},
-				'delimiter': {
-					pattern: /^\$/,
-					alias: 'variable'
-				},
-				rest: Prism.languages.puppet
-			}
-		},
-		{
-			pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
-			lookbehind: true,
-			alias: 'variable',
-			inside: {
-				'punctuation': /::/
-			}
-		}
-	];
-	Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;
-	Prism.languages.puppet['string'].inside['double-quoted'].inside.interpolation = interpolation;
 }(Prism));
diff --git a/components/prism-pure.js b/components/prism-pure.js
index 993a6641c1731fe958efe73d462b0c470d8a7dad..de922d6abce9d499ace530f1605ef6e2db768098 100644
--- a/components/prism-pure.js
+++ b/components/prism-pure.js
@@ -1,6 +1,23 @@
 (function (Prism) {
 	// https://agraef.github.io/pure-docs/pure.html#lexical-matters
 
+	var inlineLang = {
+		pattern: /%<[\s\S]+?%>/,
+		greedy: true,
+		inside: {
+			'lang': {
+				pattern: /(^%< *)-\*-.+?-\*-/,
+				lookbehind: true,
+				alias: 'comment'
+			},
+			'delimiter': {
+				pattern: /^%<.*|%>$/,
+				alias: 'punctuation'
+			},
+			rest: 'c'
+		}
+	};
+
 	Prism.languages.pure = {
 		'comment': [
 			{
@@ -13,21 +30,7 @@
 			},
 			/#!.+/
 		],
-		'inline-lang': {
-			pattern: /%<[\s\S]+?%>/,
-			greedy: true,
-			inside: {
-				'lang': {
-					pattern: /(^%< *)-\*-.+?-\*-/,
-					lookbehind: true,
-					alias: 'comment'
-				},
-				'delimiter': {
-					pattern: /^%<.*|%>$/,
-					alias: 'punctuation'
-				}
-			}
-		},
+		'inline-lang': inlineLang,
 		'string': {
 			pattern: /"(?:\\.|[^"\\\r\n])*"/,
 			greedy: true
@@ -51,32 +54,21 @@
 	};
 
 	var inlineLanguages = [
-		'c',
-		{ lang: 'c++', alias: 'cpp' },
-		'fortran'
+		'c', 'c++', 'fortran'
 	];
 	var inlineLanguageRe = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
 
-	inlineLanguages.forEach(function (lang) {
-		var alias = lang;
-		if (typeof lang !== 'string') {
-			alias = lang.alias;
-			lang = lang.lang;
-		}
-		if (Prism.languages[alias]) {
-			var o = {};
-			o['inline-lang-' + alias] = {
+	inlineLanguages.forEach(lang => {
+		var alias = lang.replace(/\+/g, 'p');
+		Prism.languages.insertBefore('pure', 'inline-lang', {
+			['inline-lang-' + alias]: {
 				pattern: RegExp(inlineLanguageRe.replace('<lang>', lang.replace(/([.+*?\/\\(){}\[\]])/g, '\\$1')), 'i'),
-				inside: Prism.util.clone(Prism.languages.pure['inline-lang'].inside)
-			};
-			o['inline-lang-' + alias].inside.rest = Prism.util.clone(Prism.languages[alias]);
-			Prism.languages.insertBefore('pure', 'inline-lang', o);
-		}
+				inside: {
+					...inlineLang.inside,
+					rest: alias
+				}
+			}
+		});
 	});
 
-	// C is the default inline language
-	if (Prism.languages.c) {
-		Prism.languages.pure['inline-lang'].inside.rest = Prism.util.clone(Prism.languages.c);
-	}
-
 }(Prism));
diff --git a/components/prism-python.js b/components/prism-python.js
index c1aa1deea15d9d8c678a42d109634e3b27752f3a..9576d8437fd0183b2e1aa2aec5e99c528032c726 100644
--- a/components/prism-python.js
+++ b/components/prism-python.js
@@ -1,4 +1,15 @@
-Prism.languages.python = {
+var inside = {
+	'format-spec': {
+		pattern: /(:)[^:(){}]+(?=\}$)/,
+		lookbehind: true
+	},
+	'conversion-option': {
+		pattern: /![sra](?=[:}]$)/,
+		alias: 'punctuation'
+	}
+};
+
+inside.rest = Prism.languages.py = Prism.languages.python = {
 	'comment': {
 		pattern: /(^|[^\\])#.*/,
 		lookbehind: true,
@@ -12,17 +23,7 @@ Prism.languages.python = {
 				// "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
 				pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
 				lookbehind: true,
-				inside: {
-					'format-spec': {
-						pattern: /(:)[^:(){}]+(?=\}$)/,
-						lookbehind: true
-					},
-					'conversion-option': {
-						pattern: /![sra](?=[:}]$)/,
-						alias: 'punctuation'
-					},
-					rest: null
-				}
+				inside: inside
 			},
 			'string': /[\s\S]+/
 		}
@@ -37,7 +38,7 @@ Prism.languages.python = {
 		greedy: true
 	},
 	'function': {
-		pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
+		pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
 		lookbehind: true
 	},
 	'class-name': {
@@ -59,7 +60,3 @@ Prism.languages.python = {
 	'operator': /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
 	'punctuation': /[{}[\];(),.:]/
 };
-
-Prism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;
-
-Prism.languages.py = Prism.languages.python;
diff --git a/components/prism-qml.js b/components/prism-qml.js
index e0b6971a4e658218ebf7862f6169358fef978853..b05ffa10258d049a714b5fb11c8e6e6d0ee85d23 100644
--- a/components/prism-qml.js
+++ b/components/prism-qml.js
@@ -4,11 +4,11 @@
 	var jsComment = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source;
 
 	var jsExpr = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/
-		.source.replace(/<string>/g, function () { return jsString; }).replace(/<comment>/g, function () { return jsComment; });
+		.source.replace(/<string>/g, jsString).replace(/<comment>/g, jsComment);
 
 	// the pattern will blow up, so only a few iterations
 	for (var i = 0; i < 2; i++) {
-		jsExpr = jsExpr.replace(/<expr>/g, function () { return jsExpr; });
+		jsExpr = jsExpr.replace(/<expr>/g, jsExpr);
 	}
 	jsExpr = jsExpr.replace(/<expr>/g, '[^\\s\\S]');
 
@@ -19,11 +19,11 @@
 			greedy: true
 		},
 		'javascript-function': {
-			pattern: RegExp(/((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(/<js>/g, function () { return jsExpr; }), 'm'),
+			pattern: RegExp(/((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(/<js>/g, jsExpr), 'm'),
 			lookbehind: true,
 			greedy: true,
 			alias: 'language-javascript',
-			inside: Prism.languages.javascript
+			inside: Prism.languages.js
 		},
 		'class-name': {
 			pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
@@ -44,11 +44,11 @@
 			}
 		],
 		'javascript-expression': {
-			pattern: RegExp(/(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(/<js>/g, function () { return jsExpr; }), 'm'),
+			pattern: RegExp(/(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(/<js>/g, jsExpr), 'm'),
 			lookbehind: true,
 			greedy: true,
 			alias: 'language-javascript',
-			inside: Prism.languages.javascript
+			inside: Prism.languages.js
 		},
 		'string': {
 			pattern: /"(?:\\.|[^\\"\r\n])*"/,
diff --git a/components/prism-qsharp.js b/components/prism-qsharp.js
index f8c403559fe870def0d0f2835ecfb16e90faca48..80ad9ea0e0177fdf230229593e9b16fa7fceff4e 100644
--- a/components/prism-qsharp.js
+++ b/components/prism-qsharp.js
@@ -10,20 +10,16 @@
 	 * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.
 	 * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source
 	 */
-	function replace(pattern, replacements) {
-		return pattern.replace(/<<(\d+)>>/g, function (m, index) {
-			return '(?:' + replacements[+index] + ')';
-		});
-	}
+	var replace = (pattern, replacements) =>
+		pattern.replace(/<<(\d+)>>/g, (m, index) => '(?:' + replacements[+index] + ')');
 	/**
 	 * @param {string} pattern
 	 * @param {string[]} replacements
 	 * @param {string} [flags]
 	 * @returns {RegExp}
 	 */
-	function re(pattern, replacements, flags) {
-		return RegExp(replace(pattern, replacements), flags || '');
-	}
+	var re = (pattern, replacements, flags) =>
+		RegExp(replace(pattern, replacements), flags || '');
 
 	/**
 	 * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
@@ -32,26 +28,16 @@
 	 * @param {number} depthLog2
 	 * @returns {string}
 	 */
-	function nested(pattern, depthLog2) {
+	var nested = (pattern, depthLog2) => {
 		for (var i = 0; i < depthLog2; i++) {
-			pattern = pattern.replace(/<<self>>/g, function () { return '(?:' + pattern + ')'; });
+			pattern = pattern.replace(/<<self>>/g, `(?:${pattern})`);
 		}
 		return pattern.replace(/<<self>>/g, '[^\\s\\S]');
 	}
 
 	// https://docs.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/
 	// https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language/5_Grammar
-	var keywordKinds = {
-		// keywords which represent a return or variable type
-		type: 'Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero',
-		// all other keywords
-		other: 'Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within'
-	};
-	// keywords
-	function keywordsToPattern(words) {
-		return '\\b(?:' + words.trim().replace(/ /g, '|') + ')\\b';
-	}
-	var keywords = RegExp(keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.other));
+	var keywords = /\b(?:Adj|BigInt|Bool|Ctl|Double|false|Int|One|Pauli|PauliI|PauliX|PauliY|PauliZ|Qubit|Range|Result|String|true|Unit|Zero|Adjoint|adjoint|apply|as|auto|body|borrow|borrowing|Controlled|controlled|distribute|elif|else|fail|fixup|for|function|if|in|internal|intrinsic|invert|is|let|mutable|namespace|new|newtype|open|operation|repeat|return|self|set|until|use|using|while|within)\b/;
 
 	// types
 	var identifier = /\b[A-Za-z_]\w*\b/.source;
@@ -65,7 +51,7 @@
 	// strings
 	var regularString = /"(?:\\.|[^\\"])*"/.source;
 
-	Prism.languages.qsharp = Prism.languages.extend('clike', {
+	Prism.languages.qs = Prism.languages.qsharp = Prism.languages.extend('clike', {
 		'comment': /\/\/.*/,
 		'string': [
 			{
@@ -118,7 +104,7 @@
 						'expression': {
 							pattern: /[\s\S]+/,
 							alias: 'language-qsharp',
-							inside: Prism.languages.qsharp
+							inside: Prism.languages.qs
 						}
 					}
 				},
@@ -128,5 +114,3 @@
 	});
 
 }(Prism));
-
-Prism.languages.qs = Prism.languages.qsharp;
diff --git a/components/prism-robotframework.js b/components/prism-robotframework.js
index 8e043452eb1f752b89e77959fd03e594812ee7ee..14bb9351d2fcf50d8bc48c9c2bd860eee8bf7bb8 100644
--- a/components/prism-robotframework.js
+++ b/components/prism-robotframework.js
@@ -14,7 +14,7 @@
 		}
 	};
 
-	function createSection(name, inside) {
+	var createSection = (name, inside) => {
 		var extendecInside = {};
 
 		extendecInside['section-header'] = {
@@ -22,10 +22,7 @@
 			alias: 'keyword'
 		};
 
-		// copy inside tokens
-		for (var token in inside) {
-			extendecInside[token] = inside[token];
-		}
+		Object.assign(extendecInside, inside)
 
 		extendecInside['tag'] = {
 			pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
@@ -38,7 +35,7 @@
 		extendecInside['comment'] = comment;
 
 		return {
-			pattern: RegExp(/^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(/<name>/g, function () { return name; }), 'im'),
+			pattern: RegExp(/^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(/<name>/g, name), 'im'),
 			alias: 'section',
 			inside: extendecInside
 		};
@@ -68,7 +65,7 @@
 		}
 	};
 
-	Prism.languages['robotframework'] = {
+	Prism.languages.robot = Prism.languages.robotframework = {
 		'settings': createSection('Settings', {
 			'documentation': {
 				pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
@@ -99,6 +96,4 @@
 		'comment': comment
 	};
 
-	Prism.languages.robot = Prism.languages['robotframework'];
-
 }(Prism));
diff --git a/components/prism-ruby.js b/components/prism-ruby.js
index 79256dcf8aa84b7f9ec263513900238a611ddd81..f829dca279186212ac450f78585817cc7985a596 100644
--- a/components/prism-ruby.js
+++ b/components/prism-ruby.js
@@ -5,7 +5,8 @@
  *     constant, builtin, variable, symbol, regex
  */
 (function (Prism) {
-	Prism.languages.ruby = Prism.languages.extend('clike', {
+
+	var ruby = Prism.languages.rb = Prism.languages.ruby = Prism.languages.extend('clike', {
 		'comment': {
 			pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
 			greedy: true
@@ -22,13 +23,6 @@
 		'punctuation': /[(){}[\].,;]/,
 	});
 
-	Prism.languages.insertBefore('ruby', 'operator', {
-		'double-colon': {
-			pattern: /::/,
-			alias: 'punctuation'
-		},
-	});
-
 	var interpolation = {
 		pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
 		lookbehind: true,
@@ -36,7 +30,7 @@
 			'content': {
 				pattern: /^(#\{)[\s\S]+(?=\}$)/,
 				lookbehind: true,
-				inside: Prism.languages.ruby
+				inside: ruby
 			},
 			'delimiter': {
 				pattern: /^#\{|\}$/,
@@ -45,8 +39,6 @@
 		}
 	};
 
-	delete Prism.languages.ruby.function;
-
 	var percentExpression = '(?:' + [
 		/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
 		/\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
@@ -57,10 +49,18 @@
 
 	var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
 
+	delete ruby.function;
+	Prism.languages.insertBefore('ruby', 'operator', {
+		'double-colon': {
+			pattern: /::/,
+			alias: 'punctuation'
+		},
+	});
+	
 	Prism.languages.insertBefore('ruby', 'keyword', {
 		'regex-literal': [
 			{
-				pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
+				pattern: RegExp(`%r${percentExpression}[egimnosux]{0,6}`),
 				greedy: true,
 				inside: {
 					'interpolation': interpolation,
@@ -178,12 +178,10 @@
 		]
 	});
 
-	delete Prism.languages.ruby.string;
+	delete ruby.string;
 
 	Prism.languages.insertBefore('ruby', 'number', {
 		'builtin': /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
 		'constant': /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
 	});
-
-	Prism.languages.rb = Prism.languages.ruby;
 }(Prism));
diff --git a/components/prism-rust.js b/components/prism-rust.js
index 1e873360367c5634ca95c6c203b3cbc771560405..375a3fe0c12a33885b6b48d5aa5f04c53962c3bd 100644
--- a/components/prism-rust.js
+++ b/components/prism-rust.js
@@ -1,14 +1,24 @@
 (function (Prism) {
 
 	var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
+	var string = {
+		pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
+		greedy: true
+	};
+	var paramsInside = {
+		'closure-punctuation': {
+			pattern: /^\||\|$/,
+			alias: 'punctuation'
+		}
+	};
+
 	for (var i = 0; i < 2; i++) {
 		// support 4 levels of nested comments
-		multilineComment = multilineComment.replace(/<self>/g, function () { return multilineComment; });
+		multilineComment = multilineComment.replace(/<self>/g, multilineComment);
 	}
-	multilineComment = multilineComment.replace(/<self>/g, function () { return /[^\s\S]/.source; });
-
+	multilineComment = multilineComment.replace(/<self>/g, /[^\s\S]/.source);
 
-	Prism.languages.rust = {
+	paramsInside.rest = Prism.languages.rust = {
 		'comment': [
 			{
 				pattern: RegExp(/(^|[^\\])/.source + multilineComment),
@@ -21,10 +31,7 @@
 				greedy: true
 			}
 		],
-		'string': {
-			pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
-			greedy: true
-		},
+		'string': string,
 		'char': {
 			pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
 			greedy: true
@@ -34,7 +41,7 @@
 			greedy: true,
 			alias: 'attr-name',
 			inside: {
-				'string': null // see below
+				'string': string
 			}
 		},
 
@@ -43,13 +50,7 @@
 			pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
 			lookbehind: true,
 			greedy: true,
-			inside: {
-				'closure-punctuation': {
-					pattern: /^\||\|$/,
-					alias: 'punctuation'
-				},
-				rest: null // see below
-			}
+			inside: paramsInside
 		},
 
 		'lifetime-annotation': {
@@ -122,7 +123,4 @@
 		'operator': /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
 	};
 
-	Prism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;
-	Prism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];
-
 }(Prism));
diff --git a/components/prism-sas.js b/components/prism-sas.js
index 8d6f3710c0cd80ea36ac7d9a37b74e3994a130d8..b82da0edafa73af02c7224832397e21ece1c1314 100644
--- a/components/prism-sas.js
+++ b/components/prism-sas.js
@@ -100,10 +100,10 @@
 	var actionSets = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source;
 
 	var casActions = {
-		pattern: RegExp(/(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(/<act>/g, function () { return actionSets; }), 'i'),
+		pattern: RegExp(/(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(/<act>/g, actionSets), 'i'),
 		lookbehind: true,
 		inside: {
-			'keyword': RegExp(/(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function () { return actionSets; }), 'i'),
+			'keyword': RegExp(/(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, actionSets), 'i'),
 			'action': {
 				pattern: /(?:action)/i,
 				alias: 'keyword'
@@ -131,9 +131,7 @@
 			lookbehind: true,
 			alias: 'string',
 			inside: {
-				'keyword': {
-					pattern: /^(?:cards|(?:data)?lines)/i
-				},
+				'keyword': /^(?:cards|(?:data)?lines)/i,
 				'punctuation': /;/
 			}
 		},
@@ -143,9 +141,9 @@
 			lookbehind: true,
 			inside: {
 				'sql': {
-					pattern: RegExp(/^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(/<str>/g, function () { return stringPattern; }), 'im'),
+					pattern: RegExp(/^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(/<str>/g, stringPattern), 'im'),
 					alias: 'language-sql',
-					inside: Prism.languages.sql
+					inside: 'sql'
 				},
 				'global-statements': globalStatements,
 				'sql-statements': {
@@ -166,10 +164,10 @@
 			inside: {
 				'comment': comment,
 				'groovy': {
-					pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function () { return stringPattern; }), 'im'),
+					pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, stringPattern), 'im'),
 					lookbehind: true,
 					alias: 'language-groovy',
-					inside: Prism.languages.groovy
+					inside: 'groovy'
 				},
 				'keyword': keywords,
 				'submit-statement': submitStatement,
@@ -187,10 +185,10 @@
 			inside: {
 				'comment': comment,
 				'lua': {
-					pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function () { return stringPattern; }), 'im'),
+					pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, stringPattern), 'im'),
 					lookbehind: true,
 					alias: 'language-lua',
-					inside: Prism.languages.lua
+					inside: 'lua'
 				},
 				'keyword': keywords,
 				'submit-statement': submitStatement,
@@ -241,7 +239,7 @@
 		},
 
 		'proc-args': {
-			pattern: RegExp(/(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(/<str>/g, function () { return stringPattern; }), 'im'),
+			pattern: RegExp(/(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(/<str>/g, stringPattern), 'im'),
 			lookbehind: true,
 			inside: args
 		},
@@ -258,9 +256,7 @@
 				},
 				'macro-keyword': macroKeyword,
 				'macro-variable': macroVariable,
-				'escaped-char': {
-					pattern: /%['"()<>=¬^~;,#]/,
-				},
+				'escaped-char': /%['"()<>=¬^~;,#]/,
 				'punctuation': punctuation
 			}
 		},
diff --git a/components/prism-scala.js b/components/prism-scala.js
index b12f2e6bbf50acbc11884fc53f61c6436ce85952..b030aac43203b2109adc61dbe4cb9ecf7a5bb3fd 100644
--- a/components/prism-scala.js
+++ b/components/prism-scala.js
@@ -1,4 +1,4 @@
-Prism.languages.scala = Prism.languages.extend('java', {
+var scala = Prism.languages.scala = Prism.languages.extend('java', {
 	'triple-quoted-string': {
 		pattern: /"""[\s\S]*?"""/,
 		greedy: true,
@@ -36,7 +36,7 @@ Prism.languages.insertBefore('scala', 'triple-quoted-string', {
 					'punctuation': /^\$\{?|\}$/,
 					'expression': {
 						pattern: /[\s\S]+/,
-						inside: Prism.languages.scala
+						inside: scala
 					}
 				}
 			},
@@ -45,6 +45,6 @@ Prism.languages.insertBefore('scala', 'triple-quoted-string', {
 	}
 });
 
-delete Prism.languages.scala['class-name'];
-delete Prism.languages.scala['function'];
-delete Prism.languages.scala['constant'];
+delete scala['class-name'];
+delete scala['function'];
+delete scala['constant'];
diff --git a/components/prism-scheme.js b/components/prism-scheme.js
index 2409f22ff7ab108f670e2814f9caebdfc2370beb..3ce2ec798867317733c8ff1fae6fe98006ba0c30 100644
--- a/components/prism-scheme.js
+++ b/components/prism-scheme.js
@@ -109,9 +109,7 @@
 	 */
 	function SortedBNF(grammar) {
 		for (var key in grammar) {
-			grammar[key] = grammar[key].replace(/<[\w\s]+>/g, function (key) {
-				return '(?:' + grammar[key].trim() + ')';
-			});
+			grammar[key] = grammar[key].replace(/<[\w\s]+>/g, key => `(?:${grammar[key].trim()})`);
 		}
 		// return the last item
 		return grammar[key];
diff --git a/components/prism-shell-session.js b/components/prism-shell-session.js
index 1b67ed76cfd5fff37d511f973a476efdf7dcd14f..14035285e772a66f218cbe28940dc78d8a18eb1a 100644
--- a/components/prism-shell-session.js
+++ b/components/prism-shell-session.js
@@ -3,39 +3,9 @@
 	// CAREFUL!
 	// The following patterns are concatenated, so the group referenced by a back reference is non-obvious!
 
-	var strings = [
-		// normal string
-		/"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
-		/'[^']*'/.source,
-		/\$'(?:[^'\\]|\\[\s\S])*'/.source,
-
-		// here doc
-		// 2 capturing groups
-		/<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
-	].join('|');
-
-	Prism.languages['shell-session'] = {
+	Prism.languages['sh-session'] = Prism.languages.shellsession = Prism.languages['shell-session'] = {
 		'command': {
-			pattern: RegExp(
-				// user info
-				/^/.source +
-				'(?:' +
-				(
-					// <user> ":" ( <path> )?
-					/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source +
-					'|' +
-					// <path>
-					// Since the path pattern is quite general, we will require it to start with a special character to
-					// prevent false positives.
-					/[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source
-				) +
-				')?' +
-				// shell symbol
-				/[$#%](?=\s)/.source +
-				// bash command
-				/(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(/<<str>>/g, function () { return strings; }),
-				'm'
-			),
+			pattern: /^(?:[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?|[/~.][^\0-\x1F$#%*?"<>@:;|]*)?[$#%](?=\s)(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"|'[^']*'|\$'(?:[^'\\]|\\[\s\S])*'|<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2)+/m,
 			greedy: true,
 			inside: {
 				'info': {
@@ -65,6 +35,4 @@
 		'output': /.(?:.*(?:[\r\n]|.$))*/
 	};
 
-	Prism.languages['sh-session'] = Prism.languages['shellsession'] = Prism.languages['shell-session'];
-
 }(Prism));
diff --git a/components/prism-smarty.js b/components/prism-smarty.js
index a49d103db4f04da5f8b4f904ef0e3effd22b6936..efba963a44db3ea4c1459f9985c4c0e9e5105adc 100644
--- a/components/prism-smarty.js
+++ b/components/prism-smarty.js
@@ -1,6 +1,16 @@
 (function (Prism) {
 
-	Prism.languages.smarty = {
+	var smartyPattern = /\{\*[\s\S]*?\*\}|\{php\}[\s\S]*?\{\/php\}|\{(?:[^{}"']|"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'|\{(?:[^{}"']|"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'|\{(?:[^{}"']|"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*')*\})*\})*\}/g;
+
+	var embedInside = {
+		pattern: /^\{php\}|\{\/php\}$/
+	};
+
+	var expression = {
+		pattern: /[\s\S]+/
+	};
+
+	var smarty = embedInside.inside = expression.inside = Prism.languages.smarty = {
 		'comment': {
 			pattern: /^\{\*[\s\S]*?\*\}/,
 			greedy: true
@@ -9,14 +19,11 @@
 			pattern: /^\{php\}[\s\S]*?\{\/php\}/,
 			greedy: true,
 			inside: {
-				'smarty': {
-					pattern: /^\{php\}|\{\/php\}$/,
-					inside: null // see below
-				},
+				'smarty': embedInside,
 				'php': {
 					pattern: /[\s\S]+/,
 					alias: 'language-php',
-					inside: Prism.languages.php
+					inside: 'php'
 				}
 			}
 		},
@@ -32,10 +39,7 @@
 								pattern: /^[{`]|[`}]$/,
 								alias: 'punctuation'
 							},
-							'expression': {
-								pattern: /[\s\S]+/,
-								inside: null // see below
-							}
+							'expression': expression
 						}
 					},
 					'variable': /\$\w+/
@@ -83,37 +87,20 @@
 		]
 	};
 
-	Prism.languages.smarty['embedded-php'].inside.smarty.inside = Prism.languages.smarty;
-	Prism.languages.smarty.string[0].inside.interpolation.inside.expression.inside = Prism.languages.smarty;
-
-	var string = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/;
-	var smartyPattern = RegExp(
-		// comments
-		/\{\*[\s\S]*?\*\}/.source +
-		'|' +
-		// php tags
-		/\{php\}[\s\S]*?\{\/php\}/.source +
-		'|' +
-		// smarty blocks
-		/\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source
-			.replace(/<str>/g, function () { return string.source; }),
-		'g'
-	);
-
 	// Tokenize all inline Smarty expressions
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		var smartyLiteralStart = '{literal}';
 		var smartyLiteralEnd = '{/literal}';
 		var smartyLiteralMode = false;
 
-		Prism.languages['markup-templating'].buildPlaceholders(env, 'smarty', smartyPattern, function (match) {
+		Prism.languages['markup-templating'].buildPlaceholders(env, 'smarty', smartyPattern, match => {
 			// Smarty tags inside {literal} block are ignored
-			if (match === smartyLiteralEnd) {
+			if (match == smartyLiteralEnd) {
 				smartyLiteralMode = false;
 			}
 
 			if (!smartyLiteralMode) {
-				if (match === smartyLiteralStart) {
+				if (match == smartyLiteralStart) {
 					smartyLiteralMode = true;
 				}
 
@@ -124,7 +111,7 @@
 	});
 
 	// Re-insert the tokens after tokenizing
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'smarty');
 	});
 
diff --git a/components/prism-sml.js b/components/prism-sml.js
index 867df03c09ac080772144e3339c484fb524d4606..7d1be9a371da5fd487f25ea31329b59dcc52b7e9 100644
--- a/components/prism-sml.js
+++ b/components/prism-sml.js
@@ -4,7 +4,26 @@
 
 	var keywords = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
 
-	Prism.languages.sml = {
+	var class0 = {
+		// This is only an approximation since the real grammar is context-free
+		//
+		// Why the main loop so complex?
+		// The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
+		// simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
+		// followed by a long identifier.
+		pattern: RegExp(
+			/((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=\s*(?:[*,]|->))|(?!\s*(?:[*,]|->))\s+<LONG-ID>)))*/.source
+				.replace(/<TERMINAL>/g, 
+					/(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source
+				)
+				.replace(/<LONG-ID>/g, `(?!${keywords.source})[a-z\\d_][\\w'.]*`),
+			'i'
+		),
+		lookbehind: true,
+		greedy: true
+	};
+
+	class0.inside = Prism.languages.smlnj = Prism.languages.sml = {
 		// allow one level of nesting
 		'comment': /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
 		'string': {
@@ -13,27 +32,7 @@
 		},
 
 		'class-name': [
-			{
-				// This is only an approximation since the real grammar is context-free
-				//
-				// Why the main loop so complex?
-				// The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
-				// simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
-				// followed by a long identifier.
-				pattern: RegExp(
-					/((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source
-						.replace(/<NOT-LAST>/g, function () { return /\s*(?:[*,]|->)/.source; })
-						.replace(/<TERMINAL>/g, function () {
-							return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
-						})
-						.replace(/<LONG-ID>/g, function () { return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source; })
-						.replace(/<KEYWORD>/g, function () { return keywords.source; }),
-					'i'
-				),
-				lookbehind: true,
-				greedy: true,
-				inside: null // see below
-			},
+			class0,
 			{
 				pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
 				lookbehind: true
@@ -61,8 +60,4 @@
 		'punctuation': /[(){}\[\].:,;]/
 	};
 
-	Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;
-
-	Prism.languages.smlnj = Prism.languages.sml;
-
 }(Prism));
diff --git a/components/prism-soy.js b/components/prism-soy.js
index 54abe34c61ed3f1f3b6a2589379975eccd033078..1d8c4a77cb3d1ec541faf9066b42c62893720c67 100644
--- a/components/prism-soy.js
+++ b/components/prism-soy.js
@@ -65,13 +65,13 @@
 	};
 
 	// Tokenize all inline Soy expressions
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		var soyPattern = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g;
 		var soyLitteralStart = '{literal}';
 		var soyLitteralEnd = '{/literal}';
 		var soyLitteralMode = false;
 
-		Prism.languages['markup-templating'].buildPlaceholders(env, 'soy', soyPattern, function (match) {
+		Prism.languages['markup-templating'].buildPlaceholders(env, 'soy', soyPattern, match => {
 			// Soy tags inside {literal} block are ignored
 			if (match === soyLitteralEnd) {
 				soyLitteralMode = false;
@@ -89,7 +89,7 @@
 	});
 
 	// Re-insert the tokens after tokenizing
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'soy');
 	});
 
diff --git a/components/prism-stan.js b/components/prism-stan.js
index cab2cfe997dda0adc4ee23079e7e6fb80f2a7f09..ad278a86446ef37c71883ef64bba57f91cea5c3f 100644
--- a/components/prism-stan.js
+++ b/components/prism-stan.js
@@ -4,7 +4,12 @@
 
 	var higherOrderFunctions = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
 
-	Prism.languages.stan = {
+	var expression = {
+		pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
+		lookbehind: true
+	};
+
+	expression.inside = Prism.languages.stan = {
 		'comment': /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
 		'string': {
 			// String literals can contain spaces and any printable ASCII characters except for " and \
@@ -20,11 +25,7 @@
 
 		'function-arg': {
 			pattern: RegExp(
-				'(' +
-				higherOrderFunctions.source +
-				/\s*\(\s*/.source +
-				')' +
-				/[a-zA-Z]\w*/.source
+				`(${higherOrderFunctions.source}\\s*\\(\\s*)[a-zA-Z]\\w*`
 			),
 			lookbehind: true,
 			alias: 'function'
@@ -33,11 +34,7 @@
 			pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
 			lookbehind: true,
 			inside: {
-				'expression': {
-					pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
-					lookbehind: true,
-					inside: null // see below
-				},
+				'expression': expression,
 				'property': /\b[a-z]\w*(?=\s*=)/i,
 				'operator': /=/,
 				'punctuation': /^<|>$|,/
@@ -60,6 +57,4 @@
 		'punctuation': /[()\[\]{},;]/
 	};
 
-	Prism.languages.stan.constraint.inside.expression.inside = Prism.languages.stan;
-
 }(Prism));
diff --git a/components/prism-stata.js b/components/prism-stata.js
index a385bfd957a3ec6c1765b1503b5a76a6853080ba..d2cf0fa492538534db0fa05f9b662e35b63752c2 100644
--- a/components/prism-stata.js
+++ b/components/prism-stata.js
@@ -1,7 +1,11 @@
 // https://www.stata.com/manuals/u.pdf
 // https://www.stata.com/manuals/p.pdf
 
-Prism.languages.stata = {
+var expression = {
+	pattern: /[\s\S]+/
+};
+
+expression.inside = Prism.languages.stata = {
 	'comment': [
 		{
 			pattern: /(^[ \t]*)\*.*/m,
@@ -22,10 +26,7 @@ Prism.languages.stata = {
 				pattern: /\$\{[^{}]*\}|[‘`']\w[^’`'\r\n]*[’`']/,
 				inside: {
 					'punctuation': /^\$\{|\}$/,
-					'expression': {
-						pattern: /[\s\S]+/,
-						inside: null // see below
-					}
+					'expression': expression
 				}
 			},
 			'string': /[\s\S]+/
@@ -51,7 +52,7 @@ Prism.languages.stata = {
 		lookbehind: true,
 		greedy: true,
 		alias: 'language-python',
-		inside: Prism.languages.python
+		inside: Prism.languages.py
 	},
 
 
@@ -72,5 +73,3 @@ Prism.languages.stata = {
 	'operator': /\+\+|--|##?|[<>!=~]=?|[+\-*^&|/]/,
 	'punctuation': /[(){}[\],:]/
 };
-
-Prism.languages.stata['string-literal'].inside.interpolation.inside.expression.inside = Prism.languages.stata;
diff --git a/components/prism-swift.js b/components/prism-swift.js
index 2f6e6e5f43894c457d0693cd946a03a5ca9f4c06..cfa2a23181bab42dfdeab4f008cc9ea184cfbbe6 100644
--- a/components/prism-swift.js
+++ b/components/prism-swift.js
@@ -8,24 +8,13 @@ Prism.languages.swift = {
 	'string-literal': [
 		// https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
 		{
-			pattern: RegExp(
-				/(^|[^"#])/.source
-				+ '(?:'
-				// single-line string
-				+ /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source
-				+ '|'
-				// multi-line string
-				+ /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source
-				+ ')'
-				+ /(?!["#])/.source
-			),
+			pattern: /(^|[^"#])(?:"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"|"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*""")(?!["#])/g,
 			lookbehind: true,
 			greedy: true,
 			inside: {
 				'interpolation': {
 					pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
-					lookbehind: true,
-					inside: null // see below
+					lookbehind: true
 				},
 				'interpolation-punctuation': {
 					pattern: /^\)|\\\($/,
@@ -36,24 +25,13 @@ Prism.languages.swift = {
 			}
 		},
 		{
-			pattern: RegExp(
-				/(^|[^"#])(#+)/.source
-				+ '(?:'
-				// single-line string
-				+ /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source
-				+ '|'
-				// multi-line string
-				+ /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source
-				+ ')'
-				+ '\\2'
-			),
+			pattern: /(^|[^"#])(#+)(?:"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"|"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?""")\2/g,
 			lookbehind: true,
 			greedy: true,
 			inside: {
 				'interpolation': {
 					pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
-					lookbehind: true,
-					inside: null // see below
+					lookbehind: true
 				},
 				'interpolation-punctuation': {
 					pattern: /^\)|\\#+\($/,
@@ -66,22 +44,7 @@ Prism.languages.swift = {
 
 	'directive': {
 		// directives with conditions
-		pattern: RegExp(
-			/#/.source
-			+ '(?:'
-			+ (
-				/(?:elseif|if)\b/.source
-				+ '(?:[ \t]*'
-				// This regex is a little complex. It's equivalent to this:
-				//   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
-				// where <round> is a general parentheses expression.
-				+ /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source
-				+ ')+'
-			)
-			+ '|'
-			+ /(?:else|endif)\b/.source
-			+ ')'
-		),
+		pattern: /#(?:(?:elseif|if)\b(?:[ 	]*(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?)+|(?:else|endif)\b)/,
 		alias: 'property',
 		inside: {
 			'directive-name': /^#\w+/,
@@ -143,6 +106,6 @@ Prism.languages.swift = {
 	'punctuation': /[{}[\]();,.:\\]/
 };
 
-Prism.languages.swift['string-literal'].forEach(function (rule) {
+Prism.languages.swift['string-literal'].forEach(rule => {
 	rule.inside['interpolation'].inside = Prism.languages.swift;
 });
diff --git a/components/prism-systemd.js b/components/prism-systemd.js
index 40204dd7451050e51fce2eadff85518b1bbb6b9f..97b24023ac5697301a4a2f33dc95a2f945ea5079 100644
--- a/components/prism-systemd.js
+++ b/components/prism-systemd.js
@@ -36,18 +36,7 @@
 			//  2) Line continuations.
 			//     After line continuations, empty lines and comments are ignored so we have to consume them.
 			pattern: RegExp(
-				/(=[ \t]*(?!\s))/.source +
-				// the value either starts with quotes or not
-				'(?:' + quotesSource + '|(?=[^"\r\n]))' +
-				// main loop
-				'(?:' + (
-					/[^\s\\]/.source +
-					// handle spaces separately because of quotes
-					'|' + '[ \t]+(?:(?![ \t"])|' + quotesSource + ')' +
-					// line continuation
-					'|' + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source
-				) +
-				')*'
+				`(=[ \\t]*(?!\\s))(?:${quotesSource}|(?=[^"\r\n]))(?:[^\\s\\\\]|[ \t]+(?:(?![ \t"])|${quotesSource})|\\\\[\\r\\n]+(?:[#;].*[\\r\\n]+)*(?![#;]))*`, 'g'
 			),
 			lookbehind: true,
 			greedy: true,
@@ -55,7 +44,7 @@
 			inside: {
 				'comment': comment,
 				'quoted': {
-					pattern: RegExp(/(^|\s)/.source + quotesSource),
+					pattern: RegExp('(^|\\s)' + quotesSource, 'g'),
 					lookbehind: true,
 					greedy: true,
 				},
@@ -67,7 +56,6 @@
 				}
 			}
 		},
-
 		'punctuation': /=/
 	};
 
diff --git a/components/prism-t4-templating.js b/components/prism-t4-templating.js
index b71dd1121f0101c9de176edb2685a4e481ab85c8..56169234e34302394a756bbd2d9c9912ddb26df7 100644
--- a/components/prism-t4-templating.js
+++ b/components/prism-t4-templating.js
@@ -1,48 +1,41 @@
 (function (Prism) {
 
-	function createBlock(prefix, inside, contentAlias) {
-		return {
-			pattern: RegExp('<#' + prefix + '[\\s\\S]*?#>'),
-			alias: 'block',
-			inside: {
-				'delimiter': {
-					pattern: RegExp('^<#' + prefix + '|#>$'),
-					alias: 'important'
-				},
-				'content': {
-					pattern: /[\s\S]+/,
-					inside: inside,
-					alias: contentAlias
-				}
+	var createBlock = (prefix, insideLang) => ({
+		pattern: RegExp(`<#${prefix}[\\s\\S]*?#>`),
+		alias: 'block',
+		inside: {
+			'delimiter': {
+				pattern: RegExp(`^<#${prefix}|#>$`),
+				alias: 'important'
+			},
+			'content': {
+				pattern: /[\s\S]+/,
+				alias: 'language-' + insideLang,
+				inside: insideLang
 			}
-		};
-	}
-
-	function createT4(insideLang) {
-		var grammar = Prism.languages[insideLang];
-		var className = 'language-' + insideLang;
+		}
+	})
 
-		return {
-			'block': {
-				pattern: /<#[\s\S]+?#>/,
-				inside: {
-					'directive': createBlock('@', {
-						'attr-value': {
-							pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
-							inside: {
-								'punctuation': /^=|^["']|["']$/
-							}
-						},
-						'keyword': /\b\w+(?=\s)/,
-						'attr-name': /\b\w+/
-					}),
-					'expression': createBlock('=', grammar, className),
-					'class-feature': createBlock('\\+', grammar, className),
-					'standard': createBlock('', grammar, className)
-				}
+	var createT4 = insideLang => ({
+		'block': {
+			pattern: /<#[\s\S]+?#>/,
+			inside: {
+				'directive': createBlock('@', {
+					'attr-value': {
+						pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
+						inside: {
+							'punctuation': /^=|^["']|["']$/
+						}
+					},
+					'keyword': /\b\w+(?=\s)/,
+					'attr-name': /\b\w+/
+				}),
+				'expression': createBlock('=', insideLang),
+				'class-feature': createBlock('\\+', insideLang),
+				'standard': createBlock('', insideLang)
 			}
-		};
-	}
+		}
+	});
 
 	Prism.languages['t4-templating'] = Object.defineProperty({}, 'createT4', { value: createT4 });
 
diff --git a/components/prism-textile.js b/components/prism-textile.js
index d10d1c5769f6a2d568cbe6b2771e23153b7ea87f..aa3db3ee613b0135e3a00eeef666436c2c2bff0d 100644
--- a/components/prism-textile.js
+++ b/components/prism-textile.js
@@ -1,28 +1,20 @@
 (function (Prism) {
-	// We don't allow for pipes inside parentheses
-	// to not break table pattern |(. foo |). bar |
-	var modifierRegex = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source;
-	// Opening and closing parentheses which are not a modifier
-	// This pattern is necessary to prevent exponential backtracking
-	var parenthesesRegex = /\)|\((?![^|()\n]+\))/.source;
+
 	/**
 	 * @param {string} source
 	 * @param {string} [flags]
 	 */
-	function withModifier(source, flags) {
-		return RegExp(
-			source
-				.replace(/<MOD>/g, function () { return '(?:' + modifierRegex + ')'; })
-				.replace(/<PAR>/g, function () { return '(?:' + parenthesesRegex + ')'; }),
-			flags || '');
-	}
+	var withModifier = (source, flags = '') => RegExp(
+		source
+			.replace(/<MOD>/g, '(?:\\([^|()\\n]+\\)|\\[[^\\]\\n]+\\]|\\{[^}\\n]+\\})')
+			.replace(/<PAR>/g, '(?:\\)|\\((?![^|()\\n]+\\)))'),
+		flags
+	);
 
 	var modifierTokens = {
 		'css': {
 			pattern: /\{[^{}]+\}/,
-			inside: {
-				rest: Prism.languages.css
-			}
+			inside: 'css'
 		},
 		'class-id': {
 			pattern: /(\()[^()]+(?=\))/,
@@ -47,10 +39,10 @@
 
 				// h1. Header 1
 				'block-tag': {
-					pattern: withModifier(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
+					pattern: withModifier('^[a-z]\\w*(?:<MOD>|<PAR>|[<>=])*\\.'),
 					inside: {
 						'modifier': {
-							pattern: withModifier(/(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source),
+							pattern: withModifier('(^[a-z]\\w*)(?:<MOD>|<PAR>|[<>=])+(?=\\.)'),
 							lookbehind: true,
 							inside: modifierTokens
 						},
@@ -62,10 +54,10 @@
 				// # List item
 				// * List item
 				'list': {
-					pattern: withModifier(/^[*#]+<MOD>*\s+\S.*/.source, 'm'),
+					pattern: withModifier('^[*#]+<MOD>*\\s+\\S.*', 'm'),
 					inside: {
 						'modifier': {
-							pattern: withModifier(/(^[*#]+)<MOD>+/.source),
+							pattern: withModifier('(^[*#]+)<MOD>+'),
 							lookbehind: true,
 							inside: modifierTokens
 						},
@@ -122,7 +114,7 @@
 						// @code@
 						'code': {
 							// eslint-disable-next-line regexp/no-super-linear-backtracking
-							pattern: withModifier(/(^@<MOD>*).+?(?=@)/.source),
+							pattern: withModifier('(^@<MOD>*).+?(?=@)'),
 							lookbehind: true,
 							alias: 'keyword'
 						},
@@ -130,26 +122,26 @@
 						// +inserted+
 						'inserted': {
 							// eslint-disable-next-line regexp/no-super-linear-backtracking
-							pattern: withModifier(/(^\+<MOD>*).+?(?=\+)/.source),
+							pattern: withModifier('(^\\+<MOD>*).+?(?=\\+)'),
 							lookbehind: true
 						},
 
 						// -deleted-
 						'deleted': {
 							// eslint-disable-next-line regexp/no-super-linear-backtracking
-							pattern: withModifier(/(^-<MOD>*).+?(?=-)/.source),
+							pattern: withModifier('(^-<MOD>*).+?(?=-)'),
 							lookbehind: true
 						},
 
 						// %span%
 						'span': {
 							// eslint-disable-next-line regexp/no-super-linear-backtracking
-							pattern: withModifier(/(^%<MOD>*).+?(?=%)/.source),
+							pattern: withModifier('(^%<MOD>*).+?(?=%)'),
 							lookbehind: true
 						},
 
 						'modifier': {
-							pattern: withModifier(/(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source),
+							pattern: withModifier('(^\\*\\*|__|\\?\\?|[*_%@+\\-^~])<MOD>+'),
 							lookbehind: true,
 							inside: modifierTokens
 						},
@@ -268,19 +260,14 @@
 
 	// Allow some nesting
 	var phraseInlineInside = phraseInside['inline'].inside;
-	phraseInlineInside['bold'].inside = nestedPatterns;
-	phraseInlineInside['italic'].inside = nestedPatterns;
-	phraseInlineInside['inserted'].inside = nestedPatterns;
-	phraseInlineInside['deleted'].inside = nestedPatterns;
-	phraseInlineInside['span'].inside = nestedPatterns;
-
-	// Allow some styles inside table cells
 	var phraseTableInside = phraseInside['table'].inside;
-	phraseTableInside['inline'] = nestedPatterns['inline'];
-	phraseTableInside['link'] = nestedPatterns['link'];
-	phraseTableInside['image'] = nestedPatterns['image'];
-	phraseTableInside['footnote'] = nestedPatterns['footnote'];
-	phraseTableInside['acronym'] = nestedPatterns['acronym'];
-	phraseTableInside['mark'] = nestedPatterns['mark'];
+	var brackets = textile['markup-bracket'];
+	delete textile['markup-bracket'];
+	textile['markup-bracket'] = brackets;
+
+	['bold', 'italic', 'inserted', 'deleted', 'span'].forEach(p => phraseInlineInside[p].inside = nestedPatterns);
 
+	// Allow some styles inside table cells
+	['inline', 'link', 'image', 'footnote', 'acronym', 'mark'].forEach(p => phraseTableInside[p] = nestedPatterns[p]);
+	
 }(Prism));
diff --git a/components/prism-toml.js b/components/prism-toml.js
index ed985eef0c66674a4e385232d368a0acaa7e3c85..871b00cc6acaf808d14b9e54ba2eb7ab40f004f4 100644
--- a/components/prism-toml.js
+++ b/components/prism-toml.js
@@ -1,13 +1,10 @@
 (function (Prism) {
 
-	var key = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
-
 	/**
 	 * @param {string} pattern
 	 */
-	function insertKey(pattern) {
-		return pattern.replace(/__/g, function () { return key; });
-	}
+	var insertKey = pattern =>
+		pattern.replace(/__/g, `(?:[\\w-]+|'[^'\\n\\r]*'|"(?:\\\\.|[^\\\\"\\r\\n])*")`);
 
 	Prism.languages.toml = {
 		'comment': {
diff --git a/components/prism-tremor.js b/components/prism-tremor.js
index 2dedeb2ab47630514f62c2542c763d4ef7ca0944..ad9c5f5d1e31aac5c5924c1b2407ebc18a61f913 100644
--- a/components/prism-tremor.js
+++ b/components/prism-tremor.js
@@ -1,6 +1,6 @@
 (function (Prism) {
 
-	Prism.languages.tremor = {
+	var tremor = Prism.languages.trickle = Prism.languages.troy = Prism.languages.tremor = {
 		'comment': {
 			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
 			lookbehind: true
@@ -40,14 +40,9 @@
 
 	var interpolationPattern = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
 
-	Prism.languages.tremor['interpolated-string'] = {
+	tremor['interpolated-string'] = {
 		pattern: RegExp(
-			/(^|[^\\])/.source +
-			'(?:' +
-			'"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + '|' + interpolationPattern + ')*"""' +
-			'|' +
-			'"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + '|' + interpolationPattern + ')*"' +
-			')'
+			`(^|[^\\\\])(?:"""(?:[^"\\\\#]|\\\\[\\s\\S]|"(?!"")|#(?!\\{)|${interpolationPattern})*"""|"(?:[^"\\\\\\r\\n#]|\\\\(?:\\r\\n|[\\s\\S])|#(?!\\{)|${interpolationPattern})*")`, 'g'
 		),
 		lookbehind: true,
 		greedy: true,
@@ -58,7 +53,7 @@
 					'punctuation': /^#\{|\}$/,
 					'expression': {
 						pattern: /[\s\S]+/,
-						inside: Prism.languages.tremor
+						inside: tremor
 					}
 				}
 			},
@@ -66,7 +61,4 @@
 		}
 	};
 
-	Prism.languages.troy = Prism.languages['tremor'];
-	Prism.languages.trickle = Prism.languages['tremor'];
-
 }(Prism));
diff --git a/components/prism-tsx.js b/components/prism-tsx.js
index 33b0ec6e1c3deb118180832c5c811a3ffff6cdff..e06ed9b51e84e6ef9e2dd619dd6a5d23c5c209c2 100644
--- a/components/prism-tsx.js
+++ b/components/prism-tsx.js
@@ -1,15 +1,21 @@
 (function (Prism) {
-	var typescript = Prism.util.clone(Prism.languages.typescript);
-	Prism.languages.tsx = Prism.languages.extend('jsx', typescript);
-
+	var typescript = Prism.util.clone(Prism.languages.ts);
+	var tsx = Prism.languages.tsx = Prism.languages.extend('jsx', typescript);
+	var tag = tsx.tag;
+	var bracket = '(';
+	
 	// doesn't work with TS because TS is too complex
-	delete Prism.languages.tsx['parameter'];
-	delete Prism.languages.tsx['literal-property'];
+	delete tsx['parameter'];
+	delete tsx['literal-property'];
 
 	// This will prevent collisions between TSX tags and TS generic types.
 	// Idea by https://github.com/karlhorky
 	// Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928
-	var tag = Prism.languages.tsx.tag;
-	tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);
-	tag.lookbehind = true;
+	try {
+		RegExp('(?<=)');
+		bracket += '?<=';
+	} catch {
+		tag.lookbehind = true;
+	}
+	tag.pattern = RegExp(bracket + `^|[^\\w$]|(?=</))(?:${tag.pattern.source})`, 'g');
 }(Prism));
diff --git a/components/prism-tt2.js b/components/prism-tt2.js
index 7ea37da456f660a4d894350cf2ed6665deeb9cc0..17c4a430d922960bac5d3f1ba3c5734de5bdcf6e 100644
--- a/components/prism-tt2.js
+++ b/components/prism-tt2.js
@@ -8,9 +8,7 @@
 
 	Prism.languages.insertBefore('tt2', 'number', {
 		'operator': /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
-		'variable': {
-			pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
-		}
+		'variable': /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
 	});
 
 	Prism.languages.insertBefore('tt2', 'keyword', {
@@ -31,9 +29,7 @@
 			greedy: true,
 			alias: 'string',
 			inside: {
-				'variable': {
-					pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
-				}
+				'variable': /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
 			}
 		}
 	});
@@ -41,12 +37,12 @@
 	// The different types of TT2 strings "replace" the C-like standard string
 	delete Prism.languages.tt2.string;
 
-	Prism.hooks.add('before-tokenize', function (env) {
+	Prism.hooks.add('before-tokenize', env => {
 		var tt2Pattern = /\[%[\s\S]+?%\]/g;
 		Prism.languages['markup-templating'].buildPlaceholders(env, 'tt2', tt2Pattern);
 	});
 
-	Prism.hooks.add('after-tokenize', function (env) {
+	Prism.hooks.add('after-tokenize', env => {
 		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'tt2');
 	});
 
diff --git a/components/prism-twig.js b/components/prism-twig.js
index 59442d449e0e5485e94d7471739ebc00e031d707..305d902e9f93a1972f4f29f745013264c903659a 100644
--- a/components/prism-twig.js
+++ b/components/prism-twig.js
@@ -30,7 +30,7 @@ Prism.languages.twig = {
 	'punctuation': /[()\[\]{}:.,]/
 };
 
-Prism.hooks.add('before-tokenize', function (env) {
+Prism.hooks.add('before-tokenize', env => {
 	if (env.language !== 'twig') {
 		return;
 	}
@@ -39,6 +39,6 @@ Prism.hooks.add('before-tokenize', function (env) {
 	Prism.languages['markup-templating'].buildPlaceholders(env, 'twig', pattern);
 });
 
-Prism.hooks.add('after-tokenize', function (env) {
+Prism.hooks.add('after-tokenize', env => {
 	Prism.languages['markup-templating'].tokenizePlaceholders(env, 'twig');
 });
diff --git a/components/prism-typescript.js b/components/prism-typescript.js
index 43713a37db1ddb7acba471235f2a4c81730ce53f..9fc2f152ac9682d2802e40a910b58c75354a7d87 100644
--- a/components/prism-typescript.js
+++ b/components/prism-typescript.js
@@ -1,17 +1,16 @@
 (function (Prism) {
 
-	Prism.languages.typescript = Prism.languages.extend('javascript', {
+	var ts = Prism.languages.ts = Prism.languages.typescript = Prism.languages.extend('js', {
 		'class-name': {
 			pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
 			lookbehind: true,
-			greedy: true,
-			inside: null // see below
+			greedy: true
 		},
-		'builtin': /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
+		'builtin': /\b(?:Array|Function|Promise|any|boolean|never|number|string|symbol|unknown)\b/,
 	});
 
 	// The keywords TypeScript adds to JavaScript
-	Prism.languages.typescript.keyword.push(
+	ts.keyword.push(
 		/\b(?:abstract|declare|is|keyof|readonly|require)\b/,
 		// keywords that have to be followed by an identifier
 		/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
@@ -20,14 +19,14 @@
 	);
 
 	// doesn't work with TS because TS is too complex
-	delete Prism.languages.typescript['parameter'];
-	delete Prism.languages.typescript['literal-property'];
+	delete ts['parameter'];
+	delete ts['literal-property'];
 
 	// a version of typescript specifically for highlighting types
-	var typeInside = Prism.languages.extend('typescript', {});
+	var typeInside = Prism.util.clone(ts);
 	delete typeInside['class-name'];
 
-	Prism.languages.typescript['class-name'].inside = typeInside;
+	ts['class-name'].inside = typeInside;
 
 	Prism.languages.insertBefore('typescript', 'function', {
 		'decorator': {
@@ -55,6 +54,4 @@
 		}
 	});
 
-	Prism.languages.ts = Prism.languages.typescript;
-
 }(Prism));
diff --git a/components/prism-typoscript.js b/components/prism-typoscript.js
index 108aba41ab6eddb31e5d7b06751c0ca2cba17e23..57b72570f263cdd5ba7f744ad85f5a6b40aee148 100644
--- a/components/prism-typoscript.js
+++ b/components/prism-typoscript.js
@@ -34,9 +34,7 @@
 							'keyword': keywords,
 						},
 					},
-					'keyword': {
-						pattern: /INCLUDE_TYPOSCRIPT/,
-					},
+					'keyword': /INCLUDE_TYPOSCRIPT/,
 				},
 			},
 			{
diff --git a/components/prism-uri.js b/components/prism-uri.js
index 5831c7dd3bf8ca2f14c74d5139b1c016fae31e9e..effa965c7881f120ae85cd5bb53b53aced2a7a67 100644
--- a/components/prism-uri.js
+++ b/components/prism-uri.js
@@ -1,6 +1,6 @@
 // https://tools.ietf.org/html/rfc3986#appendix-A
 
-Prism.languages.uri = {
+Prism.languages.url = Prism.languages.uri = {
 	'scheme': {
 		pattern: /^[a-z][a-z0-9+.-]*:/im,
 		greedy: true,
@@ -35,24 +35,7 @@ Prism.languages.uri = {
 		}
 	},
 	'authority': {
-		pattern: RegExp(
-			/^\/\//.source
-			// [ userinfo "@" ]
-			+ /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source
-			// host
-			+ (
-				'(?:'
-				// IP-literal
-				+ /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source
-				+ '|'
-				// IPv4address or registered name
-				+ /[\w\-.~!$&'()*+,;=%]*/.source
-				+ ')'
-			)
-			// [ ":" port ]
-			+ /(?::\d*)?/.source,
-			'm'
-		),
+		pattern: /^\/\/(?:[\w\-.~!$&'()*+,;=%:]*@)?(?:\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]|[\w\-.~!$&'()*+,;=%]*)(?::\d*)?/m,
 		inside: {
 			'authority-delimiter': /^\/\//,
 			'user-info-segment': {
@@ -92,5 +75,3 @@ Prism.languages.uri = {
 		}
 	}
 };
-
-Prism.languages.url = Prism.languages.uri;
diff --git a/components/prism-v.js b/components/prism-v.js
index 6fc41b8fae3d1200a6d36be19c1c43ce34012baa..458aac2ac230916768bd98bf033aa5d397601020 100644
--- a/components/prism-v.js
+++ b/components/prism-v.js
@@ -1,10 +1,14 @@
 (function (Prism) {
 	var interpolationExpr = {
-		pattern: /[\s\S]+/,
-		inside: null
+		pattern: /[\s\S]+/
 	};
 
-	Prism.languages.v = Prism.languages.extend('clike', {
+	var generic = {
+		'punctuation': /[<>]/,
+		'class-name': /\w+/
+	};
+
+	interpolationExpr.inside = Prism.languages.v = Prism.languages.extend('clike', {
 		'string': {
 			pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
 			alias: 'quoted-string',
@@ -37,8 +41,6 @@
 		'builtin': /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
 	});
 
-	interpolationExpr.inside = Prism.languages.v;
-
 	Prism.languages.insertBefore('v', 'string', {
 		'char': {
 			pattern: /`(?:\\`|\\?[^`]{1,2})`/, // using {1,2} instead of `u` flag for compatibility
@@ -58,10 +60,7 @@
 		},
 		'generic': {
 			pattern: /<\w+>(?=\s*[\)\{])/,
-			inside: {
-				'punctuation': /[<>]/,
-				'class-name': /\w+/
-			}
+			inside: generic
 		}
 	});
 
@@ -73,7 +72,7 @@
 				'function': /^\w+/,
 				'generic': {
 					pattern: /<\w+>/,
-					inside: Prism.languages.v.generic.inside
+					inside: generic
 				}
 			}
 		}
diff --git a/components/prism-vala.js b/components/prism-vala.js
index 17651cbfa2afe759231f8c5299c20a30463d58d1..1ab61b75f0b6801980e269c5ce76beb68e21887a 100644
--- a/components/prism-vala.js
+++ b/components/prism-vala.js
@@ -75,7 +75,7 @@ Prism.languages.insertBefore('vala', 'keyword', {
 				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
 				lookbehind: true,
 				alias: 'language-regex',
-				inside: Prism.languages.regex
+				inside: 'regex'
 			},
 			'regex-delimiter': /^\//,
 			'regex-flags': /^[a-z]+$/,
diff --git a/components/prism-velocity.js b/components/prism-velocity.js
index a824bb2fcaaf3f998d1ec19222b7ed2b97ed94dc..c468115e6be36f289493fc94caf8255af56eee49 100644
--- a/components/prism-velocity.js
+++ b/components/prism-velocity.js
@@ -1,12 +1,14 @@
 (function (Prism) {
-	Prism.languages.velocity = Prism.languages.extend('markup', {});
+	var vel = Prism.languages.velocity = Prism.languages.extend('markup', {});
+
+	var variable = {
+		pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
+		lookbehind: true,
+		inside: {} // See below
+	}
 
 	var velocity = {
-		'variable': {
-			pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
-			lookbehind: true,
-			inside: {} // See below
-		},
+		'variable': variable,
 		'string': {
 			pattern: /"[^"]*"|'[^']*'/,
 			greedy: true
@@ -17,7 +19,11 @@
 		'punctuation': /[(){}[\]:,.]/
 	};
 
-	velocity.variable.inside = {
+	var brackets = vel['markup-bracket'];
+	delete vel['markup-bracket'];
+	vel['markup-bracket'] = brackets;
+
+	variable.inside = {
 		'string': velocity['string'],
 		'function': {
 			pattern: /([^\w-])[a-z][\w-]*(?=\()/,
@@ -64,9 +70,9 @@
 				rest: velocity
 			}
 		},
-		'variable': velocity['variable']
+		'variable': variable
 	});
 
-	Prism.languages.velocity['tag'].inside['attr-value'].inside.rest = Prism.languages.velocity;
+	vel['tag'].inside['attr-value'].inside.rest = vel;
 
 }(Prism));
diff --git a/components/prism-web-idl.js b/components/prism-web-idl.js
index 939ec8922d465ec15f20d2e9b4028714f0a90733..a46952f56fd3b91391185e44a43ed0d87e523b84 100644
--- a/components/prism-web-idl.js
+++ b/components/prism-web-idl.js
@@ -1,14 +1,7 @@
 (function (Prism) {
 
 	var id = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source;
-	var type =
-		'(?:' +
-		/\b(?:unsigned\s+)?long\s+long(?![\w-])/.source +
-		'|' +
-		/\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source +
-		'|' +
-		/(?!(?:unrestricted|unsigned)\b)/.source + id + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source +
-		')' + /(?:\s*\?)?/.source;
+	var type = `(?:\\b(?:unsigned\\s+)?long\\s+long(?![\\w-])|\\b(?:unrestricted|unsigned)\\s+[a-z]+(?![\\w-])|(?!(?:unrestricted|unsigned)\\b)${id}(?:\\s*<(?:[^<>]|<[^<>]*>)*>)?)(?:\\s*\\?)?`;
 
 	var typeInside = {};
 
@@ -39,7 +32,7 @@
 			},
 			{
 				// callback return type
-				pattern: RegExp('(' + /\bcallback\s+/.source + id + /\s*=\s*/.source + ')' + type),
+				pattern: RegExp(`(\\bcallback\\s+${id}\\s*=\\s*)${type}`),
 				lookbehind: true,
 				inside: typeInside
 			},
@@ -56,20 +49,20 @@
 			},
 			{
 				// inheritance
-				pattern: RegExp(/(:\s*)/.source + id),
+				pattern: RegExp('(:\\s*)' + id),
 				lookbehind: true,
 			},
 
 			// includes and implements
-			RegExp(id + /(?=\s+(?:implements|includes)\b)/.source),
+			RegExp(id + '(?=\\s+(?:implements|includes)\\b)'),
 			{
-				pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + id),
+				pattern: RegExp('(\\b(?:implements|includes)\\s+)' + id),
 				lookbehind: true,
 			},
 
 			{
 				// function return type, parameter types, and dictionary members
-				pattern: RegExp(type + '(?=' + /\s*(?:\.{3}\s*)?/.source + id + /\s*[(),;=]/.source + ')'),
+				pattern: RegExp(`${type}(?=\\s*(?:\\.{3}\\s*)?${id}\\s*[(),;=])`),
 				inside: typeInside
 			},
 		],
diff --git a/components/prism-wiki.js b/components/prism-wiki.js
index d272f9cb8109b0cf7035d848a0a9e6bc77249928..7fd2d72464e15aa35c3326b51ce3bc9aec524785 100644
--- a/components/prism-wiki.js
+++ b/components/prism-wiki.js
@@ -1,3 +1,5 @@
+var tagInside = Prism.languages.markup.tag.inside
+
 Prism.languages.wiki = Prism.languages.extend('markup', {
 	'block-comment': {
 		pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
@@ -62,7 +64,7 @@ Prism.languages.wiki = Prism.languages.extend('markup', {
 				pattern: /\|$/,
 				alias: 'punctuation'
 			},
-			rest: Prism.languages.markup['tag'].inside
+			rest: tagInside
 		}
 	},
 	'punctuation': /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
@@ -75,8 +77,10 @@ Prism.languages.insertBefore('wiki', 'tag', {
 		inside: {
 			'tag': {
 				pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
-				inside: Prism.languages.markup['tag'].inside
+				inside: tagInside
 			}
 		}
 	}
 });
+
+delete Prism.languages.wiki['markup-bracket'];
diff --git a/components/prism-wren.js b/components/prism-wren.js
index 3c65348060422d132ada42dd92972a2645e142c1..feca623aa20645156c4744d2087f4cbc8372fa2c 100644
--- a/components/prism-wren.js
+++ b/components/prism-wren.js
@@ -1,6 +1,11 @@
 // https://wren.io/
 
-Prism.languages.wren = {
+var expression = {
+	pattern: /^(%\()[\s\S]+(?=\)$)/,
+	lookbehind: true
+};
+
+expression.inside = Prism.languages.wren = {
 	// Multiline comments in Wren can have nested multiline comments
 	// Comments: // and /* */
 	'comment': [
@@ -71,30 +76,25 @@ Prism.languages.wren = {
 
 	'operator': /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
 	'punctuation': /[\[\](){}.,;]/,
-};
-
-Prism.languages.wren['string-literal'] = {
-	// A single quote string is multiline and can have interpolation (similar to JS backticks ``)
-	pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
-	lookbehind: true,
-	greedy: true,
-	inside: {
-		'interpolation': {
-			// "%(interpolation)"
-			pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
-			lookbehind: true,
-			inside: {
-				'expression': {
-					pattern: /^(%\()[\s\S]+(?=\)$)/,
-					lookbehind: true,
-					inside: Prism.languages.wren
-				},
-				'interpolation-punctuation': {
-					pattern: /^%\(|\)$/,
-					alias: 'punctuation'
-				},
-			}
-		},
-		'string': /[\s\S]+/
+	'string-literal': {
+		// A single quote string is multiline and can have interpolation (similar to JS backticks ``)
+		pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
+		lookbehind: true,
+		greedy: true,
+		inside: {
+			'interpolation': {
+				// "%(interpolation)"
+				pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
+				lookbehind: true,
+				inside: {
+					'expression': expression,
+					'interpolation-punctuation': {
+						pattern: /^%\(|\)$/,
+						alias: 'punctuation'
+					},
+				}
+			},
+			'string': /[\s\S]+/
+		}
 	}
 };
diff --git a/components/prism-xeora.js b/components/prism-xeora.js
index de33b078f09d2aac23b07c9ca7d09dbe8dd3a74e..cba2b1d9bdb4e167ad6962d36827b4b697701158 100644
--- a/components/prism-xeora.js
+++ b/components/prism-xeora.js
@@ -1,22 +1,16 @@
 (function (Prism) {
-	Prism.languages.xeora = Prism.languages.extend('markup', {
+	var xeora = Prism.languages.xeoracube = Prism.languages.xeora = Prism.languages.extend('markup', {
 		'constant': {
 			pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
 			inside: {
-				'punctuation': {
-					pattern: /\$/
-				}
+				'punctuation': /\$/
 			}
 		},
 		'variable': {
 			pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
 			inside: {
-				'punctuation': {
-					pattern: /[$.]/
-				},
-				'operator': {
-					pattern: /#+|[-+*~=^@]/
-				}
+				'punctuation': /[$.]/,
+				'operator': /#+|[-+*~=^@]/
 			}
 		},
 		'function-inline': {
@@ -25,26 +19,18 @@
 				'variable': {
 					pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
 					inside: {
-						'punctuation': {
-							pattern: /[,.|]/
-						},
-						'operator': {
-							pattern: /#+|[-+*~=^@]/
-						}
+						'punctuation': /[,.|]/,
+						'operator': /#+|[-+*~=^@]/
 					}
 				},
-				'punctuation': {
-					pattern: /\$\w:|[$:?.,|]/
-				}
+				'punctuation': /\$\w:|[$:?.,|]/
 			},
 			alias: 'function'
 		},
 		'function-block': {
 			pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
 			inside: {
-				'punctuation': {
-					pattern: /[$:{}?.,|]/
-				}
+				'punctuation': /[$:{}?.,|]/
 			},
 			alias: 'function'
 		},
@@ -54,9 +40,7 @@
 				'punctuation': {
 					pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
 					inside: {
-						'tag': {
-							pattern: /#\d/
-						}
+						'tag': /#\d/
 					}
 				}
 			},
@@ -68,17 +52,13 @@
 				'punctuation': {
 					pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
 					inside: {
-						'tag': {
-							pattern: /#\d/
-						}
+						'tag': /#\d/
 					}
 				},
 				'attribute': {
 					pattern: /![A-Z]+$/,
 					inside: {
-						'punctuation': {
-							pattern: /!/
-						}
+						'punctuation': /!/
 					},
 					alias: 'keyword'
 				}
@@ -88,27 +68,25 @@
 		'directive-block-separator': {
 			pattern: /\}:[-\w.]+:\{/,
 			inside: {
-				'punctuation': {
-					pattern: /[:{}]/
-				}
+				'punctuation': /[:{}]/
 			},
 			alias: 'function'
 		},
 		'directive-block-close': {
 			pattern: /\}:[-\w.]+\$/,
 			inside: {
-				'punctuation': {
-					pattern: /[:{}$]/
-				}
+				'punctuation': /[:{}$]/
 			},
 			alias: 'function'
 		}
 	});
 
-	Prism.languages.insertBefore('inside', 'punctuation', {
-		'variable': Prism.languages.xeora['function-inline'].inside['variable']
-	}, Prism.languages.xeora['function-block']);
+	var brackets = xeora['markup-bracket'];
+	delete xeora['markup-bracket'];
+	xeora['markup-bracket'] = brackets;
 
-	Prism.languages.xeoracube = Prism.languages.xeora;
+	Prism.languages.insertBefore('inside', 'punctuation', {
+		'variable': xeora['function-inline'].inside['variable']
+	}, xeora['function-block']);
 
 }(Prism));
diff --git a/components/prism-xml-doc.js b/components/prism-xml-doc.js
index 34f8f946fb2ccd5868887d8e0fc7402e5335bdd0..3fa25c4f8894593f87f3585ce6689f1b5733fa11 100644
--- a/components/prism-xml-doc.js
+++ b/components/prism-xml-doc.js
@@ -6,7 +6,7 @@
 	 * @param {string} lang
 	 * @param {any} docComment
 	 */
-	function insertDocComment(lang, docComment) {
+	var insertDocComment = (lang, docComment) => {
 		if (Prism.languages[lang]) {
 			Prism.languages.insertBefore(lang, 'comment', {
 				'doc-comment': docComment
diff --git a/components/prism-xquery.js b/components/prism-xquery.js
index b394d4325a5ee47516e8650a976d45c4901776c3..7aa1955962fde1a2a5349cc6b7179d9233f2808b 100644
--- a/components/prism-xquery.js
+++ b/components/prism-xquery.js
@@ -1,6 +1,6 @@
 (function (Prism) {
 
-	Prism.languages.xquery = Prism.languages.extend('markup', {
+	var xquery = Prism.languages.xquery = Prism.languages.extend('markup', {
 		'xquery-comment': {
 			pattern: /\(:[\s\S]*?:\)/,
 			greedy: true,
@@ -55,108 +55,94 @@
 		'punctuation': /[[\](){},;:/]/
 	});
 
-	Prism.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
-	Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
-	Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^="|"$/;
-	Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {
-		// Allow for two levels of nesting
-		pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
-		inside: Prism.languages.xquery,
-		alias: 'language-xquery'
-	};
-
 	// The following will handle plain text inside tags
-	var stringifyToken = function (token) {
-		if (typeof token === 'string') {
-			return token;
+	var stringifyToken = token => {
+		if (token && token.type) {
+			return Array.isArray(token = token.content) ? token.map(stringifyToken).join('') : token;
 		}
-		if (typeof token.content === 'string') {
-			return token.content;
-		}
-		return token.content.map(stringifyToken).join('');
+		return token || '';
 	};
 
-	var walkTokens = function (tokens) {
-		var openedTags = [];
-		for (var i = 0; i < tokens.length; i++) {
+	var walkTokens = tokens => {
+		for (var i = 0, openedTags = []; i < tokens.length; i++) {
 			var token = tokens[i];
 			var notTagNorBrace = false;
+			var content = token.content;
+			var type = token.type;
+			var last;
 
-			if (typeof token !== 'string') {
-				if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {
+			if (type && type != 'comment') {
+				if (type == 'tag' && content[0].type == 'tag') {
 					// We found a tag, now find its kind
 
-					if (token.content[0].content[0].content === '</') {
+					if (content[0].content[0].content == '</') {
 						// Closing tag
-						if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
+						if (openedTags[0] && openedTags[openedTags.length - 1][0] == stringifyToken(content[0].content[1])) {
 							// Pop matching opening tag
 							openedTags.pop();
 						}
 					} else {
-						if (token.content[token.content.length - 1].content === '/>') {
-							// Autoclosed tag, ignore
-						} else {
+						if (content[content.length - 1].content == '>') {
 							// Opening tag
-							openedTags.push({
-								tagName: stringifyToken(token.content[0].content[1]),
-								openedBraces: 0
-							});
+							openedTags.push([stringifyToken(content[0].content[1]), 0]);
 						}
 					}
-				} else if (
-					openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' &&
-					// Ignore `{{`
-					(!tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') &&
-					(!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')
-				) {
-					// Here we might have entered an XQuery expression inside a tag
-					openedTags[openedTags.length - 1].openedBraces++;
-
-				} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {
-
-					// Here we might have left an XQuery expression inside a tag
-					openedTags[openedTags.length - 1].openedBraces--;
-
-				} else if (token.type !== 'comment') {
+				} else if (openedTags[0] && type == 'punctuation') {
+					last = openedTags[openedTags.length - 1];
+					if (
+						content == "{" && 
+						!(tokens[i + 1] && tokens[i + 1].type == 'punctuation' && tokens[i + 1].content == '{') &&
+						!(tokens[i - 1] && tokens[i - 1].type == 'plain-text' && tokens[i - 1].content == '{')
+					) last[1]++;
+					else if (last[1] && content == "}") last[1]--;
+					else {
+						notTagNorBrace = true;
+					}
+				} else {
 					notTagNorBrace = true;
 				}
 			}
-			if (notTagNorBrace || typeof token === 'string') {
-				if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
+			if (notTagNorBrace || !type) {
+				if (openedTags[0] && !openedTags[openedTags.length - 1][1]) {
 					// Here we are inside a tag, and not inside an XQuery expression.
 					// That's plain text: drop any tokens matched.
 					var plainText = stringifyToken(token);
+					var isText = token => token && (!token.type || token.type == 'plain-text');
 
 					// And merge text with adjacent text
-					if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {
+					if (isText(tokens[i + 1])) {
 						plainText += stringifyToken(tokens[i + 1]);
 						tokens.splice(i + 1, 1);
 					}
-					if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {
+					if (isText(tokens[i - 1])) {
 						plainText = stringifyToken(tokens[i - 1]) + plainText;
 						tokens.splice(i - 1, 1);
 						i--;
 					}
 
-					if (/^\s+$/.test(plainText)) {
-						tokens[i] = plainText;
-					} else {
-						tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);
-					}
+					tokens[i] = plainText.trimEnd() ? new Prism.Token('plain-text', plainText, null, plainText) : plainText;
 				}
 			}
 
-			if (token.content && typeof token.content !== 'string') {
-				walkTokens(token.content);
+			if (Array.isArray(content)) {
+				walkTokens(content);
 			}
 		}
 	};
 
-	Prism.hooks.add('after-tokenize', function (env) {
-		if (env.language !== 'xquery') {
-			return;
-		}
-		walkTokens(env.tokens);
+	xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
+	xquery['tag'].inside['attr-value'].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
+	xquery['tag'].inside['attr-value'].inside['punctuation'] = /^="|"$/;
+	xquery['tag'].inside['attr-value'].inside['expression'] = {
+		// Allow for two levels of nesting
+		pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
+		inside: xquery,
+		alias: 'language-xquery'
+	};
+	delete xquery['markup-bracket'];
+
+	Prism.hooks.add('after-tokenize', env => {
+		if (env.language == 'xquery') walkTokens(env.tokens);
 	});
 
 }(Prism));
diff --git a/components/prism-yaml.js b/components/prism-yaml.js
index a16390bfb2ff39bed7f6a9494c8db80dc0abd17f..1f1255c9413e1f03d2812572ab3b1f9cae928c36 100644
--- a/components/prism-yaml.js
+++ b/components/prism-yaml.js
@@ -6,13 +6,12 @@
 	// https://yaml.org/spec/1.2/spec.html#c-ns-tag-property
 	var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
 	// https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)
-	var properties = '(?:' + tag.source + '(?:[ \t]+' + anchorOrAlias.source + ')?|'
-		+ anchorOrAlias.source + '(?:[ \t]+' + tag.source + ')?)';
+	var properties = `(?:${tag.source}(?:[ \t]+${anchorOrAlias.source})?|${anchorOrAlias.source}(?:[ \t]+${tag.source})?)`;
 	// https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
 	// This is a simplified version that doesn't support "#" and multiline keys
 	// All these long scarry character classes are simplified versions of YAML's characters
 	var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source
-		.replace(/<PLAIN>/g, function () { return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source; });
+		.replace(/<PLAIN>/g, /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source);
 	var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
 
 	/**
@@ -21,25 +20,24 @@
 	 * @param {string} [flags]
 	 * @returns {RegExp}
 	 */
-	function createValuePattern(value, flags) {
-		flags = (flags || '').replace(/m/g, '') + 'm'; // add m flag
-		var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source
-			.replace(/<<prop>>/g, function () { return properties; }).replace(/<<value>>/g, function () { return value; });
-		return RegExp(pattern, flags);
-	}
+	var createValuePattern = (value, flags = 'm') => RegExp(
+		/([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source
+			.replace(/<<prop>>/g, properties).replace(/<<value>>/g, value),
+		flags
+	);
 
-	Prism.languages.yaml = {
+	Prism.languages.yml = Prism.languages.yaml = {
 		'scalar': {
 			pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source
-				.replace(/<<prop>>/g, function () { return properties; })),
+				.replace(/<<prop>>/g, properties)),
 			lookbehind: true,
 			alias: 'string'
 		},
 		'comment': /#.*/,
 		'key': {
 			pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source
-				.replace(/<<prop>>/g, function () { return properties; })
-				.replace(/<<key>>/g, function () { return '(?:' + plainKey + '|' + string + ')'; })),
+				.replace(/<<prop>>/g, properties)
+				.replace(/<<key>>/g, '(?:' + plainKey + '|' + string + ')')),
 			lookbehind: true,
 			greedy: true,
 			alias: 'atrule'
@@ -55,12 +53,12 @@
 			alias: 'number'
 		},
 		'boolean': {
-			pattern: createValuePattern(/false|true/.source, 'i'),
+			pattern: createValuePattern(/false|true/.source, 'im'),
 			lookbehind: true,
 			alias: 'important'
 		},
 		'null': {
-			pattern: createValuePattern(/null|~/.source, 'i'),
+			pattern: createValuePattern(/null|~/.source, 'im'),
 			lookbehind: true,
 			alias: 'important'
 		},
@@ -70,7 +68,7 @@
 			greedy: true
 		},
 		'number': {
-			pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, 'i'),
+			pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, 'im'),
 			lookbehind: true
 		},
 		'tag': tag,
@@ -78,6 +76,4 @@
 		'punctuation': /---|[:[\]{}\-,|>?]|\.\.\./
 	};
 
-	Prism.languages.yml = Prism.languages.yaml;
-
 }(Prism));
diff --git a/components/prism-zig.js b/components/prism-zig.js
index 4f18353a359cd2f519e8952e7af001972b94f5c4..dc22e9ae94083b32931e68b55353a5df29fbbdb9 100644
--- a/components/prism-zig.js
+++ b/components/prism-zig.js
@@ -1,15 +1,11 @@
 (function (Prism) {
 
-	function literal(str) {
-		return function () { return str; };
-	}
-
 	var keyword = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/;
 
 	var IDENTIFIER = '\\b(?!' + keyword.source + ')(?!\\d)\\w+\\b';
 	var ALIGN = /align\s*\((?:[^()]|\([^()]*\))*\)/.source;
-	var PREFIX_TYPE_OP = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));
-	var SUFFIX_EXPR = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));
+	var PREFIX_TYPE_OP = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(/<ALIGN>/g, ALIGN);
+	var SUFFIX_EXPR = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(/<ID>/g, IDENTIFIER);
 	var TYPE = '(?!\\s)(?:!?\\s*(?:' + PREFIX_TYPE_OP + '\\s*)*' + SUFFIX_EXPR + ')+';
 
 	/*
@@ -69,15 +65,15 @@
 				// const x: i32 = 9;
 				// var x: Bar;
 				// fn foo(x: bool, y: f32) void {}
-				pattern: RegExp(/(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),
+				pattern: RegExp(/(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, TYPE).replace(/<ALIGN>/g, ALIGN)),
 				lookbehind: true,
-				inside: null // see below
+				inside: 'zig'
 			},
 			{
 				// extern fn foo(x: f64) f64; (optional alignment)
-				pattern: RegExp(/(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),
+				pattern: RegExp(/(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, TYPE).replace(/<ALIGN>/g, ALIGN)),
 				lookbehind: true,
-				inside: null // see below
+				inside: 'zig'
 			}
 		],
 		'builtin-type': {
@@ -92,10 +88,4 @@
 		'punctuation': /[.:,;(){}[\]]/
 	};
 
-	Prism.languages.zig['class-name'].forEach(function (obj) {
-		if (obj.inside === null) {
-			obj.inside = Prism.languages.zig;
-		}
-	});
-
 }(Prism));